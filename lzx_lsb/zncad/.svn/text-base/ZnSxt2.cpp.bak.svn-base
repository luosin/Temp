#include "stdafx.h"
#include "znsxt.h"
#include "CableInfoDlg.h"
#include "XhlCableInfoDlg.h"
#include "znutility.h"
#include "PolylineUtil.h"
#include "ConvertUtil.h"
#include "EntPropertyDlg.h"
#include "BlockUtil.h"

#include "..\blkuserdll\ViewExtents.h"
#include "BoxNodeEnt.h"

CZnSxt::CZnSxt(void)
: m_pDb(NULL)
, m_bFillPolarErro(false)
, m_iCurDljlType(-1)
, m_iColorIndexCur(256)
, m_strCurNameIntoXhl(_T(""))
, m_iCurJob(0)
, m_i4Or2Line(0)
, m_iDsNumXhj(0)
, m_iQkNum(0)
, m_iDcDsNum(0)
, m_dRowHeightToXhl(10)
, m_dHeightOfDistText(2.2)
, m_dHeightOfDistText_DT(3)
, m_dMaxLenPmt(2000)
{	
	m_AdoDb.Open(g_strAdoCon) ;
	m_RecordSet.SetConnection(&m_AdoDb) ;
    num=3;
	
	CBlkUtility::QueryValueReg(_T("ZnOption"), _T("TwoOrFourLine"), m_i4Or2Line) ;
	CBlkUtility::QueryValueReg(_T("ZnOption"), _T("XhjDsNum"), m_iDsNumXhj) ;
	CBlkUtility::QueryValueReg(_T("ZnOption"), _T("DcQkNum"), m_iQkNum) ;
	CBlkUtility::QueryValueReg(_T("ZnOption"), _T("DcDsNum"), m_iDcDsNum) ;

// 	DWORD iJgNum = 1, iXgNum = 0 ;
// 	CBlkUtility::QueryValueReg(_T("ZnOption"), _T("JGNUM"), iJgNum) ;
// 	CBlkUtility::QueryValueReg(_T("ZnOption"), _T("XGNUM"), iXgNum) ;
// 	m_iJgNum = iJgNum ;
// 	m_iXgNum = iXgNum ;
}

CZnSxt::~CZnSxt(void)
{
	m_RecordSet.Close() ;
	m_AdoDb.Close() ;
}

int CZnSxt::Test(void)
{
	_ApplicationPtr pExcel = NULL ;
	WorkbooksPtr pWorkBooks = NULL ;
	_WorkbookPtr pWorkBook = NULL ;
	SheetsPtr pWorksheets = NULL ; 
	RangePtr pRange = NULL ;
	_WorksheetPtr pSheet = NULL ;

	try
	{
		if (bFirst)
		{
			::AfxOleInit() ;
			bFirst = FALSE ;
		}
		HRESULT hr = pExcel.CreateInstance ( _T("Excel.Application") ) ;
		if(FAILED(hr))
		{
			AfxMessageBox( _T("初始化Excel失败,可能是没有安装Excel") ) ;
			//return ;
		}
		//使excel程序显示可见
		//pExcel->PutVisible(0,VARIANT_TRUE) ;
		//得到所有的工作簿
		pWorkBooks = pExcel->GetWorkbooks() ;
		//添加一个新的工作簿，返回结果为刚添加的工作簿的指针
		pWorkBook = pWorkBooks->Add() ;

		VARIANT vt_index ;
		vt_index.vt = VT_I2 ;
		vt_index.iVal = 1 ;		

		//得到当前工作簿的所有的sheet
		pWorksheets = pWorkBook->GetSheets() ;
		//定位于第一个sheet
		pSheet = pWorksheets->GetItem(vt_index) ;

		CADORecordset cSet(&m_AdoDb) ;

		CString strSql ;
		strSql.Format(_T("select top 35 * from define_dev_use_cablecore order by id")) ;
		if (cSet.Open(strSql))
		{
			int iRow = 0 ;
			while(!cSet.IsEOF())
			{
				CString strCellName, strCellContent ;
				long iData = 0 ;
				CString strData ;
				iRow++ ;
				for (int iCol=0; iCol<12; iCol++)
				{
					strCellName.Format(_T("%c%d"), _T('A')+iCol, iRow) ;
					iData = 0 ;
					strData = _T("") ;
					if (iCol>1&&iCol<7)
					{
						cSet.GetFieldValue(iCol, strData) ;
						strCellContent = strData ;
					}
					else
					{
						cSet.GetFieldValue(iCol, iData) ;
						strCellContent.Format(_T("%d"), iData) ;
					}
					pRange = NULL ;				
					pRange = pSheet->GetRange((_variant_t)strCellName, vtMissing) ;
					pRange->FormulaR1C1 = (_variant_t) strCellContent ;
				}


				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}

		//保存excel文件
		VARIANT varOptional ;
		VariantInit(&varOptional);
		varOptional.vt		= VT_ERROR;
		varOptional.scode	= (long)DISP_E_PARAMNOTFOUND;		

		CString strSaveFileName  = _T("D:\\1.xls") ;
		pWorkBook->SaveAs( (_variant_t) strSaveFileName, COleVariant(varOptional), COleVariant(varOptional), 
			COleVariant(varOptional), COleVariant(varOptional), COleVariant(varOptional), xlExclusive, 
			COleVariant(varOptional), COleVariant(varOptional), COleVariant(varOptional), COleVariant(varOptional)) ;
		//////////////////////////////////////////////////////////////////////////
		pWorkBook->Close( ) ;
		pWorkBook = NULL ;
		pExcel->Quit() ;
		pExcel = NULL ;
		//end double for loop
		//////////////////////////////////////////////////////////////////////////
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);  
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		pExcel->Quit() ;
		pExcel = NULL ;		
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!"));		
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		pExcel->Quit() ;
		pExcel = NULL ;		
	}
	return 0;

}

//查询和pEntSrc相交的多段线，若是定位相交的线，则返回多段线的段数（base 0）,若是反位相交的，返回多段线的顶点序号（base 0）
//iMode:默认-1表示反位相交情况，iMode=100，表示信号机绝缘节相交情况，iIndexOfVertex需要返回相交的Vertex序号（base 0）;其他表示定位相交，iIndexOfVertex需要返回相交的段数（base 0）
int CZnSxt::GetIntersectPLine(AcDbEntity *pEntSrc, UINT &nHandleIntersectEnt, UINT &nIndexOfVertex, AcGePoint3d &pt_3d_intersect, int &iDwIntersectMoveToVertex, int iMode)
{
	int iRet = 0 ;

	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			//只查询相交的多段线
			if (!pEnt->isEqualTo(pEntSrc)&&pEnt->isKindOf(AcDbPolyline::desc()))
			{
				long nHandle = m_mysys.GetHandle(pEnt) ;
// 				if (nHandle==289)
// 				{
// 					int iiii = 0 ;
// 				}
				AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;
				AcGePoint3dArray arrayPt3d ;
				if(Acad::eOk==pEntSrc->intersectWith(pEnt, AcDb::kOnBothOperands, arrayPt3d) )
				{
					int iPtNum = arrayPt3d.length() ;
					//正常情况应该只有一个交点
					if (iPtNum==1)
					{
						nHandleIntersectEnt = m_mysys.GetHandle(pEnt) ;
						pt_3d_intersect = arrayPt3d.at(0) ;
						iRet++ ;

						int iPtOnPolyRet = m_mysys.IsPointOnPolyLine(pPolyLine, pt_3d_intersect, nIndexOfVertex) ;
						if (iMode==0) //定位
						{	
							//确定绘制双线图的三线交点（其实是两线交点，定位那根线是折点分成的2段）
							//判断定位那个交点离定位线折点有没有小于等于2的，若有就将三线交点设在折点，否则就是定位交点pt_3d_intersectDW
							AcGePoint3d pt_3d_vertex1(0, 0, 0), pt_3d_vertex2(0, 0, 0) ;
							pPolyLine->getPointAt(nIndexOfVertex, pt_3d_vertex1) ;
							pPolyLine->getPointAt(nIndexOfVertex+1, pt_3d_vertex2) ;
							if (pt_3d_intersect.distanceTo(pt_3d_vertex1)<=2.3)
							{
								pt_3d_intersect = pt_3d_vertex1 ;
								iDwIntersectMoveToVertex = nIndexOfVertex ;
							}
							else if (pt_3d_intersect.distanceTo(pt_3d_vertex2)<=2.3)
							{
								pt_3d_intersect = pt_3d_vertex2 ;
								iDwIntersectMoveToVertex = nIndexOfVertex+1 ;
							}
							//20140430-1627,here
							//交点不在折点则需要给该多段线增加一个折点（交点位置）
// 							else 
// 							{
// 								AcGePoint2d pt_2d_intersect(pt_3d_intersect.x, pt_3d_intersect.y) ;
// 								pPolyLine->upgradeOpen() ;
// 								pPolyLine->addVertexAt(nIndexOfVertex+1, pt_2d_intersect) ;
// 								pPolyLine->downgradeOpen() ;
// 							}

							//acutPrintf(_T("\n定位iIndexOfSeg: %d"), nIndexOfVertex) ;				
						}
						else if (iMode==-1)//反位
						{
							AcGePoint3d pt_3d_vertex1(0, 0, 0), pt_3d_vertex2(0, 0, 0) ;
							pPolyLine->getPointAt(nIndexOfVertex, pt_3d_vertex1) ;
							pPolyLine->getPointAt(nIndexOfVertex+1, pt_3d_vertex2) ;
							if (pt_3d_intersect.distanceTo(pt_3d_vertex1)>pt_3d_intersect.distanceTo(pt_3d_vertex2))
							{
								nIndexOfVertex = nIndexOfVertex+1 ;
							}
							//acutPrintf(_T("\n反位iIndexOfvertex: %d"), nIndexOfVertex) ;		
						}
						else if (iMode==100)//信号机、绝缘节
						{
						}

						CString strPt ;
						strPt.Format(_T("%d"), iPtNum) ;
						for (int iPtIndex=0; iPtIndex<iPtNum; iPtIndex++)
						{
							strPt.AppendFormat(_T("(%.3f-%.3f)"), arrayPt3d.at(iPtIndex).x, arrayPt3d.at(iPtIndex).y) ;
						}
						//acutPrintf(_T("\n一个交点:%d, 交点：%s"), nHandleIntersectEnt, strPt) ;
					}
					else if(iPtNum>1)
					{
						CString strPt ;
						strPt.Format(_T("%d"), iPtNum) ;
						for (int iPtIndex=0; iPtIndex<iPtNum; iPtIndex++)
						{
							strPt.AppendFormat(_T("(%.3f-%.3f)"), arrayPt3d.at(iPtIndex).x, arrayPt3d.at(iPtIndex).y) ;
						}
						//acutPrintf(_T("\n不止一个交点:%d, 交点：%s"), nHandleIntersectEnt, strPt) ;
					}
				}
			}

			pEnt->close() ;
		}		
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return iRet ;
}

//查询和pEntSrc(信号机或绝缘节)相交的多段线，返回值：1,1个交点在顶点,顶点所在线在当前信号机或者绝缘节的左侧；5,1个交点在顶点,顶点所在线在当前信号机或者绝缘节的右侧
int CZnSxt::GetIntersectPLine(AcDbEntity *pEntSrc, CLongArray &nArrayHandleIntersect, CLongArray &nArrayIndexOfVertex, AcGePoint3dArray &pt3dArrayIntersect)
{
	int iRet = 0 ;

	int iPtOnPLinePre = -1 ; //记录上一次交点在多段线上的情况：1000，在多段线非顶点位置，0~1000，在多段线顶点位置。若上次为1000，第二次为任何大于-1的值都是有问题的；若上次为0~1000，则第二次必须也为0~1000才行

	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	int iIndexEnt = 0 ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			//只查询相交的多段线
			if (!pEnt->isEqualTo(pEntSrc)&&pEnt->isKindOf(AcDbPolyline::desc()))
			{
				AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;
				AcDb::Visibility bIsVisible  = pPolyLine->visibility() ;
				double dLenOfPline = m_mysys.GetLineLen(pPolyLine) ;
				if (bIsVisible==AcDb::kInvisible||m_mysys.IsOnOffLayer(pEnt)||dLenOfPline<1)
				{
					pEnt->close() ;
					continue;
				}
				iIndexEnt++ ;

				AcGePoint3dArray arrayPt3d ;
				Acad::ErrorStatus es = pEntSrc->intersectWith(pEnt, AcDb::kOnBothOperands, arrayPt3d);
				int iPtNum = arrayPt3d.length() ;

				if(es==Acad::eOk && iPtNum>0)
				{
					UINT nIndexOfVertex = 0 ;
					UINT nHandleIntersectEnt = 0 ;
					nHandleIntersectEnt = m_mysys.GetHandle(pEnt) ;
					AcGePoint3d pt_3d_intersect(0,0,0) ;
					pt_3d_intersect = arrayPt3d.at(0) ;

					//正常情况应该只有一个交点
					if (iPtNum==1)
					{
						int iPtOnPLine = m_mysys.IsPointOnPolyLine(pPolyLine, pt_3d_intersect, nIndexOfVertex) ;
						int iNumOfVertex = pPolyLine->numVerts() ;
						if (iPtOnPLinePre>-1&&iPtOnPLinePre<1000) //前一个交点是顶点
						{
							if (iPtOnPLine>-1&&iPtOnPLine<1000)//当前交点也是顶点
							{
								nArrayHandleIntersect.Add(nHandleIntersectEnt) ;
								nArrayIndexOfVertex.Add(iPtOnPLine) ;
								pt3dArrayIntersect.append(pt_3d_intersect) ;
								if (iPtOnPLine==0)
								{
									iRet =5*10 + iRet ; //顶点所在线在当前信号机或者绝缘节的右侧
								}
								else if (iPtOnPLine==iNumOfVertex-1)
								{
									iRet = 1*10 +iRet ; //顶点所在线在当前信号机或者绝缘节的左侧
								}
								else
								{
									iRet = 0 ; //erro
								}
							}
							else
							{
								acutPrintf(_T("\n前交点是顶点，当前交点不是。交点为（%.3f, %.3f）,handle为%d，第%d段"), pt_3d_intersect.x, pt_3d_intersect.y, nHandleIntersectEnt, nIndexOfVertex) ;
								iRet = 2*10 +iRet;
							}
						}
						else if (iPtOnPLinePre==1000)//前一个交点不是顶点
						{
							acutPrintf(_T("\n前交点不是顶点，现在有出现一个交线，请检查图面。交点为（%.3f, %.3f）,handle为%d，第%d段"), pt_3d_intersect.x, pt_3d_intersect.y, nHandleIntersectEnt, nIndexOfVertex) ;
							iRet = 0 ;
						}
						else if (iPtOnPLinePre==-1)
						{
							nArrayHandleIntersect.Add(nHandleIntersectEnt) ;
							if (iPtOnPLine>-1&&iPtOnPLine<1000)//当前交点是顶点
							{
								nArrayIndexOfVertex.Add(iPtOnPLine) ;
								if (iPtOnPLine==0)
								{
									iRet = 5 ; //顶点所在线在当前信号机或者绝缘节的右侧
								}
								else if (iPtOnPLine==iNumOfVertex-1)
								{
									iRet = 1 ; //顶点所在线在当前信号机或者绝缘节的左侧
								}
								else
								{
									iRet = 0 ; //错误
								}
							}
							else //有交点，但交点不在顶点，那肯定在直线上了（即信号机/绝缘节位于直线上online）
							{
								nArrayIndexOfVertex.Add(nIndexOfVertex) ;
								iRet = 2 ;
							}							
							pt3dArrayIntersect.append(pt_3d_intersect) ;							
						}
						iPtOnPLinePre = iPtOnPLine ;	
						//acutPrintf(_T("\n%d:cur pline handle:%d, iRet:%d"), iIndexEnt, m_mysys.GetHandle(pEnt), iRet) ;

					}
					else if(iPtNum>1)
					{
						CString strPt ;
						strPt.Format(_T("%d"), iPtNum) ;
						for (int iPtIndex=0; iPtIndex<iPtNum; iPtIndex++)
						{
							strPt.AppendFormat(_T("(%.3f-%.3f)"), arrayPt3d.at(iPtIndex).x, arrayPt3d.at(iPtIndex).y) ;
						}
						acutPrintf(_T("\n不止一个交点:%d, 交点：%s"), nHandleIntersectEnt, strPt) ;
					}
				}
			}

			pEnt->close() ;
		}		
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return iRet ;
}

// 前期工作：确定道岔中心点，可能需要移动岔后连线（连在DC块屁股上的线）的及其上的实体（循环过程）
//DC定位直线的，中心点在插入点，反位的在多段线折点（顶点vertex）
int CZnSxt::PreDoGetDcCenter()
{
	AcDbDatabase *pDbCur = acdbHostApplicationServices()->workingDatabase() ;	
	m_pDb = pDbCur ;
	m_mysys.m_pDb = pDbCur ;

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;

		//遍历出所有DC_00块
		CArray<long, long> nArrayHandleDC ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type=0")) ;		
		int nNumDc = m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDC) ;
		for (int i=0; i<nArrayHandleDC.GetCount(); i++)
		{
			long nHandleDC  = nArrayHandleDC.GetAt(i), nHandleDW  = 0, nHandleFW  = 0;

			strSql.Format(_T("select * from sxt_ent where sxt_ent_type=0 and sxt_ent_handle=%d"), nHandleDC) ;
			AcGePoint2d pt_2d_dwcon(0,0) ; //DW连接点
			//m_RecordSet.GetRecordValue(strSql,_T("sxt_ent_handle"), nHandleDC) ;
			m_RecordSet.GetRecordValue(strSql,_T("sxt_ent_online_handle"), nHandleDW) ;
			m_RecordSet.GetRecordValue(strSql,_T("sxt_ent_online_intersectx1"), pt_2d_dwcon.x) ;
			m_RecordSet.GetRecordValue(strSql,_T("sxt_ent_online_intersecty1"), pt_2d_dwcon.y) ;
			m_RecordSet.GetRecordValue(strSql,_T("sxt_ent_fwline_handle"), nHandleFW) ;
			long iFwVertex = 0 ; //道岔块反位连线的vertex base 0（不是终点就是起点）
			m_RecordSet.GetRecordValue(strSql,_T("sxt_ent_fwline_vertex"), iFwVertex) ;
			AcGePoint2d pt_2d_fwcon(0,0) ; //FW连接点
			strSql.Format(_T("select * from sxt_line where  sxt_line_handle=%d and sxt_line_vertex=%d"), nHandleFW, iFwVertex) ;				
			m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x1"), pt_2d_fwcon.x	) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y1"), pt_2d_fwcon.y	) ;
			AcGePoint2d pt_2d_rotate(0,0) ; //旋转基点，即FW连接点所在段的另一点
			strSql.Format(_T("select * from sxt_line where  sxt_line_handle=%d and sxt_line_vertex=%d"), nHandleFW, iFwVertex==0?(iFwVertex+1):(iFwVertex-1)) ;				
			m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x1"), pt_2d_rotate.x) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y1"), pt_2d_rotate.y) ;

			double dAngleToMove = 0.000 ;
			AcGeVector2d vecOld, vecNew ;
			vecOld = pt_2d_rotate-pt_2d_fwcon ;
			vecNew = pt_2d_rotate-pt_2d_dwcon ;
			dAngleToMove = vecNew.angle()-vecOld.angle() ;

			//先将当前fw线的连接点移动到dwcon点,仅更新数据库值				
			strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex=%d"),  nHandleFW, iFwVertex) ;
			m_RecordSet.SetRecordValue(strSql, _T("sxt_line_vertex_x1"), pt_2d_dwcon.x) ;
			m_RecordSet.SetRecordValue(strSql, _T("sxt_line_vertex_y1"), pt_2d_dwcon.y) ;

			this->SearchToMoveEnt(nHandleFW, iFwVertex, pt_2d_rotate, dAngleToMove) ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in PreDoGetDcCenter"));
	}

	return 0;
}

// 取得和DC块定/反位方向连接的线
BOOL CZnSxt::GetDcConLineDFW(const AcDbBlockReference *pRef, CLongArray &nArrayHandleIntersectLine, CLongArray &nArrayIndexOfVertex, AcGePoint3dArray &pt3dArrayIntersect, int &iDwIntersectMoveToVertex)
{
	BOOL bRet = FALSE ;

	AcGePoint3d pt_3d_ref = pRef->position() ;
	AcGeScale3d scale_3d = pRef->scaleFactors()  ;
	if (pRef->normal().z<0)
	{
		scale_3d.sx = -scale_3d.sx	;
	}
	double dAngle = pRef->rotation() ;

	//以DC块基点为源，确定8个点，起点为黑疙瘩反位点，第7点为黑疙瘩中心,第8点为基点下移一点和3、4点同一线上的点
	//先算其无旋转时的值，再旋转dAangle度
	double dPlus = 0.05 ; //计算点时，适当外扩一点，防止没开捕捉绘制的图
	AcGePoint2dArray pt2dArrayDC ;
	for (int i=0; i<8; i++)
	{
		AcGePoint2d pt_2d_tmp(0,0) ;
		pt2dArrayDC.append(pt_2d_tmp) ;
	}
	pt2dArrayDC[0].x = pt2dArrayDC[3].x = pt_3d_ref.x-(1+dPlus)*(scale_3d.sx<0?-1:1) ;
	pt2dArrayDC[0].y = pt2dArrayDC[1].y = pt2dArrayDC[4].y = pt_3d_ref.y+(1+dPlus) ;
	pt2dArrayDC[1].x = pt2dArrayDC[2].x = pt_3d_ref.x+1*(scale_3d.sx<0?-1:1) ;
	pt2dArrayDC[2].y = pt2dArrayDC[3].y = pt2dArrayDC[5].y = pt_3d_ref.y-dPlus ;
	pt2dArrayDC[4].x = pt2dArrayDC[5].x = pt_3d_ref.x+(2+dPlus)*(scale_3d.sx<0?-1:1) ;
	pt2dArrayDC[6].x = pt_3d_ref.x ;
	pt2dArrayDC[6].y = ((pt_3d_ref.y+(1+dPlus)) +(pt_3d_ref.y-dPlus))/2 ;
	pt2dArrayDC[7].x = pt_3d_ref.x ;
	pt2dArrayDC[7].y = pt_3d_ref.y-dPlus ;
	for(int i=0; i<8; i++)
	{
		AcGeMatrix2d matrix; 
		matrix.setToRotation(dAngle, pt_3d_ref.convert2d(AcGePlane::kXYPlane)); 
		pt2dArrayDC[i].transformBy(matrix) ; 				
	}

	//acutPrintf(_T("\n%d\n%s号道岔:position(%.3f,%.3f)"), iDcIndex, strDcName, pt_3d_ref.x, pt_3d_ref.y) ; 

	//定位方向的线
	AcGePoint2dArray pt2dArrayLine ; //测试用，绘制辅助线
	AcGePoint2d pt_2d_start(0, 0), pt_2d_end(0,0) ;	
	AcDbPolyline *polyLineTmp1 = new AcDbPolyline(2) ;
	AcGeVector2d vec1 = pt2dArrayDC[6]-pt2dArrayDC[7] ;
	vec1/=2 ; //vec1长度为0.5，需要减半
	pt_2d_start.x =pt2dArrayDC[7].x ;
	pt_2d_start.y =pt2dArrayDC[7].y ;
	pt_2d_start-=vec1 ;
	pt2dArrayLine.append(pt_2d_start) ;
	polyLineTmp1->addVertexAt(0, pt_2d_start) ;
	pt_2d_end.x =(pt2dArrayDC[6].x+pt2dArrayDC[7].x)/2;
	pt_2d_end.y =(pt2dArrayDC[6].y+pt2dArrayDC[7].y)/2 ;	
	pt2dArrayLine.append(pt_2d_end) ;
	polyLineTmp1->addVertexAt(1, pt_2d_end) ;
	UINT nHandleIntersectDW ;
	AcGePoint3d pt_3d_intersectDW(0,0,0) ;
	UINT nIndexOfVertexDW = 0 ;
	int iNumConLineDW = GetIntersectPLine(polyLineTmp1, nHandleIntersectDW, nIndexOfVertexDW, pt_3d_intersectDW, iDwIntersectMoveToVertex,0) ;
	nArrayHandleIntersectLine.Add(nHandleIntersectDW) ;
	nArrayIndexOfVertex.Add(nIndexOfVertexDW) ;
	pt3dArrayIntersect.append(pt_3d_intersectDW) ;
	delete polyLineTmp1 ;
	polyLineTmp1 = NULL ;
	//m_mysys.AddAcDbPolyLine(pt2dArrayLine, 0, 3) ;

	//反位方向的线
	pt2dArrayLine.removeSubArray(0, pt2dArrayLine.length()-1) ;
	AcGePoint2d pt_2d_tmp(0,0) ;
	AcDbPolyline *polyLineTmp2 = new AcDbPolyline(3) ;
	pt_2d_tmp.x = (pt2dArrayDC[0].x+pt2dArrayDC[1].x)/2 ;
	pt_2d_tmp.y = (pt2dArrayDC[0].y+pt2dArrayDC[1].y)/2 ;	
	pt2dArrayLine.append(pt_2d_tmp) ;
	polyLineTmp2->addVertexAt(0, pt_2d_tmp) ;
	pt_2d_tmp.x =pt2dArrayDC[0].x ;
	pt_2d_tmp.y =pt2dArrayDC[0].y ;
	pt2dArrayLine.append(pt_2d_tmp) ;
	polyLineTmp2->addVertexAt(1, pt_2d_tmp) ;
	pt_2d_tmp.x = (pt2dArrayDC[0].x+pt2dArrayDC[3].x)/2 ;
	pt_2d_tmp.y = (pt2dArrayDC[0].y+pt2dArrayDC[3].y)/2 ;
	pt2dArrayLine.append(pt_2d_tmp) ;
	polyLineTmp2->addVertexAt(2, pt_2d_tmp) ;
	UINT nHandleIntersectFW ;
	AcGePoint3d pt_3d_intersectFW(0,0,0) ;
	UINT nIndexOfVertexFW = 0 ;
// 	CString strMsg ;
// 	for (int iii = 0; iii<polyLineTmp2->numVerts(); iii++)
// 	{
// 		AcGePoint2d pt_2d_iii(0,0) ;
// 		polyLineTmp2->getPointAt(iii, pt_2d_iii) ;
// 		strMsg.AppendFormat(_T("%.3f-%.3f,"), pt_2d_iii.x, pt_2d_iii.y ) ;
// 	}
// 	acutPrintf(_T("\n%s"), strMsg) ;
	int iNumConLineFW = GetIntersectPLine(polyLineTmp2, nHandleIntersectFW, nIndexOfVertexFW,  pt_3d_intersectFW, iDwIntersectMoveToVertex,-1) ;
	nArrayHandleIntersectLine.Add(nHandleIntersectFW) ;
	nArrayIndexOfVertex.Add(nIndexOfVertexFW) ;
	pt3dArrayIntersect.append(pt_3d_intersectFW) ;
	delete polyLineTmp2 ;
	polyLineTmp2 = NULL ;
	//mysys.AddAcDbPolyLine(pt2dArrayLine, 0, 3) ;

	if (iNumConLineFW==1&&iNumConLineDW==1)
	{
		bRet = TRUE ;
	}
	else
	{
		acutPrintf(_T("\n查找定反位线时不都为1，%.3f %.3f"), pt_3d_ref.x, pt_3d_ref.y) ;
	}

	return bRet ;
}

// 查找一条FW连线移动引起的所有移动，对于反位顶点nIndexOfVertex，若为起点，对应的该线段数就是第0段，若大于0，则对应段数为nIndexOfVertex-1
void CZnSxt::SearchToMoveEnt( UINT nHandleLineFW,  UINT nIndexOfVertex,  const AcGePoint2d &pt_2d_rotate, const double dRotateAngle)
{
	//查询在nHandleLineFW的第nIndexOfVertex段线上的实体
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_online_vertex=%d"), nHandleLineFW, nIndexOfVertex==0?0:nIndexOfVertex-1) ;
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long iEntType = 0 ;
				long iHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_type"), iEntType) ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), iHandle) ;
				AcGePoint2d pt_2d_ent(0,0), pt_2d_intersect(0,0) ;
				cSet.GetFieldValue(_T("sxt_ent_x1"), pt_2d_ent.x) ;
				cSet.GetFieldValue(_T("sxt_ent_y1"), pt_2d_ent.y) ;
				cSet.GetFieldValue(_T("sxt_ent_online_intersectx1"), pt_2d_intersect.x) ;
				cSet.GetFieldValue(_T("sxt_ent_online_intersecty1"), pt_2d_intersect.y) ;

				AcGeMatrix2d matrix; 
				matrix.setToRotation(dRotateAngle, pt_2d_rotate); 
				pt_2d_ent.transformBy(matrix) ; 	
				pt_2d_intersect.transformBy(matrix) ; 	

				cSet.Edit() ;
				cSet.SetFieldValue(_T("sxt_ent_x1"), pt_2d_ent.x) ;
				cSet.SetFieldValue(_T("sxt_ent_y1"), pt_2d_ent.y) ;
				cSet.SetFieldValue(_T("sxt_ent_online_intersectx1"), pt_2d_intersect.x) ;
				cSet.SetFieldValue(_T("sxt_ent_online_intersecty1"), pt_2d_intersect.y) ;
				cSet.Update() ;

				if (iEntType==0) //道岔
				{
					long iHandleLineFWTmp = 0 ;
					long iIndexOfVertexTmp = 0 ;
					cSet.GetFieldValue(_T("sxt_ent_fwline_handle"), iHandleLineFWTmp) ;
					cSet.GetFieldValue(_T("sxt_ent_fwline_vertex"), iIndexOfVertexTmp) ;

					//fw连接线
					strSql.Format(_T("select * from sxt_line where  sxt_line_handle=%d and sxt_line_vertex=%d"), iHandleLineFWTmp, iIndexOfVertexTmp) ;				
					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x1"), pt_2d_ent.x	) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y1"), pt_2d_ent.y	) ;
					pt_2d_ent.transformBy(matrix) ; 	
					
					m_RecordSet.SetRecordValue(strSql, _T("sxt_line_vertex_x1"), pt_2d_ent.x) ;
					m_RecordSet.SetRecordValue(strSql, _T("sxt_line_vertex_y1"), pt_2d_ent.y) ;

					this->SearchToMoveEnt(iHandleLineFWTmp, iIndexOfVertexTmp, pt_2d_rotate, dRotateAngle) ;
				}

				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in SearchToMoveEnt"));
	}
}

// 读入所有实体到数据库
int CZnSxt::ReadAllEntToDB()
{
	int iRet = 0 ;
	m_AdoDb.ClearTable(_T("sxt_ent")) ;
	m_AdoDb.ClearTable(_T("sxt_line")) ;

	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbObjectIdArray objArray ;
	AcDbEntity * pEnt = NULL ;
	CString strSql ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			UINT nHandle = m_mysys.GetHandle(pEnt) ;

			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;
				AcGePoint3d pt_3d_position = pRef->position() ;
				//将块统一为X比例和旋转角变化（X、Y都置-1，等同于旋转180度，X置-1并且旋转180度等同于Y置-1，Y置-1并且旋转180度等同于X置-1）
				AcGeScale3d scale_3d = pRef->scaleFactors()  ;		
				if (scale_3d.sy<0)
				{
					pRef->upgradeOpen() ;
					scale_3d.set(-scale_3d.sx, -scale_3d.sy, scale_3d.sz) ;
					pRef->setScaleFactors(scale_3d) ;
					pRef->setRotation(pRef->rotation()-PI) ;
					pRef->downgradeOpen() ;
				}	

				CString strName ;
				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;
				CStringArray strArrayBlkName ;
				CBlkUtility::DivideString(strBlkName, _T("_"), strArrayBlkName) ;
				CString strBlkType = _T("") ;
				if (strArrayBlkName.GetCount()>0)
				{
					strBlkType = strArrayBlkName.GetAt(0) ;
				}

				if (strBlkType==_T("DC"))
				{
					m_mysys.GetAttValue(pRef, _T("BIANHAO"), strName) ;
					//acutPrintf(_T("\n道岔编号%s"), strName) ;
					//和DC块定/反位连接的线信息
					CLongArray nArrayHandleIntersectLine, nArrayIndexOfVertex ;
					int iDwIntersectMoveToVertex = -1 ;
					AcGePoint3dArray pt3dArrayIntersect ;
					if(this->GetDcConLineDFW(pRef, nArrayHandleIntersectLine, nArrayIndexOfVertex, pt3dArrayIntersect, iDwIntersectMoveToVertex) )
					{
						strSql.Format(_T("insert into sxt_ent(sxt_ent_handle,  sxt_ent_block, sxt_ent_x, sxt_ent_y, sxt_ent_movetovertex, sxt_ent_name, sxt_ent_type,  sxt_ent_online_handle,  sxt_ent_online_vertex,  sxt_ent_online_intersectx,  sxt_ent_online_intersecty,  sxt_ent_fwline_handle,  sxt_ent_fwline_vertex,  sxt_ent_x1, sxt_ent_y1, sxt_ent_online_intersectx1,  sxt_ent_online_intersecty1)  \
							values(%d, '%s', %.10f, %.10f, %d, '%s', %d, %d, %d, %.10f, %.10f, %d, %d, %.10f, %.10f, %.10f, %.10f) "), nHandle, strBlkName,pt_3d_position.x, pt_3d_position.y, iDwIntersectMoveToVertex, strName, 0, nArrayHandleIntersectLine.GetAt(0), nArrayIndexOfVertex.GetAt(0), pt3dArrayIntersect.at(0).x, pt3dArrayIntersect.at(0).y, nArrayHandleIntersectLine.GetAt(1), nArrayIndexOfVertex.GetAt(1), pt_3d_position.x, pt_3d_position.y, pt3dArrayIntersect.at(0).x, pt3dArrayIntersect.at(0).y) ;
						m_AdoDb.Execute(strSql) ;
					}					
				}
				else if (strBlkType==_T("XHJ")||strBlkType==_T("JYJ"))
				{
					int iEntType = 100 ; //xhj
					if (strBlkType==_T("JYJ"))
					{
						iEntType = 200 ;
						if (strBlkName.Left(6)==_T("JYJ_JX"))
						{
							iEntType=250 ; //为实现极性切割增加的绝缘节
						}
					}

					m_mysys.GetAttValue(pRef, _T("XHJNAME"), strName) ;
					UINT nHandleIntersectLine, nIndexOfVertex ;
					AcGePoint3d pt_3d_intersect ;
					if(this->GetXhjJyjConLine(pRef, nHandleIntersectLine, nIndexOfVertex, pt_3d_intersect) )
					{
						strSql.Format(_T("insert into sxt_ent(sxt_ent_handle,  sxt_ent_block, sxt_ent_x, sxt_ent_y, sxt_ent_name, sxt_ent_type,  sxt_ent_online_handle,  sxt_ent_online_vertex,  sxt_ent_online_intersectx,  sxt_ent_online_intersecty,  sxt_ent_fwline_handle,  sxt_ent_fwline_vertex,  sxt_ent_x1, sxt_ent_y1, sxt_ent_online_intersectx1,  sxt_ent_online_intersecty1)  \
										 values(%d, '%s', %.10f, %.10f, '%s', %d, %d, %d, %.10f, %.10f, %d, %d, %.10f, %.10f, %.10f, %.10f) "), nHandle, strBlkName, pt_3d_position.x, pt_3d_position.y,strName, iEntType, nHandleIntersectLine, nIndexOfVertex, pt_3d_intersect.x, pt_3d_intersect.y, 0, 0, pt_3d_position.x, pt_3d_position.y, pt_3d_intersect.x, pt_3d_intersect.y) ;
						m_AdoDb.Execute(strSql) ;
					}	
				}
			}

			pEnt->close() ;
		}	
	}
	//再遍历一遍，将轨道线读入
	for (pBlkTblRecIter->start(); !pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				long nHandleLine = m_mysys.GetHandle(pEnt) ;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d or sxt_ent_fwline_handle=%d or sxt_ent_conline_left=%d or sxt_ent_conline_right=%d"), nHandleLine, nHandleLine, nHandleLine, nHandleLine ) ;
				int iRetSum = m_RecordSet.GetRecordCount(strSql) ;
				if (iRetSum>0)
				{
					AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;	
					int iNumVert = pPolyLine->numVerts() ;
					for (int i=0; i<iNumVert; i++)
					{
						AcGePoint3d pt_3d_vertex(0,0,0) ;
						pPolyLine->getPointAt(i, pt_3d_vertex) ;
						strSql.Format(_T("insert into sxt_line(sxt_line_handle, sxt_line_vertex,  sxt_line_vertex_x, sxt_line_vertex_y, sxt_line_vertex1,  sxt_line_vertex_x1, sxt_line_vertex_y1 )  \
										 values(%d, %d, %.10f, %.10f, %d, %.10f, %.10f) "), nHandleLine, i,  pt_3d_vertex.x, pt_3d_vertex.y, i,  pt_3d_vertex.x, pt_3d_vertex.y) ;
						m_AdoDb.Execute(strSql) ;
					}
				}
			}
			pEnt->close() ;
		}
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return iRet ;
}

// 取得信号机、绝缘节所在的线的信息
BOOL CZnSxt::GetXhjJyjConLine(const AcDbBlockReference *pRef, UINT &nHandleIntersectLine, UINT &nIndexOfVertex, AcGePoint3d &pt_3d_intersect)
{
	BOOL bRet = FALSE ;

	AcGePoint3d pt_3d_ref = pRef->position() ;
	AcGeScale3d scale_3d = pRef->scaleFactors()  ;
	double dAngle = pRef->rotation() ;

	//以块基点为源，确定2个点
	//先算其无旋转时的值，再旋转dAangle度
	double dPlus = 0.05 ; //计算点时，适当外扩一点，防止没开捕捉绘制的图
	AcGePoint2dArray pt2dArray ;
	for (int i=0; i<2; i++)
	{
		AcGePoint2d pt_2d_tmp(0,0) ;
		pt2dArray.append(pt_2d_tmp) ;
	}
	pt2dArray[0].x = pt2dArray[1].x = pt_3d_ref.x ;
	pt2dArray[0].y = pt_3d_ref.y+(1+dPlus) ;
	pt2dArray[1].y = pt_3d_ref.y-(1+dPlus) ;

	for(int i=0; i<2; i++)
	{
		AcGeMatrix2d matrix; 
		matrix.setToRotation(dAngle, pt_3d_ref.convert2d(AcGePlane::kXYPlane)); 
		pt2dArray[i].transformBy(matrix) ; 				
	}

	AcDbPolyline *polyLineTmp = new AcDbPolyline(2) ;
	polyLineTmp->addVertexAt(0, pt2dArray[0]) ;
	polyLineTmp->addVertexAt(1, pt2dArray[1]) ;
	int iDwIntersectMoveToVertex = -1 ;
	int iNumConLine = GetIntersectPLine(polyLineTmp, nHandleIntersectLine, nIndexOfVertex, pt_3d_intersect, iDwIntersectMoveToVertex, 100) ;
	delete polyLineTmp ;
	polyLineTmp = NULL ;

	if (iNumConLine==1)
	{
		bRet = TRUE ;
	}

	return bRet ;
}

// 取得信号机所在的线的信息(可能为两段)
int CZnSxt::GetXhjJyjConLine(const AcDbBlockReference *pRef, CLongArray &nArrayHandleIntersect, CLongArray &nArrayIndexOfVertex, AcGePoint3dArray &pt3dArrayIntersect)
{
	int iRet = -1 ;

	AcGeTol tol ;
	tol.setEqualPoint(0.05) ;

	AcGePoint3d pt_3d_ref = pRef->position() ;

	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		BOOL bValidData = FALSE ; //本次数据是否有效

		if (iRet==0)
		{
			break;
		}
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;
			
				//只查询显示的多段线
				AcDb::Visibility bIsVisible  = pPolyLine->visibility() ;
				double dLenOfPline = m_mysys.GetLineLen(pPolyLine) ;
				if (bIsVisible==AcDb::kInvisible||m_mysys.IsOnOffLayer(pEnt)||dLenOfPline<1)
				{
					pEnt->close() ;
					continue;
				}
				long nHandleCur = m_mysys.GetHandle(pEnt) ;
				AcGePoint3d pt_3d_intersect ; //交点
				UINT nIndexOfVertex = 0 ;
				int iPtOnPLine = m_mysys.IsPointOnPolyLine(pPolyLine, pt_3d_ref, nIndexOfVertex,0.05) ;
				if (iPtOnPLine==1000)
				{
					if (iRet==-1)
					{
						iRet = 2 ;
						pPolyLine->getClosestPointTo(pt_3d_ref, pt_3d_intersect) ;
						bValidData = TRUE ;
					}
					else
					{
						iRet = 0 ;
					}
				}
				else if (iPtOnPLine>-1&&iPtOnPLine<1000)
				{
					if (iPtOnPLine==0) //起点
					{
						pPolyLine->getStartPoint(pt_3d_intersect) ;
						if (iRet==-1)
						{
							iRet = 5 ;
							bValidData = TRUE ;
						}
						else if (iRet==1)
						{
							iRet = 5*10+1 ;
							bValidData = TRUE ;
						}
						else
						{
							iRet = 0 ;
						}
					}
					else //终点
					{
						pPolyLine->getEndPoint(pt_3d_intersect) ;
						if (iRet==-1)
						{
							iRet = 1 ;
							bValidData = TRUE ;
						}
						else if (iRet==5)
						{
							iRet = 1*10+5 ;
							bValidData = TRUE ;
						}
						else
						{
							iRet = 0 ;
						}
					}
				}
				if (bValidData)
				{
					nArrayHandleIntersect.Add(nHandleCur) ;
					nArrayIndexOfVertex.Add(nIndexOfVertex) ;
					pt3dArrayIntersect.append(pt_3d_intersect) ;
				}
			}

			pEnt->close() ;
		}		
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;	
	

	return iRet ;
}

int CZnSxt::DrawGuiDao(void)
{
	AcDbDatabase *pDb = acdbHostApplicationServices()->workingDatabase() ;	
	CUserSystem mysys ;
	mysys.m_pDb = pDb ;
	mysys.Set_Layer(_T(""), _T("sxt_guidao")) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select distinct sxt_line_handle from sxt_line")) ;
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long  iHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_line_handle"), iHandle) ;

				AcGePoint2dArray pt2dArray ;
				strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d order by sxt_line_vertex1"), iHandle) ;
				CADORecordset cSetVertex(&m_AdoDb) ;
				if (cSetVertex.Open(strSql))
				{
					if (!cSetVertex.IsBOF())
					{
						cSetVertex.MoveFirst() ;
					}
					while (!cSetVertex.IsEOF())
					{
						double dVertexX = 0.000, dVertexY = 0.000 ;
						cSetVertex.GetFieldValue(_T("sxt_line_vertex_x1"), dVertexX) ;
						cSetVertex.GetFieldValue(_T("sxt_line_vertex_y1"), dVertexY) ;
						AcGePoint2d pt_2d_tmp(dVertexX, dVertexY) ;
						pt2dArray.append(pt_2d_tmp) ;

						cSetVertex.MoveNext() ;
					}
					cSetVertex.Close() ;
				}
				
				mysys.AddAcDbPolyLine(pt2dArray, 0) ;

				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in DrawGuiDao"));
	}

	mysys.Set_Layer(_T(""), _T("0")) ;

	return 0;
}

// 绘制双线图
int CZnSxt::DrawSxt(double dScaleX, double dScaleY, const AcGePoint3d & pt_3d_orign, double dLenDcPlus, double dDistBetweenSX)
{
	AcDbObjectId objIdOldLayer = m_pDb->clayer() ;
	m_mysys.Set_Layer(_T(""), _T("sxt")) ;
	AcGeTol tol  ; 
	tol.setEqualVector(0.00001) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;

		//begin 根据指定基点、缩放比值，计算实体（信号机、道岔、轨道线）坐标值
		CString strTables[2] ={ _T("sxt_ent"), _T("sxt_line")} ;
		for (int iTbIndex=0; iTbIndex<2; iTbIndex++)
		{
			strSql.Format(_T("select * from %s"), strTables[iTbIndex]) ;
			CString strField1[2], strField2[2], strField3[2], strField4[2] ;

			for (int i=0; i<2; i++)
			{
				if (iTbIndex==0)
				{
					strField1[i].Format(_T("%s_x%d"), strTables[iTbIndex], i+1) ;
					strField2[i].Format(_T("%s_y%d"), strTables[iTbIndex], i+1) ;
					strField3[i].Format(_T("%s_online_intersectx%d"), strTables[iTbIndex], i+1) ;
					strField4[i].Format(_T("%s_online_intersecty%d"), strTables[iTbIndex], i+1) ;
				}
				else if (iTbIndex==1)
				{
					strField1[i].Format(_T("%s_vertex_x%d"), strTables[iTbIndex], i+1) ;
					strField2[i].Format(_T("%s_vertex_y%d"), strTables[iTbIndex], i+1) ;
				}
			}

			if(cSet.Open(strSql))
			{
				while(!cSet.IsEOF())
				{
					double dEntX = 0.000, dEntY = 0.000, dEntX1 = 0.000, dEntY1 = 0.000;		

					cSet.GetFieldValue(strField1[0], dEntX) ;
					cSet.GetFieldValue(strField2[0], dEntY) ;
					dEntX = pt_3d_orign.x +dEntX*dScaleX ;
					dEntY = pt_3d_orign.y +dEntY*dScaleY ;

					if (iTbIndex==0)
					{
						cSet.GetFieldValue(strField3[0], dEntX1) ;
						cSet.GetFieldValue(strField4[0], dEntY1) ;
						dEntX1 = pt_3d_orign.x +dEntX1*dScaleX ;
						dEntY1 = pt_3d_orign.y +dEntY1*dScaleY ;
					}
					cSet.Edit() ;
					cSet.SetFieldValue(strField1[1], dEntX) ;
					cSet.SetFieldValue(strField2[1], dEntY) ;
					if (iTbIndex==0)
					{
						cSet.SetFieldValue(strField3[1], dEntX1) ;
						cSet.SetFieldValue(strField4[1], dEntY1) ;
					}
					cSet.Update() ;

					cSet.MoveNext() ;
				}

				cSet.Close() ;
			}
		}
		//end 根据指定基点、缩放比值，计算实体（信号机、道岔、轨道线）坐标值

		//begin 绘制线
		strSql.Format(_T("select distinct sxt_line_handle from sxt_line")) ;
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long  iHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_line_handle"), iHandle) ;
				//begin 读取该线信息for绘制轨道名称
				CString strGdName ;
				int iGdWriteLeftOrRight = -1 ; //轨道名称写在线左侧0还是右侧1
				AcDbEntity* pEntLine = NULL ;
				if (m_mysys.OpenAcDbEntity(iHandle, pEntLine, AcDb::kForRead))
				{
					if(m_mysys.GetXdata(pEntLine, _T("GUIDAONAME"), strGdName))
					{
						if (!strGdName.IsEmpty())
						{
							CString strLeftForS=_T("N"), strRightForS = _T("N") ;
							m_mysys.GetXdata(pEntLine, _T("LEFT_FORS"), strLeftForS) ;
							m_mysys.GetXdata(pEntLine, _T("RIGHT_FORS"), strRightForS) ;
							if (strLeftForS==_T("S"))
							{
								iGdWriteLeftOrRight = 0 ;
							}
							else if (strRightForS==_T("S"))
							{
								iGdWriteLeftOrRight = 1 ;
							}
							else if (strLeftForS==_T("F"))
							{
								iGdWriteLeftOrRight = 0 ;
							}
							else if (strRightForS==_T("F"))
							{
								iGdWriteLeftOrRight = 1 ;
							}
						}
					}
					pEntLine->close() ;
				}
				//end 读取该线信息for绘制轨道名称

				//确定该多段线的起点和终点是否都是DC的反位连接端

				AcGePoint2dArray pt2dArrayUp, pt2dArrayDown ;
				AcArray <double> dDrawOptionUps,dDrawOptionDowns ;
				//VertexInfo=A:0,B:0,C:0;A:1,B:0,C:0;A:2,B:1,C:-1;A:3,B:2,C:1;A:4,B:3,C:2
				//ABC后面数字表示：A，双线中线的顶点序号；B，原平面图线加上极性切割绝缘节后形成的顶点序号；C，原平面图线不考虑极性绝缘节的顶点序号
				CString strXdataUp, strXdataDown ; 
				CString strXdataUpForZZJ, strXdataDownForZZJ ; //记录形式（针对的是道岔FW线）：端头连接的道岔handle-道岔FW朝向（1，朝上；0，朝下）-FW端线的顶点vertex（起点或终点）-道岔所在DW线-道岔所在DW线vertex
				strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d order by sxt_line_vertex1"), iHandle) ;
				CADORecordset cSetVertex(&m_AdoDb) ;
				if (cSetVertex.Open(strSql))
				{
					int iNumVertex = cSetVertex.GetRecordCount() ;
					if (!cSetVertex.IsBOF())
					{
						cSetVertex.MoveFirst() ;
					}
					int iIndexVertex = 0 ;
					int iDrawOptionPre = 2222 ; //前一顶点的DrawOption
					while (!cSetVertex.IsEOF())
					{
						//acutPrintf(_T("\nhandle:%d,vetex:%d"), iHandle, iIndexVertex) ;
						AcGePoint2d pt_2d_up(0,0), pt_2d_down(0,0) ; //双线的上下2个点
						AcGePoint2d pt_2d_cur(0,0), pt_2d_pre(0,0), pt_2d_back(0,0) ; 

						int iIndexVertexOld = iIndexVertex ; //原顶点序号（未加入切割点）
						cSetVertex.GetFieldValue(_T("sxt_line_vertex"), iIndexVertexOld) ;
						
						cSetVertex.GetFieldValue(_T("sxt_line_vertex_x2"), pt_2d_cur.x) ;
						cSetVertex.GetFieldValue(_T("sxt_line_vertex_y2"), pt_2d_cur.y) ;

						//begin 线宽
						long nHandleVertex = 0 ; //该点对应的绝缘节或者道岔
						int iDrawOptionCur = -1 ; //当前顶点的DrawOption
						cSetVertex.GetFieldValue(_T("sxt_line_vertex_handle"), nHandleVertex) ;

						double dWidthUp = 0, dWidthDown = 0 ;

						int iPolar = 0 ;
						cSetVertex.GetFieldValue(_T("sxt_line_polar"), iPolar) ;
						if (iIndexVertex==(iNumVertex-1)) //最后一段极性取前一个顶点的值
						{
							cSetVertex.MovePrevious() ;
							cSetVertex.GetFieldValue(_T("sxt_line_polar"), iPolar) ;
							cSetVertex.MoveNext() ;
						}
						if (iPolar==-1) //上粗下细
						{
							dWidthUp = 0.5 ;
							dWidthDown = 0 ;							
						}
						else if (iPolar==1)
						{
							dWidthUp = 0 ;
							dWidthDown = 0.5 ;				
						}
						//end 线宽

						if (iIndexVertex!=0)//不是第一个点
						{
							cSetVertex.MovePrevious() ;
							cSetVertex.GetFieldValue(_T("sxt_line_vertex_x2"), pt_2d_pre.x) ;
							cSetVertex.GetFieldValue(_T("sxt_line_vertex_y2"), pt_2d_pre.y) ;
							cSetVertex.MoveNext() ;
						}
						if (iIndexVertex!=(iNumVertex-1)) //不是最后一个点
						{
							cSetVertex.MoveNext() ;
							cSetVertex.GetFieldValue(_T("sxt_line_vertex_x2"), pt_2d_back.x) ;
							cSetVertex.GetFieldValue(_T("sxt_line_vertex_y2"), pt_2d_back.y) ;
							cSetVertex.MovePrevious() ;
						}

						if (iIndexVertex==0)
						{
							AcGeLineSeg2d lineSeg2dSrc(pt_2d_cur, pt_2d_back) ;
							AcGeLineSeg2d lineSeg2dParallelUp, lineSeg2dParallelDown ;
							m_mysys.GetParallelLine(lineSeg2dSrc, lineSeg2dParallelUp, 2.5 ) ;
							m_mysys.GetParallelLine(lineSeg2dSrc, lineSeg2dParallelDown, 2.5, FALSE) ;
							pt_2d_up = lineSeg2dParallelUp.startPoint() ;
							pt_2d_down = lineSeg2dParallelDown.startPoint() ;

							//begin 绘制轨道名称
							if (iGdWriteLeftOrRight==0)
							{
								AcGePoint2d pt_2d_gdname = lineSeg2dSrc.midPoint() ;
								AcGePoint3d pt_3dg_gdname(pt_2d_gdname.x, pt_2d_gdname.y, 0) ;
								AcGeVector2d vecLine = lineSeg2dSrc.direction() ;
								AcDbObjectId objIdGdName ;
								m_mysys.AddText(objIdGdName, strGdName, pt_3dg_gdname, pt_3dg_gdname, AcDb::kTextCenter, AcDb::kTextVertMid, 2.5, 0.8, vecLine.angle(), 4)  ;	
								m_mysys.SetXdata(objIdGdName, _T("TYPE"), (long)101) ; //双线图中轨道名称文本
								m_mysys.SetXdata(objIdGdName, _T("BELONG_ENT"), iHandle) ;
							}
							//end 绘制轨道名称

							//和该FW端相交的DW轨道线的信息
							AcGePoint2d pt_2d_start_dw, pt_2d_end_dw ;	
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d and sxt_ent_fwline_vertex=%d"), iHandle, iIndexVertex) ;
							long iHandleDW = 0 ;
							int iLineVertexDW = 0 ;							
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), iHandleDW) ;
							long nHandleDc = 0 ; //以该线为反位线的道岔记录下来，为双线图绘制尖轨芯轨用
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDc) ;
							CString strDcName ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strDcName) ;
							int iUpOrDownDc = 0 ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_upordown"), iUpOrDownDc) ;
							if (iHandleDW!=0) //还有不是和DC反位相连的线，比如轨道起始
							{
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_vertex"), iLineVertexDW) ;
								strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex=%d"), iHandleDW, iLineVertexDW) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x2"), pt_2d_start_dw.x) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y2"),  pt_2d_start_dw.y) ;
								strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex=%d"), iHandleDW, iLineVertexDW+1) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x2"), pt_2d_end_dw.x) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y2"),  pt_2d_end_dw.y) ;
								//2条平行线，一条距定位2.5,，另一条是距定位线1.5
								AcGeLineSeg2d lineSeg2dDwSrc(pt_2d_start_dw, pt_2d_end_dw), lineSeg2dDw25, lineSeg2dDw15 ;

								//begin 尖轨、芯轨牵引数量
								//int iJgNum = 3, iXgNum = 2 ; 
								double dAngleDc = 0 ; //道岔块旋转角度
								AcDbEntity* pEntDc = NULL ;
								if (m_mysys.OpenAcDbEntity(nHandleDc, pEntDc, AcDb::kForRead))
								{
									AcDbBlockReference* pRefDc = AcDbBlockReference::cast(pEntDc) ;
									dAngleDc = pRefDc->rotation() ;
									pEntDc->close() ;
								}
								//end 尖轨、芯轨牵引数量

								AcGePoint2d pt_2d_ext ;
								AcGeVector2d vecDw = pt_2d_end_dw-pt_2d_start_dw ;
								//用于判断道岔垂直方向，不能简单根据*** int iDcDirectV = ((pt_2d_back.y-pt_2d_cur.y)>0.5?0:1) ; //道岔垂直方向（FW向上0、向下1）***
								//根据以下算法：道岔旋转角，90~270度之间，向下	
								int iDcDirectV =0 ; //道岔垂直方向（FW向上0、向下1）
								if (dAngleDc>PI/2&&dAngleDc<(PI*3/2))
								{
									iDcDirectV = 1 ;
								}
								if (iDcDirectV==0) //反位端朝上
								{
									//反位端相交的所在多段线及段序号
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw25, 2.5, TRUE) ;
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw15, 1.5, FALSE) ;

									lineSeg2dParallelUp.intersectWith(lineSeg2dDw25, pt_2d_up) ;
									lineSeg2dParallelDown.intersectWith(lineSeg2dDw15, pt_2d_down) ;

									//Dc反位线和定位线平行的一段
									pt_2d_ext =pt_2d_down ;
									pt_2d_ext.x -=dLenDcPlus ;
									pt_2d_ext.rotateBy(vecDw.angle(), pt_2d_down) ;								
									pt2dArrayDown.append(pt_2d_ext) ;		
									dDrawOptionDowns.append(dWidthDown) ;
									strXdataDown.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayDown.length()-1, iIndexVertex, iIndexVertexOld) ;
									strXdataDownForZZJ.AppendFormat(_T("%d-1-%d-%d-%d;"), nHandleDc, iIndexVertex, iHandleDW, iLineVertexDW) ;	
								}
								else //反位端朝下，（反位端在水平线上，视同反位朝下）
								{
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw25, 2.5, FALSE) ;
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw15, 1.5, TRUE) ;

									lineSeg2dParallelUp.intersectWith(lineSeg2dDw15, pt_2d_up) ;
									lineSeg2dParallelDown.intersectWith(lineSeg2dDw25, pt_2d_down) ;

									//Dc反位线和定位线平行的一段
									pt_2d_ext = pt_2d_up ;
									pt_2d_ext.x -=dLenDcPlus ;
									pt_2d_ext.rotateBy(vecDw.angle(), pt_2d_up) ;
									pt2dArrayUp.append(pt_2d_ext) ;
									dDrawOptionUps.append(dWidthUp) ;
									strXdataUp.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayUp.length()-1, iIndexVertex, iIndexVertexOld) ;
									strXdataUpForZZJ.AppendFormat(_T("%d-0-%d-%d-%d;"), nHandleDc, iIndexVertex, iHandleDW, iLineVertexDW) ;
								}

								//begin draw zzj
								int iDcDirectH =0 ; //道岔FW水平朝向，0朝右，1，朝左
								AcGeLineSeg2d line2d(pt_2d_ext,iDcDirectV==0?pt_2d_down:pt_2d_up) ;									
								AcGePoint2d pt_2d_extcen =line2d.midPoint() ;
								AcGePoint2d pt_2d_extcen_mid = pt_2d_extcen ;
								pt_2d_extcen_mid.y+=(iDcDirectV==0?1.5:-1.5) ;
								pt_2d_extcen_mid.rotateBy(vecDw.angle(), pt_2d_extcen) ;

								//映射到双线的一边
								AcGePoint2d pt_2d_extcen_jg = pt_2d_extcen_mid ;
								pt_2d_extcen_jg.y +=(iUpOrDownDc==0?-2.5:2.5); 
								pt_2d_extcen_jg.rotateBy(vecDw.angle(), pt_2d_extcen) ;
								
								//道岔名称
								AcGePoint2d pt_2d_dcname = pt_2d_extcen_jg ;
								pt_2d_dcname.y+=(iUpOrDownDc==0?-2:2); 
								pt_2d_dcname.rotateBy(vecDw.angle(), pt_2d_extcen_jg) ;
								AcGePoint3d pt_3d_dcname(pt_2d_dcname.x, pt_2d_dcname.y,0) ;
								m_mysys.AddText(strDcName, pt_3d_dcname, pt_3d_dcname, AcDb::kTextCenter, AcDb::kTextVertMid, 2.5, 0.8, vecDw.angle(), 3) ;
								//end draw zzj
							}

							pt2dArrayUp.append(pt_2d_up) ;
							dDrawOptionUps.append(dWidthUp) ;
							strXdataUp.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayUp.length()-1, iIndexVertex, iIndexVertexOld) ;
							pt2dArrayDown.append(pt_2d_down) ;
							dDrawOptionDowns.append(dWidthDown) ;
							strXdataDown.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayDown.length()-1, iIndexVertex, iIndexVertexOld) ;
						}
						else if (iIndexVertex==(iNumVertex-1))
						{
							AcGeLineSeg2d lineSeg2dSrc(pt_2d_pre, pt_2d_cur) ;
							AcGeLineSeg2d lineSeg2dParallelUp, lineSeg2dParallelDown ;
							m_mysys.GetParallelLine(lineSeg2dSrc, lineSeg2dParallelUp, 2.5 ) ;
							m_mysys.GetParallelLine(lineSeg2dSrc, lineSeg2dParallelDown, 2.5, FALSE) ;
							pt_2d_up = lineSeg2dParallelUp.endPoint() ;
							pt_2d_down = lineSeg2dParallelDown.endPoint() ;

							//begin 绘制轨道名称
							if (iGdWriteLeftOrRight==1)
							{
								AcGePoint2d pt_2d_gdname = lineSeg2dSrc.midPoint() ;
								AcGePoint3d pt_3dg_gdname(pt_2d_gdname.x, pt_2d_gdname.y, 0) ;
								AcGeVector2d vecLine = lineSeg2dSrc.direction() ;
								AcDbObjectId objIdGdName ;
								m_mysys.AddText(objIdGdName, strGdName, pt_3dg_gdname, pt_3dg_gdname, AcDb::kTextCenter, AcDb::kTextVertMid, 2.5, 0.8, vecLine.angle(), 4)  ;	
								m_mysys.SetXdata(objIdGdName, _T("TYPE"), (long)101) ; //双线图中轨道名称文本
								m_mysys.SetXdata(objIdGdName, _T("BELONG_ENT"), iHandle) ;
							}
							//end 绘制轨道名称

							int iIndexVertexOld = -1 ;
							cSetVertex.GetFieldValue(_T("sxt_line_vertex"), iIndexVertexOld) ;

							//和该FW端相交的DW轨道线的信息
							AcGePoint2d pt_2d_start_dw, pt_2d_end_dw ;	
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d and sxt_ent_fwline_vertex=%d"), iHandle, iIndexVertexOld) ;
							long iHandleDW = 0 ;
							int iLineVertexDW = 0 ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), iHandleDW) ;
							long nHandleDc = 0 ; //以该线为反位线的道岔记录下来，为双线图绘制尖轨芯轨用
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDc) ;
							CString strDcName ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strDcName) ;
							int iUpOrDownDc = 0 ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_upordown"), iUpOrDownDc) ;

							if (iHandleDW!=0) //还有不是和DC反位相连的线，比如轨道终点
							{
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_vertex"), iLineVertexDW) ;
								strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex=%d"), iHandleDW, iLineVertexDW) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x2"), pt_2d_start_dw.x) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y2"),  pt_2d_start_dw.y) ;
								strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex=%d"), iHandleDW, iLineVertexDW+1) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x2"), pt_2d_end_dw.x) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y2"),  pt_2d_end_dw.y) ;
								//2条平行线，一条距定位2.5,，另一条是距定位线1.5
								AcGeLineSeg2d lineSeg2dDwSrc(pt_2d_start_dw, pt_2d_end_dw), lineSeg2dDw25, lineSeg2dDw15 ;

								//begin 尖轨、芯轨牵引数量
								double dAngleDc = 0 ; //道岔块旋转角度
								AcDbEntity* pEntDc = NULL ;
								if (m_mysys.OpenAcDbEntity(nHandleDc, pEntDc, AcDb::kForRead))
								{
									AcDbBlockReference* pRefDc = AcDbBlockReference::cast(pEntDc) ;
									dAngleDc = pRefDc->rotation() ;
									pEntDc->close() ;
								}
								//end 尖轨、芯轨牵引数量

								AcGePoint2d pt_2d_ext ;
								AcGeVector2d vecDw = pt_2d_end_dw-pt_2d_start_dw ;
								//用于判断道岔垂直方向，不能简单根据*** int iDcDirectV = ((pt_2d_pre.y-pt_2d_cur.y)>0.5?0:1) ; //道岔垂直方向（FW向上0、向下1）***
								//根据以下算法：道岔旋转角，90~270度之间，向下								
								int iDcDirectV =0 ; //道岔垂直方向（FW向上0、向下1）
								if (dAngleDc>PI/2&&dAngleDc<(PI*3/2))
								{
									iDcDirectV = 1 ;
								}
								if (iDcDirectV==0) //反位端朝上,允许一定误差，这个0.5可再议
								{
									//反位端相交的所在多段线及段序号
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw25, 2.5, TRUE) ;
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw15, 1.5, FALSE) ;

									lineSeg2dParallelUp.intersectWith(lineSeg2dDw25, pt_2d_up) ;
									lineSeg2dParallelDown.intersectWith(lineSeg2dDw15, pt_2d_down) ;

									pt2dArrayUp.append(pt_2d_up) ;
									dDrawOptionUps.append(dWidthUp) ;
									strXdataUp.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayUp.length()-1, iIndexVertex, iIndexVertexOld) ;
									pt2dArrayDown.append(pt_2d_down) ;
									dDrawOptionDowns.append(dWidthDown) ;
									strXdataDown.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayDown.length()-1, iIndexVertex, iIndexVertexOld) ;

									//Dc反位线和定位线平行的一段
									pt_2d_ext =pt_2d_down ;
									pt_2d_ext.x +=dLenDcPlus ;
									//AcGeVector2d vecDw = pt_2d_end_dw-pt_2d_start_dw ;
									pt_2d_ext.rotateBy(vecDw.angle(), pt_2d_down) ;								
									pt2dArrayDown.append(pt_2d_ext) ;	
									dDrawOptionDowns.append(dWidthDown) ;
									strXdataDown.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayDown.length()-1, iIndexVertex, iIndexVertexOld) ;
									strXdataDownForZZJ.AppendFormat(_T("%d-1-%d-%d-%d;"), nHandleDc, iIndexVertex, iHandleDW, iLineVertexDW) ;
								}
								else //反位端朝下，（反位端在水平线上，视同反位朝下）
								{
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw25, 2.5, FALSE) ;
									m_mysys.GetParallelLine(lineSeg2dDwSrc, lineSeg2dDw15, 1.5, TRUE) ;

									lineSeg2dParallelUp.intersectWith(lineSeg2dDw15, pt_2d_up) ;
									lineSeg2dParallelDown.intersectWith(lineSeg2dDw25, pt_2d_down) ;

									pt2dArrayUp.append(pt_2d_up) ;
									dDrawOptionUps.append(dWidthUp) ;
									strXdataUp.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayUp.length()-1, iIndexVertex, iIndexVertexOld) ;
									pt2dArrayDown.append(pt_2d_down) ;
									dDrawOptionDowns.append(dWidthDown) ;
									strXdataDown.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayDown.length()-1, iIndexVertex, iIndexVertexOld) ;

									//Dc反位线和定位线平行的一段
									pt_2d_ext = pt_2d_up ;
									pt_2d_ext.x +=dLenDcPlus ;
									//AcGeVector2d vecDw = pt_2d_end_dw-pt_2d_start_dw ;
									pt_2d_ext.rotateBy(vecDw.angle(), pt_2d_up) ;
									pt2dArrayUp.append(pt_2d_ext) ;
									dDrawOptionUps.append(dWidthUp) ;
									strXdataUp.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayUp.length()-1, iIndexVertex, iIndexVertexOld) ;
									strXdataUpForZZJ.AppendFormat(_T("%d-0-%d-%d-%d;"), nHandleDc, iIndexVertex, iHandleDW, iLineVertexDW) ;
								}

								//begin draw zzj
								int iDcDirectH = 1 ; //道岔FW水平朝向，0朝右，1，朝左
								AcGeLineSeg2d line2d(pt_2d_ext,iDcDirectV==0?pt_2d_down:pt_2d_up) ;									
								AcGePoint2d pt_2d_extcen =line2d.midPoint() ;

								AcGePoint2d pt_2d_extcen_mid = pt_2d_extcen ;
								pt_2d_extcen_mid.y+=(iDcDirectV==0?1.5:-1.5) ;
								pt_2d_extcen_mid.rotateBy(vecDw.angle(), pt_2d_extcen) ;

								//映射到双线的一边
								AcGePoint2d pt_2d_extcen_jg = pt_2d_extcen_mid ;
								pt_2d_extcen_jg.y +=(iUpOrDownDc==0?-2.5:2.5); 
								pt_2d_extcen_jg.rotateBy(vecDw.angle(), pt_2d_extcen) ;

								//道岔名称
								AcGePoint2d pt_2d_dcname = pt_2d_extcen_jg ;
								pt_2d_dcname.y+=(iUpOrDownDc==0?-2:2); 
								pt_2d_dcname.rotateBy(vecDw.angle(), pt_2d_extcen_jg) ;
								AcGePoint3d pt_3d_dcname(pt_2d_dcname.x, pt_2d_dcname.y,0) ;
								m_mysys.AddText(strDcName, pt_3d_dcname, pt_3d_dcname, AcDb::kTextCenter, AcDb::kTextVertMid, 2.5, 0.8, vecDw.angle(), 3) ;
								//end draw zzj
							}
							else
							{
								pt2dArrayUp.append(pt_2d_up) ;
								dDrawOptionUps.append(dWidthUp) ;
								strXdataUp.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayUp.length()-1, iIndexVertex, iIndexVertexOld) ;
								pt2dArrayDown.append(pt_2d_down) ;
								dDrawOptionDowns.append(dWidthDown) ;
								strXdataDown.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayDown.length()-1, iIndexVertex, iIndexVertexOld) ;
							}
						}
						else
						{
							AcGeLineSeg2d lineSeg2dSrc1(pt_2d_pre, pt_2d_cur), lineSeg2dSrc2(pt_2d_cur, pt_2d_back) ;	
							//acutPrintf(_T("\nlinesrc1(%.3f,%.3f)(%.3f,%.3f) linesrc2(%.3f,%.3f)(%.3f,%.3f)"), lineSeg2dSrc1.startPoint().x,lineSeg2dSrc1.startPoint().y,lineSeg2dSrc1.endPoint().x,lineSeg2dSrc1.endPoint().y,lineSeg2dSrc2.startPoint().x,lineSeg2dSrc2.startPoint().y, lineSeg2dSrc2.endPoint().x,lineSeg2dSrc2.endPoint().y );

							AcGeLineSeg2d lineSeg2dParallelUp1, lineSeg2dParallelDown1, lineSeg2dParallelUp2, lineSeg2dParallelDown2 ;
							m_mysys.GetParallelLine(lineSeg2dSrc1, lineSeg2dParallelUp1, 2.5 ) ;
							m_mysys.GetParallelLine(lineSeg2dSrc1, lineSeg2dParallelDown1, 2.5, FALSE) ;
							m_mysys.GetParallelLine(lineSeg2dSrc2, lineSeg2dParallelUp2, 2.5 ) ;
							m_mysys.GetParallelLine(lineSeg2dSrc2, lineSeg2dParallelDown2, 2.5, FALSE) ;				

							//lineSeg2dParallelUp1.intersectWith(lineSeg2dParallelUp2, pt_2d_up) ;
							//lineSeg2dParallelDown1.intersectWith(lineSeg2dParallelDown2, pt_2d_down) ;
							m_mysys.IntersectWith(&lineSeg2dParallelUp1, &lineSeg2dParallelUp2, pt_2d_up, AcDb::kExtendBoth) ;
							m_mysys.IntersectWith(&lineSeg2dParallelDown1, &lineSeg2dParallelDown2, pt_2d_down, AcDb::kExtendBoth) ;

							if (lineSeg2dSrc1.isParallelTo(lineSeg2dSrc2, tol))
							{
								pt_2d_up = lineSeg2dParallelUp1.endPoint() ;
								pt_2d_down = lineSeg2dParallelDown1.endPoint() ;
							}
							//acutPrintf(_T("\nintersect-up(%.3f,%.3f)intersect-down(%.3f,%.3f)"), pt_2d_up.x,pt_2d_up.y,pt_2d_down.x,pt_2d_down.y );

							pt2dArrayUp.append(pt_2d_up) ;
							dDrawOptionUps.append(dWidthUp) ;
							strXdataUp.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayUp.length()-1, iIndexVertex, iIndexVertexOld) ;
							pt2dArrayDown.append(pt_2d_down) ;
							dDrawOptionDowns.append(dWidthDown) ;
							strXdataDown.AppendFormat(_T("A:%d,B:%d,C:%d;"), pt2dArrayDown.length()-1, iIndexVertex, iIndexVertexOld) ;
						}

						cSetVertex.MoveNext() ;
						iIndexVertex++ ;
						iDrawOptionPre = iDrawOptionCur ;
					}
					cSetVertex.Close() ;
				}

				AcDbObjectId objIdUp = m_mysys.AddAcDbPolyLine(pt2dArrayUp, dDrawOptionUps, 7) ;				
				AcDbObjectId objIdDown = m_mysys.AddAcDbPolyLine(pt2dArrayDown, dDrawOptionDowns, 7) ;

				//set xdata
				strXdataUp.TrimRight(_T(";")) ;
				strXdataDown.TrimRight(_T(";")) ;
				strXdataUpForZZJ.TrimRight(_T(";")) ;
				strXdataDownForZZJ.TrimRight(_T(";")) ;
				AcDbEntity * pEnt = NULL ;
				if (m_mysys.OpenAcDbEntity(objIdUp, pEnt))
				{
					m_mysys.SetXdata(pEnt, _T("CloneFrom"), iHandle) ;
					m_mysys.SetXdata(pEnt, _T("UPDOWN"), 1) ;
					m_mysys.SetXdata(pEnt, _T("VertexInfo"), strXdataUp) ;
					if (!strXdataUpForZZJ.IsEmpty())
					{
						m_mysys.SetXdata(pEnt, _T("ForZZJ"), strXdataUpForZZJ) ;
					}
					pEnt->close() ;
				}
				if (m_mysys.OpenAcDbEntity(objIdDown, pEnt))
				{
					m_mysys.SetXdata(pEnt, _T("CloneFrom"), iHandle) ;
					m_mysys.SetXdata(pEnt, _T("UPDOWN"), 0) ;
					m_mysys.SetXdata(pEnt, _T("VertexInfo"), strXdataDown) ;
					if (!strXdataDownForZZJ.IsEmpty())
					{
						m_mysys.SetXdata(pEnt, _T("ForZZJ"), strXdataDownForZZJ) ;
					}
					pEnt->close() ;
				}

				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
		//end 绘制线

		//begin 信号机
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type=100")) ;
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;
				
				double dEntX = 0.000, dEntY = 0.000 ;				
				cSet.GetFieldValue(_T("sxt_ent_x2"), dEntX) ;
				cSet.GetFieldValue(_T("sxt_ent_y2"), dEntY) ;
				CString strBlkName ; 
				cSet.GetFieldValue(_T("sxt_ent_block"), strBlkName) ;
				AcDbEntity * pEnt = NULL ;
				if (m_mysys.OpenAcDbEntity(nHandle, pEnt))
				{
					AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;
					double dAngle = pRef->rotation() ;
					AcGePoint3d pt_3d_old = pRef->position() ;
					AcDbBlockReference *pRefNew = AcDbBlockReference::cast(pRef->clone()) ;
					m_mysys.SetXdata(pRefNew, _T("CloneFrom"), nHandle) ;
					AcGePoint3d pt_3d_new(dEntX, dEntY, 0) ;
					AcGeMatrix3d matrix ;
					AcGeVector3d vec = pt_3d_new - pt_3d_old ;
					matrix.setToTranslation(vec) ;
					pRefNew->transformBy(matrix) ; 
					//begin 在双线图中，信号机基点不能在中线上，要至少上/下移2.5
					AcGePoint3d pt_3d_new2(pt_3d_new) ;
					int iMarkLoc = strBlkName.Find(_T("_Z_")) ;//正向信号机（Z 立于左侧）, 逆向信号机(Y 立于右侧)
					//角度在90度~270度之间是倒置了
					if (dAngle>PI/2&&dAngle<PI*3/2)
					{
						pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?2.5:-2.5) ;
					}
					else
					{
						pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?-2.5:2.5) ;
					}
					pt_3d_new2.rotateBy(PI/2, AcGeVector3d::kZAxis, pt_3d_new) ;
					vec = pt_3d_new2 - pt_3d_new ;
					matrix.setToTranslation(vec) ;
					pRefNew->transformBy(matrix) ; 
					//end 在双线图中，信号机基点不能在中线上，要至少上/下移2.5
					pRefNew->setLayer(_T("sxt")) ;
					m_mysys.AddEntityToDb(pRefNew) ;
					pRefNew->close() ;

					pEnt->close() ;
				}

				cSet.MoveNext() ;
			}

			cSet.Close() ;
		}
		//end 信号机

		//begin 绝缘节
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=2")) ; //整除为2的
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;
				int iEntType = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_type"), iEntType) ;

				//计算双线中线绝缘节位置时，应以平面图绝缘节和多段线交点作为源数据为宜
				double dEntX = 0.000, dEntY = 0.000 ;				
				cSet.GetFieldValue(_T("sxt_ent_online_intersectx2"), dEntX) ;
				cSet.GetFieldValue(_T("sxt_ent_online_intersecty2"), dEntY) ;
				
				///begin 绝缘节所在线段信息	
				AcGeVector2d vecOnLine = GetAngleOfJyjOnLine(nHandle) ;
				double dAngleOnLine = 0 ;
				dAngleOnLine = vecOnLine.angle() ;
				//end  绝缘节所在线段信息

				//begin 复制平面图中的绝缘节（2份）并经过移动转换到双线中
				AcDbEntity * pEnt = NULL ;
				if (m_mysys.OpenAcDbEntity(nHandle, pEnt))
				{
					AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;
					double dAngle = pRef->rotation() ;
					AcGePoint3d pt_3d_old = pRef->position() ;
					AcDbBlockReference *pRefNew1 = AcDbBlockReference::cast(pRef->clone()) ;
					AcDbBlockReference *pRefNew2 = AcDbBlockReference::cast(pRef->clone()) ;
					AcGePoint3d pt_3d_new(dEntX, dEntY, 0) ;//双线中间线和绝缘节交点位置
					AcGeMatrix3d matrix ;
					AcGeVector3d vec = pt_3d_new - pt_3d_old ;
					matrix.setToTranslation(vec) ;					
					pRefNew1->transformBy(matrix) ; 
					pRefNew2->transformBy(matrix) ; 
					//begin 在双线图中，绝缘节基点不能在中线上，上/下移2.5
					AcGePoint3d pt_3d_new1(pt_3d_new), pt_3d_new2(pt_3d_new) ;
					pt_3d_new1.x = pt_3d_new.x+2.5 ;
					pt_3d_new2.x = pt_3d_new.x-2.5 ;
					pt_3d_new1.rotateBy(PI/2+dAngleOnLine, AcGeVector3d::kZAxis, pt_3d_new) ;
					pt_3d_new2.rotateBy(PI/2+dAngleOnLine, AcGeVector3d::kZAxis, pt_3d_new) ;
					vec = pt_3d_new1 - pt_3d_new ;
					matrix.setToTranslation(vec) ;
					pRefNew1->transformBy(matrix) ; 
					vec = pt_3d_new2 - pt_3d_new ;
					matrix.setToTranslation(vec) ;
					pRefNew2->transformBy(matrix) ; 
					//end 在双线图中，绝缘节基点不能在中线上，上/下移2.5
					pRefNew1->setColorIndex(1) ;
					pRefNew1->setLayer(_T("sxt")) ;
					m_mysys.AddEntityToDb(pRefNew1) ;
					m_mysys.SetXdata(pRefNew1, _T("CloneFrom"), nHandle) ;
					m_mysys.SetXdata(pRefNew1, _T("UPDOWN"), 1) ;
					pRefNew1->close() ;
					pRefNew2->setColorIndex(3) ;
					pRefNew2->setLayer(_T("sxt")) ;
					m_mysys.AddEntityToDb(pRefNew2) ;
					m_mysys.SetXdata(pRefNew2, _T("CloneFrom"), nHandle) ;
					m_mysys.SetXdata(pRefNew2, _T("UPDOWN"), 0) ;
					pRefNew2->close() ;
					pEnt->close() ;
				}
				//end 复制平面图中的绝缘节（2份）并经过移动转换到双线中

				cSet.MoveNext() ;
			}

			cSet.Close() ;
		}
		//end 绝缘节		

		//begin 绘制跳线
		this->DrawJumpLine() ;		
		//end 绘制跳线
		
		//begin 绘制 信号楼(20150605：双线不绘制警冲标）
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type=310")) ;
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;

				double dEntX = 0.000, dEntY = 0.000 ;				
				cSet.GetFieldValue(_T("sxt_ent_x2"), dEntX) ;
				cSet.GetFieldValue(_T("sxt_ent_y2"), dEntY) ;
				CString strBlkName ; 
				cSet.GetFieldValue(_T("sxt_ent_block"), strBlkName) ;
				AcDbEntity * pEnt = NULL ;
				if (m_mysys.OpenAcDbEntity(nHandle, pEnt))
				{
					AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;
					double dAngle = pRef->rotation() ;
					AcGePoint3d pt_3d_old = pRef->position() ;
					AcDbBlockReference *pRefNew = AcDbBlockReference::cast(pRef->clone()) ;
					AcGePoint3d pt_3d_new(dEntX, dEntY, 0) ;
					AcGeMatrix3d matrix ;
					AcGeVector3d vec = pt_3d_new - pt_3d_old ;
					matrix.setToTranslation(vec) ;
					pRefNew->transformBy(matrix) ; 
					pRefNew->setLayer(_T("sxt")) ;
					m_mysys.AddEntityToDb(pRefNew) ;
					pRefNew->close() ;

					pEnt->close() ;
				}

				cSet.MoveNext() ;
			}

			cSet.Close() ;
		}
		//end 绘制警冲标 信号楼

		//begin 绘制距离信号楼距离
		AcGePoint3d pt_3d_min_dwg(0,0,0), pt_3d_max_dwg(0,0,0) ; //先取得当前图纸的范围,以便确定绘制距信号楼距离的坐标
		m_mysys.GetCurExtents(pt_3d_min_dwg, pt_3d_max_dwg) ;
		AcGePoint3d pt_3d_insert_toxhldist(pt_3d_min_dwg.x-20,pt_3d_max_dwg.y+100,0) ;
		double dRowHeight = 10 ;
		double dY1 = pt_3d_insert_toxhldist.y ;
		double dY2 = pt_3d_insert_toxhldist.y-dRowHeight ;
		double dY3 = pt_3d_insert_toxhldist.y-dRowHeight*2 ;
		double dY4 = pt_3d_insert_toxhldist.y-dRowHeight*3 ;
		double dY5 = pt_3d_insert_toxhldist.y-dRowHeight*4 ;
		for (int i=0; i<2; i++) //循环处理道岔、信号机
		{
			strSql.Format(_T("select distinct sxt_ent_toxhldist from sxt_ent where sxt_ent_type\\100=%d and sxt_ent_toxhldist<>0 order by sxt_ent_toxhldist"), i) ; //整除为0,dc;为1,xhj
			if (cSet.Open(strSql))
			{
				while(!cSet.IsEOF())
				{
					int iDist = 0 ;
					cSet.GetFieldValue(_T("sxt_ent_toxhldist"), iDist) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=%d and sxt_ent_toxhldist=%d"), i, iDist) ;
					CStringArray strArrayName ;
					int iNum = m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strArrayName) ;
					double dCenter_X = 0 ; //信号机或者道岔在双线图中的插入点，作为绘制距离文本的x坐标中心点,多个设备同一x坐标的，名称按此点左右散开
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x2"), dCenter_X) ;
					//距离数值文本
					AcGePoint3d pt_3d_insert_text(dCenter_X, dY5+dRowHeight*3/2+i*dRowHeight*2, 0) ;
					CString strDist ;
					strDist.Format(_T("%d"), abs(iDist)) ;
					m_mysys.AddText(strDist, pt_3d_insert_text, pt_3d_insert_text, AcDb::kTextCenter, AcDb::kTextVertMid, 2.2, 0.8, PI/2) ;
					//信号机名称或道岔编号
					pt_3d_insert_text.y-=dRowHeight ;
					for (int j=0; j<iNum; j++)
					{
						pt_3d_insert_text.x = dCenter_X-iNum*2.4/2+2.4/2+j*2.4 ;
						m_mysys.AddText(strArrayName.GetAt(j), pt_3d_insert_text, pt_3d_insert_text, AcDb::kTextCenter, AcDb::kTextVertMid, 2.2, 0.8, PI/2) ;
					}

					cSet.MoveNext() ;
				}

				cSet.Close() ;
			}
		}
		//插入表头、绘制行线5根
		AcDbBlockReference* pRef = NULL ;
		CString strBlkName = _T("PMT_TOXHL_HEADER") ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_insert_toxhldist))
		{
			pRef->close() ;
			pRef = NULL ;
		}
		for (int i=0; i<5; i++)
		{
			AcGePoint3d pt_3d_start(pt_3d_insert_toxhldist.x+20, pt_3d_insert_toxhldist.y-i*dRowHeight, 0) ;
			AcGePoint3d pt_3d_end(pt_3d_max_dwg.x, pt_3d_insert_toxhldist.y-i*dRowHeight, 0) ;
			m_mysys.AddAcDbPolyLine(pt_3d_start, pt_3d_end, 0.5) ;
		}
		//end 绘制距离信号楼距离
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in Drawsxt"));
	}

	m_pDb->setClayer(objIdOldLayer) ;

	return 0;
}

// 读取各绝缘节、道岔前后关系到relation表
void CZnSxt::FillRelationDB(void)
{
	m_AdoDb.ClearTable(_T("sxt_relation")) ;

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;

		//查出所有的前后关系(绝缘节、道岔)
		strSql.Format(_T("select distinct sxt_line_handle from sxt_line")) ;
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long  nHandleLine = 0 ;
				cSet.GetFieldValue(_T("sxt_line_handle"), nHandleLine) ;
				//begin 查找iHandle多线上所有的道岔、绝缘节
				//1、先查询起始vertex是否连着道岔反位端
				int iNumEntFirst = 0 ;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d and sxt_ent_fwline_vertex=0"), nHandleLine) ;
				long nHandleEntPre = 0, nEntTypePre =  0, nDirectPre = 0, nDfwPre = 0 ;
				iNumEntFirst = m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleEntPre) ;
				if (iNumEntFirst==1)
				{
					int iDwIntersectMoveToVertex = -1 ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_movetovertex"), iDwIntersectMoveToVertex) ;
					if (iDwIntersectMoveToVertex==-1)
					{
						nDirectPre = 1 ;
					}
					nDfwPre = 1 ;
				}
				else
				{
					//1.1对于分段pmt新增，线段左侧连接的绝缘节
					strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_right=%d and sxt_ent_type\\100=2"), nHandleLine) ;
					iNumEntFirst = m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleEntPre) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_type"), nEntTypePre) ;
				}

				//2、再查询在这条线上的绝缘节和道岔（定位相交）
				int iNumEntOnLine = 0 ;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type<>100 order by sxt_ent_x"), nHandleLine) ;
				CADORecordset cSetTmp(&m_AdoDb) ;
				if (cSetTmp.Open(strSql))
				{
					iNumEntOnLine = cSetTmp.GetRecordCount() ;
					if (iNumEntOnLine>0)
					{
						cSetTmp.MoveFirst() ;
						int iIndexEntOnLine = 0 ;
						while (!cSetTmp.IsEOF())
						{
							long nHandleEntCur = 0, nEntTypeCur =  0, nDirectCur = 0, nDfwCur = 0 ;
							cSetTmp.GetFieldValue(_T("sxt_ent_handle"), nHandleEntCur) ;
							cSetTmp.GetFieldValue(_T("sxt_ent_type"), nEntTypeCur) ;
							int iDwIntersectMoveToVertex = -1 ;
							cSetTmp.GetFieldValue(_T("sxt_ent_movetovertex"), iDwIntersectMoveToVertex) ;
							if (iDwIntersectMoveToVertex!=-1)
							{
								nDirectCur= 1 ;
							}							

							if (nHandleEntPre!=0)
							{
								strSql.Format(_T("insert into sxt_relation (sxt_relation_from_handle, sxt_relation_from_type, sxt_relation_to_handle, sxt_relation_to_type, sxt_relation_direct, sxt_relation_dfw) values(%d, %d, %d, %d, %d, %d)"), nHandleEntPre, nEntTypePre, nHandleEntCur, nEntTypeCur, nDirectPre, nDfwPre) ;
								m_AdoDb.Execute(strSql) ;
							}

							nHandleEntPre = nHandleEntCur ;
							nEntTypePre = nEntTypeCur ;
							nDirectPre = nDirectCur ;
							nDfwPre = nDfwCur ;

							cSetTmp.MoveNext() ;
							iIndexEntOnLine++ ;
						}
					}
					cSetTmp.Close() ;
				}

				//3、最后查询终点vertex是否连着道岔反位端
				int iNumEntLast = 0 ;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d and sxt_ent_fwline_vertex=(select max(sxt_line_vertex)  from sxt_line where sxt_line_handle=%d)"), nHandleLine, nHandleLine) ;
				long nHandleEntLast = 0, nEntTypeLast =  0, nDirectLast = 0, nDfwLast = 0 ;
				iNumEntLast = m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleEntLast) ;
				if (iNumEntLast==1)
				{
					int iDwIntersectMoveToVertex = -1 ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_movetovertex"), iDwIntersectMoveToVertex) ;
					if (iDwIntersectMoveToVertex==-1)
					{
						nDirectLast = 1 ;
					}
					nDfwLast = 1 ;

					if (nHandleEntPre!=0)
					{
						strSql.Format(_T("insert into sxt_relation (sxt_relation_from_handle, sxt_relation_from_type, sxt_relation_to_handle, sxt_relation_to_type, sxt_relation_direct, sxt_relation_dfw) values(%d, %d, %d, %d, %d, %d)"), nHandleEntPre, nEntTypePre, nHandleEntLast, nEntTypeLast, nDirectLast, nDfwLast) ;
						m_AdoDb.Execute(strSql) ;
					}
				}
				else
				{
					//3.1对于分段pmt新增，线段右侧连接的绝缘节
					strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_left=%d and sxt_ent_type\\100=2"), nHandleLine) ;
					iNumEntLast = m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleEntLast) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_type"), nEntTypeLast) ;
					if (iNumEntLast==1)
					{
						if (nHandleEntPre!=0)
						{
							strSql.Format(_T("insert into sxt_relation (sxt_relation_from_handle, sxt_relation_from_type, sxt_relation_to_handle, sxt_relation_to_type, sxt_relation_direct, sxt_relation_dfw) values(%d, %d, %d, %d, %d, %d)"), nHandleEntPre, nEntTypePre, nHandleEntLast, nEntTypeLast, nDirectLast, nDfwLast) ;
							m_AdoDb.Execute(strSql) ;
						}
					}
				}
				//end 查找iHandle多线上所有的道岔、绝缘节

				cSet.MoveNext() ;
			}
		}

		//计算各关系所属轨道区段编号(此处轨道区段不是轨道电路，而是极性概念上的区段，其小于等于轨道电路区段)
		strSql.Format(_T("select * from sxt_relation where sxt_relation_from_type\\100=2 and not (sxt_relation_to_type=0 and sxt_relation_dfw=1)")) ;
		if (cSet.Open(strSql))
		{
			int iIndexGuiDao = 0 ;
			while (!cSet.IsEOF())
			{
				long nHandleFrom = 0 ;
				cSet.GetFieldValue(_T("sxt_relation_from_handle"), nHandleFrom) ;
				this->FindOneGuiDao(nHandleFrom, iIndexGuiDao) ;
				iIndexGuiDao++ ;

				cSet.MoveNext() ;
			}

			cSet.Close();
		}

		//计算极性
		strSql.Format(_T("select distinct sxt_relation_polarsn from sxt_relation order by sxt_relation_polarsn")) ;
		if (cSet.IsOpen())
		{
			cSet.Close() ;
		}
		if (cSet.Open(strSql))
		{
			//计算下一个极性区段
			while (!cSet.IsEOF())
			{
				int iPolarSn = 0 ;
				cSet.GetFieldValue(_T("sxt_relation_polarsn"), iPolarSn) ;
				strSql.Format(_T("select * from sxt_relation where sxt_relation_polarsn=%d"), iPolarSn) ;
				CADORecordset cSetSection(&m_AdoDb) ;
				if (cSetSection.Open(strSql))
				{
					if (cSetSection.GetRecordCount()>0)
					{
						cSetSection.MoveFirst() ;
						while (!cSetSection.IsEOF())
						{
							int nId = 0 ;
							cSetSection.GetFieldValue(_T("id"), nId) ;
							int iTypeTo = -1 ;
							cSetSection.GetFieldValue(_T("sxt_relation_to_type"), iTypeTo) ;
							if (iTypeTo/100==2) //结束是绝缘节的紧邻下个轨道
							{
								long nHandleTo = 0 ;
								cSetSection.GetFieldValue(_T("sxt_relation_to_handle"), nHandleTo) ;
								strSql.Format(_T("update sxt_relation a, (select top 1 sxt_relation_polarsn from sxt_relation where sxt_relation_from_handle=%d) as b set a.sxt_relation_nextpolar=b.sxt_relation_polarsn where a.id=%d"), nHandleTo, nId) ;
								m_AdoDb.Execute(strSql) ;
							}
							cSetSection.MoveNext() ;
						}
					}
					cSetSection.Close() ;
				}
				cSet.MoveNext() ;
			}

			cSet.Close();
		}

		//计算极性
		//先给一个起始区段设定极性0
		int iPolarFirst = -1 ;
		strSql.Format(_T("select top 1 * from sxt_relation where sxt_relation_from_handle in(select sxt_ent_handle from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle not in(select distinct sxt_relation_to_handle from sxt_relation))")) ;
		if (cSet.Open(strSql))
		{
			if (cSet.GetRecordCount()>0)
			{
				cSet.MoveFirst() ;

				cSet.GetFieldValue(_T("sxt_relation_polarsn"), iPolarFirst) ;

				cSet.Edit() ;
				cSet.SetFieldValue(_T("sxt_relation_drawoption"), 0) ;
				cSet.Update() ;
			}
			cSet.Close() ;
		}
		//以iBelongGuiDaoFirst为起点往后顺序设置极性
		this->FillPolar(iPolarFirst, 0) ;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FillRelationDB"));
	}
}

// 查找由一个绝缘节起始的一条轨道包含的区段
void CZnSxt::FindOneGuiDao(long nHandleFrom, const int iIndexGuiDao, int iForword)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;

		if (iForword==0)
		{
			strSql.Format(_T("select *  from sxt_relation where sxt_relation_from_handle=%d and sxt_relation_done<>1"), nHandleFrom) ;
			if (cSet.Open(strSql))
			{
				if (cSet.GetRecordCount()>0)
				{
					cSet.MoveFirst() ;
					while (!cSet.IsEOF())
					{
						cSet.Edit() ;
						cSet.SetFieldValue(_T("sxt_relation_polarsn"), iIndexGuiDao) ;
						cSet.SetFieldValue(_T("sxt_relation_done"), 1) ;
						cSet.Update() ;

						int iTypeTo = -1 ;
						cSet.GetFieldValue(_T("sxt_relation_to_type"), iTypeTo) ;
						if (iTypeTo==0)//dc
						{
							long  nHandleTo = 0 ;
							cSet.GetFieldValue(_T("sxt_relation_to_handle"), nHandleTo) ;
							FindOneGuiDao(nHandleTo, iIndexGuiDao) ;
						}

						int iTypeFrom = -1 ;
						cSet.GetFieldValue(_T("sxt_relation_from_type"), iTypeFrom) ;
						if (iTypeFrom==0)
						{
							FindOneGuiDao(nHandleFrom, iIndexGuiDao,-1) ;
						}

						cSet.MoveNext() ;
					}
				}

				cSet.Close() ;
			}
		}
		else if (iForword==-1)
		{
			strSql.Format(_T("select *  from sxt_relation where sxt_relation_to_handle=%d and sxt_relation_done<>1"), nHandleFrom) ;
			if (cSet.Open(strSql))
			{
				if (cSet.GetRecordCount()>0)
				{
					cSet.MoveFirst() ;
					while (!cSet.IsEOF())
					{
						cSet.Edit() ;
						cSet.SetFieldValue(_T("sxt_relation_polarsn"), iIndexGuiDao) ;
						cSet.SetFieldValue(_T("sxt_relation_done"), 1) ;
						cSet.Update() ;

						int iTypeFrom = -1 ;
						cSet.GetFieldValue(_T("sxt_relation_from_type"), iTypeFrom) ;
						if (iTypeFrom==0)//dc
						{
							long  nHandleFrom = 0 ;
							cSet.GetFieldValue(_T("sxt_relation_from_handle"), nHandleFrom) ;
							FindOneGuiDao(nHandleFrom, iIndexGuiDao, -1) ;
						}
						cSet.MoveNext() ;
					}
				}
				cSet.Close() ;
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindOneGuiDao"));
	}
}

// 顺序设置极性，循环过程
void CZnSxt::FillPolar(int iPolarSn, int iDrawOption)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_relation where sxt_relation_polarsn=%d and sxt_relation_nextpolar<>-1"), iPolarSn) ;
		if (cSet.Open(strSql))
		{
			if (cSet.GetRecordCount()>0)
			{
				cSet.MoveFirst() ;
				while (!cSet.IsEOF())
				{
					int iPolarNext = -1 ;
					cSet.GetFieldValue(_T("sxt_relation_nextpolar"), iPolarNext) ;
					int iDrawOptionNext = (iDrawOption+1)%2 ;
					//查看iPolarNext的区段是否已设置了DrawOption，并且是否和要设置的值iDrawOptionNext冲突
					int iDrawOptionNextTmp = -1 ;
					strSql.Format(_T("select * from sxt_relation where sxt_relation_polarsn=%d"), iPolarNext) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_relation_drawoption"), iDrawOptionNextTmp) ;
					if (iDrawOptionNextTmp==-1)
					{
						strSql.Format(_T("update sxt_relation set sxt_relation_drawoption=%d where sxt_relation_polarsn=%d"), iDrawOptionNext, iPolarNext) ;
						m_AdoDb.Execute(strSql) ;
                        FillPolar(iPolarNext, iDrawOptionNext) ;					
					}
					else if (iDrawOptionNextTmp!=iDrawOptionNext)
					{
						CString strMsg ;
						strMsg.Format(_T("冲突 Cur belong: %d，drawop:%d， next belong: %d，drawop:%d"), iPolarSn, iDrawOption, iPolarNext, iDrawOptionNextTmp) ;
						AfxMessageBox(strMsg) ;
					}

					cSet.MoveNext() ;
				}
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FillPolar"));
	}
}

// 调整图纸
void CZnSxt::AdjustDwg(void)
{
	AcDbDatabase *pDb = acdbHostApplicationServices()->workingDatabase() ;	
	CUserSystem mysys ;
	mysys.m_pDb = pDb ;

	acedInitGet(RSG_NONULL, _T("All Sel")) ;
	TCHAR chInput[10]  ;
	int iRet = acedGetKword(_T("\n[全图(All)/选择(Sel)]<全图>:"), chInput) ;
	if (RTNORM==iRet)
	{		
		if (_tcscmp(chInput, _T("All"))==0)
		{
			AcDbBlockTable * pBlkTbl = NULL ;
			pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

			AcDbBlockTableRecord * pBlkTblRec = NULL ;
			pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
			pBlkTbl->close() ;
			AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
			pBlkTblRec->newIterator( pBlkTblRecIter );
			pBlkTblRec->close();

			AcDbObjectIdArray objArray ;
			AcDbEntity * pEnt = NULL ;
			for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
			{
				//遍历并打开实体 ;	
				if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
				{
					if (pEnt->isKindOf(AcDbBlockReference::desc()))
					{
						AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;
						CString strBlkName ;
						mysys.GetBlockName(pRef, strBlkName) ;
						int iBlkType = 0 ;
						if (strBlkName.Left(2)==_T("DC"))
						{
							iBlkType = 0 ;
						}
						else if (strBlkName.Left(3)==_T("XHJ"))
						{
							iBlkType = 1 ;
						}
						this->AdjustBlock(pRef, iBlkType) ;
					}

					pEnt->close() ;
				}	
			}
			delete pBlkTblRecIter ;
			pBlkTblRecIter = NULL ;
		}
		else if (_tcscmp(chInput, _T("Sel"))==0)
		{
			struct resbuf *pRb ;
			pRb = acutBuildList(RTDXF0,_T("INSERT"),0) ;	

			long iLen = 0 ;
			ads_name sum_name ;
			if (Acad::eNormal==acedSSGet(NULL, NULL, NULL, pRb, sum_name))
			{	
				acedSSLength(sum_name, &iLen) ;
				for (int i=0; i<iLen; i++)
				{
					ads_name en ;
					acedSSName(sum_name, i, en) ;
					AcDbEntity *pEnt = NULL ;
					AcDbObjectId ent_id ;
					acdbGetObjectId(ent_id, en) ;
					if(Acad::eOk == acdbOpenAcDbEntity(pEnt,ent_id, AcDb::kForWrite))
					{
						AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;
						CString strBlkName ;
						mysys.GetBlockName(pRef, strBlkName) ;
						int iBlkType = 0 ;
						if (strBlkName.Left(2)==_T("DC"))
						{
							iBlkType = 0 ;
						}
						else if (strBlkName.Left(3)==_T("XHJ"))
						{
							iBlkType = 1 ;
						}
						this->AdjustBlock(pRef, iBlkType) ;

						pEnt->close() ;
					}
				}
			}
		}	
	}
}

// 调整道岔、信号机块的属性，使其符合美观
void CZnSxt::AdjustBlock(AcDbBlockReference*& pRef, int iType)
{
	//将DC_00统一为X比例和旋转角变化（X、Y都置-1，等同于旋转180度，X置-1并且旋转180度等同于Y置-1，Y置-1并且旋转180度等同于X置-1）
	AcGeScale3d scale3d = pRef->scaleFactors()  ;	
	double dSX = scale3d.sx ;
	double dSY = scale3d.sy;

	if (dSY<0)
	{
		pRef->upgradeOpen() ;
		scale3d.set(-dSX, -dSY, scale3d.sz) ;
		pRef->setScaleFactors(scale3d) ;
		pRef->setRotation(pRef->rotation()-PI) ;
		pRef->downgradeOpen() ;
	}	

	double dAngleBlk = pRef->rotation() ;
	//得到块的属性
	AcDbObjectIterator * pObjIter ;
	pObjIter = pRef->attributeIterator() ;
	for(pObjIter->start(); !pObjIter->done(); pObjIter->step()) 
	{
		AcDbObjectId attId ;
		attId = pObjIter->objectId() ;
		AcDbAttribute * pAttrib ;
		if(Acad::eOk==pRef->openAttribute(pAttrib, attId, AcDb::kForWrite, Adesk::kFalse) )
		{
			bool b1 =  pAttrib->isMirroredInX() ;
			bool b2 =  pAttrib->isMirroredInY() ;
			if (iType==0)
			{
				if (dSX==-1)
				{
					if (dAngleBlk>(PI/2) && dAngleBlk<(PI*3/2))
					{
						pAttrib->mirrorInY(!b2) ;
						pAttrib->setVerticalMode(AcDb::kTextTop) ;
					}
					else
					{
						pAttrib->mirrorInX(!b1) ;
					}
				}
				else
				{
					if (dAngleBlk>(PI/2) && dAngleBlk<(PI*3/2))
					{
						pAttrib->setRotation(pAttrib->rotation()-PI) ;
						pAttrib->setVerticalMode(AcDb::kTextTop) ;
					}
				}
			}
			else
			{
				if (dAngleBlk>(PI/2) && dAngleBlk<(PI*3/2))
				{
					pAttrib->setRotation(pAttrib->rotation()-PI) ;
					pAttrib->setHorizontalMode(AcDb::kTextLeft) ;
					pAttrib->setVerticalMode(AcDb::kTextTop) ;
				}
			}
			pAttrib->close() ;	
		}						
	}
}

// 将平面图转换为由一段一段区段组成的平面图
void CZnSxt::ConvertPMT(void)
{
	AcDbDatabase *pDb = acdbHostApplicationServices()->workingDatabase() ;
	//AcDbDatabase *pDbNew = new AcDbDatabase ;    
	this->SetAcDbDB(pDb) ;
	//m_mysys.Wblock(pDb, pDbNew) ;
	m_mysys.DelAllXdata() ; //删除图上所有xdata

	//this->SetAcDbDB(pDbNew) ;
	this->ReadAllEntToDB() ;

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select distinct sxt_line_handle from sxt_line") ) ;
		if (cSet.Open(strSql))
		{
			if (cSet.GetRecordCount()>0)
			{
				cSet.MoveFirst() ;
				while (!cSet.IsEOF())
				{
					long nLineHandle = 0 ;
					cSet.GetFieldValue(_T("sxt_line_handle"), nLineHandle) ;

					AcGePoint2dArray pt2dArrayLine ; //每条多段线的（每个区段）顶点
					AcArray<double> dPlineWidths ; //每段多段线的宽
					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d order by sxt_line_vertex"), nLineHandle) ;
					CADORecordset cSetVertex(&m_AdoDb) ;
					if (cSetVertex.Open(strSql))
					{
						int iVertexNum = cSetVertex.GetRecordCount() ;
						if (iVertexNum>0)
						{
							cSetVertex.MoveFirst() ;
							double dStartWidth = 0, dEndWidth = 0 ; //该段线宽
							while (!cSetVertex.IsEOF())
							{
								int iVertextIndex = 0 ;
								cSetVertex.GetFieldValue(_T("sxt_line_vertex"), iVertextIndex) ;
								//取得该段线顶点线宽
								m_mysys.GetPlineWidthAt(nLineHandle, iVertextIndex, dStartWidth, dEndWidth) ;
								//顶点
								double dVertexX  , dVertexY ; 
								cSetVertex.GetFieldValue(_T("sxt_line_vertex_x"), dVertexX) ;
								cSetVertex.GetFieldValue(_T("sxt_line_vertex_y"), dVertexY) ;
								pt2dArrayLine.append(AcGePoint2d(dVertexX, dVertexY)) ;
								dPlineWidths.append(dStartWidth) ;
								
								if (iVertextIndex!=iVertexNum-1)
								{
									//该段线上的实体（绝缘节）
									strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_online_vertex=%d and sxt_ent_type/100=2 order by sxt_ent_x"), nLineHandle, iVertextIndex, nLineHandle) ;
									CADORecordset cSetJyjOnLine(&m_AdoDb) ;
									if (cSetJyjOnLine.Open(strSql))
									{
										if (cSetJyjOnLine.GetRecordCount()>0)
										{
											cSetJyjOnLine.MoveFirst() ;
											while (!cSetJyjOnLine.IsEOF())
											{
												cSetJyjOnLine.GetFieldValue(_T("sxt_ent_online_intersectx"), dVertexX) ;
												cSetJyjOnLine.GetFieldValue(_T("sxt_ent_online_intersecty"), dVertexY) ;
												pt2dArrayLine.append(AcGePoint2d(dVertexX, dVertexY)) ;
												dPlineWidths.append(dStartWidth) ;
												
												//遇到一个绝缘节，既是一个区段的终点，也是下一个区段的起点
												//作为终点，需要绘制这一阶段的线
												AcDbObjectId objIdClayer = m_pDb->clayer() ;
												m_mysys.Set_Layer(_T(""), _T("convert_pmt_guidao")) ;
												AcDbObjectId objIdPline = m_mysys.AddAcDbPolyLine(pt2dArrayLine, dPlineWidths) ;
												m_mysys.SetXdata(objIdPline,_T("ISGUIDAO"), 1) ;
												m_pDb->setClayer(objIdClayer) ;
												//作为起点，要初始化pt2dArrayLine，并将起点加入点集合(保留点集合最后一个点即可)，一种例外：这个绝缘节刚好在多段线顶点，这时不要保留此起点
												//begin 此处不会儿到EOF
												cSetVertex.MoveNext() ;
												double dTmpX = 0, dTmpY = 0 ;
												cSetVertex.GetFieldValue(_T("sxt_line_vertex_x"), dTmpX) ;
												cSetVertex.GetFieldValue(_T("sxt_line_vertex_y"), dTmpY) ;
												if (fabs(dTmpX-dVertexX)<0.01 &&fabs(dTmpY-dVertexY)<0.01) //clear
												{
													pt2dArrayLine.removeSubArray(0, pt2dArrayLine.length()-1) ;
													dPlineWidths.removeSubArray(0, dPlineWidths.length()-1) ;
												}
												else //left one
												{
													pt2dArrayLine.removeSubArray(0, pt2dArrayLine.length()-2) ;
													dPlineWidths.removeSubArray(0, dPlineWidths.length()-2) ;
												}
												cSetVertex.MovePrevious() ;
												//end
												
												cSetJyjOnLine.MoveNext() ;
											}
										}
										cSetJyjOnLine.Close() ;
									}
								}
								else 
								{
									AcDbObjectId objIdClayer = m_pDb->clayer() ;
									m_mysys.Set_Layer(_T(""), _T("convert_pmt_guidao")) ;
									AcDbObjectId objIdPline = m_mysys.AddAcDbPolyLine(pt2dArrayLine, dPlineWidths) ;
									m_mysys.SetXdata(objIdPline,_T("ISGUIDAO"), 1) ;
									m_pDb->setClayer(objIdClayer) ;
								}
								cSetVertex.MoveNext() ;
							}
						}
						cSetVertex.Close() ;
					}
					cSet.MoveNext() ;
				}

				cSet.MoveFirst() ;
				while (!cSet.IsEOF())
				{
					long nLineHandle = 0 ;
					cSet.GetFieldValue(_T("sxt_line_handle"), nLineHandle) ;
					AcDbEntity *pEnt = NULL ;
					if (m_mysys.OpenAcDbEntity(nLineHandle, pEnt))
					{
						pEnt->erase() ;
						pEnt->close() ;
					}

					cSet.MoveNext() ;
				}
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in ConvertPMT"));
	}

// 	AcApDocManager *pDocMgr = acDocManager ;
// 	AcApDocument *pDocCur = pDocMgr->curDocument() ;
// 	CString strFileNameCur = pDocCur->fileName() ;
// 	CString strFileNameNew ;
// 	strFileNameNew.Format(_T("%s(程序转换图).dwg"), strFileNameCur.Left(strFileNameCur.GetLength()-4)) ;
// 	pDbNew->saveAs(strFileNameNew) ;
// 	delete pDbNew ;
// 	pDbNew = NULL ;
// 	TCHAR * chFileNameNew = NULL ;
// 	chFileNameNew = (LPTSTR)(LPCTSTR)strFileNameNew ;
// 	pDocMgr->executeInApplicationContext(CUserSystem::OpenDocument,(void *)chFileNameNew) ;

}

void CZnSxt::SetAcDbDB(AcDbDatabase * pDb)
{
	m_pDb = pDb ;
	m_mysys.m_pDb = pDb ;
}

// 找出所有的轨道（根据绝缘节划分的，不是根据送受电的轨道电路，不带DG1之类的）
void CZnSxt::FindAllGuiDao(void)
{
	this->ReadAllEntToDB2() ;

	//先清理既有
	this->ClearShowInfo(_T("PMT_SHOWINFO_GUIDAONAME")) ; //删除显示信息
	m_mysys.WriteToRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_GUIDAONAME"), 0) ;//当前是显示，下次运行显示隐藏轨道就是要隐藏了。

	//删除扩展信息
	CString strAppNames[6] = {_T("GUIDAOID"), _T("IS1FNJ"), _T("ISMAINSEC"),  _T("LEFT_FORS"), _T("RIGHT_FORS"), _T("GUIDAONAME")} ;
	CStringArray strArrayAppName ;
	for(int i=0; i<6; i++)
	{
		strArrayAppName.Add(strAppNames[i]) ;
	}
	this->DeleteXdata(strArrayAppName) ;

	AcDbObjectId objIdClayer = m_pDb->clayer() ;
	m_mysys.Set_Layer(_T(""), _T("PMT_SHOWINFO_GUIDAONAME")) ;

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select distinct sxt_line_handle from sxt_line") ) ;
		if (cSet.Open(strSql))
		{
			if (cSet.GetRecordCount()>0)
			{	
				CLongArray nArrayLineDone ; //已经处理过的线
				while (!cSet.IsEOF())
				{
					long nLineHandle = 0 ;
					cSet.GetFieldValue(_T("sxt_line_handle"), nLineHandle) ;
					if (nLineHandle==386098)
					{
						int iii = 0 ;
					}
                    
					//acutPrintf(_T("\n%d"), nLineHandle) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nLineHandle) ;
					if (CBlkUtility::FindLongInArray(nArrayLineDone, nLineHandle)!=-1||m_RecordSet.GetRecordCount(strSql)>0)//已经处理过的线跳过//如果该线和道岔反位相连，亦跳过
					{
						cSet.MoveNext() ;
						continue;
					}

					CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
					this->GetGuiDaoInfo(nLineHandle, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
					nArrayLineDone.Append(nArrayLineDoneCur) ;

					int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
					int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
					int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
					long nHandleLineMain = 0 ; //写轨道电路名称的line
					CString strGuiDaoName ; //轨道电路名称（此处是主轨道，类似3DG1之类的都是附属在主轨道上的）
					if (iNumDC>0) //道岔区段
					{
						if (iNumDC==1) //example：3DG
						{
							CString strNameDC;		
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nArrayHandleDC.GetAt(0)) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strNameDC) ;
												
							strGuiDaoName.Format(_T("%sDG"), strNameDC) ;
							strSql.Format(_T("select sxt_ent_online_handle from sxt_ent where sxt_ent_handle=%d"), nArrayHandleDC.GetAt(0)) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleLineMain) ;							
						}
						else  //example:1-3DG
						{
							int iMinDC = 0, iMaxDC = 0 ;
							this->GetMaxMinDC(nArrayHandleDC, iMaxDC, iMinDC) ;
							strGuiDaoName.Format(_T("%d-%dDG"), iMinDC, iMaxDC) ;
							CString strLineDoneCur ;
							CBlkUtility::ConvertArrayToString(nArrayLineDoneCur, _T(","),  strLineDoneCur) ;
							strSql.Format(_T("select top 1 sxt_ent_online_handle from sxt_ent where sxt_ent_online_handle in (%s)"),  strLineDoneCur) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleLineMain) ;
						}
					}
					else //无岔区段
					{
						if (iNumXHJ==1) //一般是一个调车信号机和牵出线绝缘节组成的类似D8G或者股道分割4G1 4G2
						{
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nArrayHandleXHJ.GetAt(0)) ;
							CString strBlockName ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_block"), strBlockName) ;
							CString strXHJName ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strXHJName) ;
							CStringArray strArrayBlockName ;
							CBlkUtility::DivideString(strBlockName, _T("_"), strArrayBlockName) ;
							if (strArrayBlockName.GetCount()>1)
							{
								CString strXHJType ;
								strXHJType = strArrayBlockName.GetAt(1) ;
								if (strXHJType==_T("LF"))
								{
									int iGuDaoNum = 0 ;
									if (strXHJName.Left(1)==_T("S"))
									{
										iGuDaoNum = 1 ;										
									}
									else
									{
										iGuDaoNum =2 ;
									}
									strGuiDaoName.Format(_T("%dG%d"), strXHJName.Right(strXHJName.GetLength()-1), iGuDaoNum ) ;
								}
								else if (strXHJType==_T("DC"))
								{
									strGuiDaoName.Format(_T("%sG"), strXHJName) ;
								}
							}
						}
						else if (iNumXHJ==2)
						{
							CString strXHJTypes[2] = {_T(""), _T("")} ;
							CString strXHJNames[2] = {_T(""), _T("")} ;
							for (int i=0; i<2; i++)
							{
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nArrayHandleXHJ.GetAt(i)) ;
								CString strBlockName ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_block"), strBlockName) ;
								CStringArray strArrayBlockName ;
								CBlkUtility::DivideString(strBlockName, _T("_"), strArrayBlockName) ;
								strXHJTypes[i] = strArrayBlockName.GetAt(1) ;
								
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strXHJNames[i]) ;
							}
							if (strXHJTypes[0]==_T("LF") && strXHJTypes[1]==_T("LF"))	//若2侧都是发车信号机，则是股道
							{
								strGuiDaoName.Format(_T("%sG"), strXHJNames[0].Right(strXHJNames[0].GetLength()-1) ) ;
							}
							else if (strXHJTypes[0]==_T("YG")||strXHJTypes[1]==_T("YG")) //预告区段
							{
								strGuiDaoName.Format(_T("%sG"), strXHJTypes[0]==_T("YG")?strXHJNames[0]:strXHJNames[1] ) ;
							}
							else if ((strXHJTypes[0]==_T("LJ")&&strXHJTypes[1]==_T("DC")) || (strXHJTypes[1]==_T("LJ")&&strXHJTypes[0]==_T("DC")) )//IAG IIBG
							{
								CString strAOrBG = _T("B") ;
								if (strXHJNames[0].Left(1)==_T("X")||strXHJNames[1].Left(1)==_T("X"))
								{
									strAOrBG = _T("A") ;
								}
								//查找水平坐标上的出站信号机，得出股道编号
								strSql.Format(_T("select * from sxt_ent where abs(sxt_ent_y-(select sxt_ent_y from sxt_ent where sxt_ent_handle=%d))<1 and left(sxt_ent_block,6)='XHJ_LF'"), nArrayHandleXHJ.GetAt(0)) ;
								CString strCZXHJ ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strCZXHJ) ;
								if (!strCZXHJ.IsEmpty())
								{
									strGuiDaoName.Format(_T("%s%sG"), strCZXHJ.Right(strCZXHJ.GetLength()-1), strAOrBG) ;
								}								
							}
							else //31/33WG
							{
								CString strLeftDC = _T("XXX"),  strRightDC = _T("XXX") ;
								strSql.Format(_T("select sxt_ent_name from sxt_ent where sxt_ent_online_handle=(select top 1 sxt_ent_conline_left from sxt_ent where sxt_ent_conline_right=%d) or sxt_ent_fwline_handle=(select top 1 sxt_ent_conline_left from sxt_ent where sxt_ent_conline_right=%d)"), nArrayLineDoneCur.GetAt(0), nArrayLineDoneCur.GetAt(0)) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strLeftDC) ;
								strSql.Format(_T("select sxt_ent_name from sxt_ent where sxt_ent_online_handle=(select top 1 sxt_ent_conline_right from sxt_ent where sxt_ent_conline_left=%d) or sxt_ent_fwline_handle=(select top 1 sxt_ent_conline_right from sxt_ent where sxt_ent_conline_left=%d) "), nArrayLineDoneCur.GetAt(0), nArrayLineDoneCur.GetAt(0)) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strRightDC) ;
								int iLeftDC = _tstoi(strLeftDC) ;
								int iRightDc = _tstoi(strRightDC) ;
								strGuiDaoName.Format(_T("%d/%dWG"), min(iLeftDC, iRightDc), max(iLeftDC, iRightDc) ) ;
							}
						}

						nHandleLineMain = nArrayLineDoneCur.GetAt(0) ;
					}

					//绘制轨道名称
					if (nHandleLineMain!=0 && !strGuiDaoName.IsEmpty())
					{
						long nMaxGuiDaoId = this->GetMaxGuiDaoId() ;
						int iGuiDaoNameIndex = 0 ; //一送多受区段编号
						int iNumLineNotCross = iNumLine ;
						for (int i=0; i<iNumLine; i++)
						{	
							if (nArrayLineCurType.GetAt(i)==1)
							{
								iNumLineNotCross-- ;
							}
						}

						for (int i=0; i<iNumLine; i++)
						{	
							long nHandleLineTmp = nArrayLineDoneCur.GetAt(i) ;

							CString strGuiDaoNameTmp = strGuiDaoName ;
							CString strLeftForS = _T("N"), strRightForS = _T("N") ;
							int iIsMainSec = 0 ;
							int iIS1FNJ = iNumLineNotCross>1?1:0 ;						
							//是否是渡线
							if (nArrayLineCurType.GetAt(i)==1)
							{
								strGuiDaoNameTmp = _T("") ;
							}
							int iLineType = nArrayLineCurType.GetAt(i) ;

							AcDbEntity *pEnt = NULL ;
							if (m_mysys.OpenAcDbEntity(nHandleLineTmp, pEnt))
							{
								if (nHandleLineTmp==nHandleLineMain)
								{
									iIsMainSec = 1 ;
									strLeftForS = _T("F") ;
									strRightForS = _T("S") ;								
								}
								if (nHandleLineTmp!=nHandleLineMain)
								{
									iIsMainSec = 0 ;
									if (iLineType!=1)
									{
										strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineTmp) ;
										int iFwLineVertex = 0 ;
										m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_vertex"), iFwLineVertex) ;
										if (iFwLineVertex>0) //左侧受电
										{
											strLeftForS = _T("S") ;
										}
										else
										{
											strRightForS = _T("S") ;
										}
										iGuiDaoNameIndex++ ;
										strGuiDaoNameTmp.AppendFormat(_T("%d"),  iGuiDaoNameIndex) ;
									}
								}

								m_mysys.SetXdata(pEnt, _T("GUIDAOID"), nMaxGuiDaoId+1) ; //将本次区段标记为一个轨道电路（xdata：GUIDAOID）
								m_mysys.SetXdata(pEnt, _T("ISMAINSEC"), iIsMainSec) ; 
								m_mysys.SetXdata(pEnt, _T("IS1FNJ"), iIS1FNJ) ;
								m_mysys.SetXdata(pEnt, _T("RIGHT_FORS"), strRightForS) ;	
								m_mysys.SetXdata(pEnt, _T("LEFT_FORS"),strLeftForS) ;	
								m_mysys.SetXdata(pEnt, _T("GUIDAONAME"), strGuiDaoNameTmp) ;
								
								if (!strGuiDaoNameTmp.IsEmpty())
								{
									this->ShowGdName(pEnt) ;
								}

								pEnt->close() ;
							}
						}						
					}

					cSet.MoveNext() ;
				}
			}

			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindAllGuiDao"));
	}

	m_pDb->setClayer(objIdClayer) ;
}

// 将所有实体读入数据库（程序转换平面图中）
void CZnSxt::ReadAllEntToDB2(void)
{
	CString strMsg ;

	acutPrintf(_T("\n读取平面图，注意此函数针对一张dwg中一个车站情况,默认搜索距离信号楼长度为%.0f"), m_dMaxLenPmt) ;
	//找到距离信号楼距离框的图块 
	AcGePoint3d pt_3d_toxhlheader, pt_3d_toxhlheader2 ;//距信号楼距离图块基点
	if(this->GetToXhlHeaderPos(pt_3d_toxhlheader, pt_3d_toxhlheader2)!=1)
	{
		AfxMessageBox(_T("未发现距信号楼距离栏图块 PMT_TOXHL_HEADER，程序退出，请处理!")) ;
		return ;
	}

	double dY1 = pt_3d_toxhlheader.y ; //距离栏最上一条线
	double dY2 = pt_3d_toxhlheader.y - m_dRowHeightToXhl ;
	double dY3 = pt_3d_toxhlheader.y - m_dRowHeightToXhl*2 ;
	double dY4 = pt_3d_toxhlheader.y - m_dRowHeightToXhl*3 ;
	double dY5 = pt_3d_toxhlheader.y - m_dRowHeightToXhl*4 ;

	int nLen = 0 ;
	struct resbuf* pRb ;
	CLongArray nArrayHandle ;

	//在header下面的实体集合
	pRb = acutBuildList(-4,  _T("*,<,*"), 10,  asDblArray(pt_3d_toxhlheader),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	m_AdoDb.ClearTable(_T("sxt_ent")) ;
	m_AdoDb.ClearTable(_T("sxt_line")) ;

	CString strSql ;
	for(int i=0; i<nLen; i++)
	{
		UINT nHandle =nArrayHandle.GetAt(i) ;
		AcDbEntity * pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nArrayHandle.GetAt(i), pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;
				AcGePoint3d pt_3d_position = pRef->position() ;
				//将块统一为X比例和旋转角变化（X、Y都置-1，等同于旋转180度，X置-1并且旋转180度等同于Y置-1，Y置-1并且旋转180度等同于X置-1）
				AcGeScale3d scale_3d = pRef->scaleFactors()  ;		
				if (scale_3d.sy<0)
				{
					pRef->upgradeOpen() ;
					scale_3d.set(-scale_3d.sx, -scale_3d.sy, scale_3d.sz) ;
					pRef->setScaleFactors(scale_3d) ;
					pRef->setRotation(pRef->rotation()-PI) ;
					pRef->downgradeOpen() ;
				}	

				CString strName ;
				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;
				//acutPrintf(_T("坐标 %.3f-%.3f,块名：%s"), pt_3d_position.x, pt_3d_position.y, strBlkName) ;

				CStringArray strArrayBlkName ;
				CBlkUtility::DivideString(strBlkName, _T("_"), strArrayBlkName) ;
				CString strBlkType = _T("") ;
				if (strArrayBlkName.GetCount()>0)
				{
					strBlkType = strArrayBlkName.GetAt(0) ;
				}

				if (strBlkName==_T("PMT_JCB"))
				{
					m_mysys.GetAttValue(pRef, _T("LEN"), strName) ;

					strSql.Format(_T("insert into sxt_ent(sxt_ent_handle,  sxt_ent_block, sxt_ent_x, sxt_ent_y,  sxt_ent_name, sxt_ent_type,  sxt_ent_x1, sxt_ent_y1)  \
									 values(%d, '%s', %.10f, %.10f,  '%s', %d, %.10f, %.10f) "), nHandle, strBlkName,pt_3d_position.x, pt_3d_position.y, strName, 300, pt_3d_position.x, pt_3d_position.y) ;
					m_AdoDb.Execute(strSql) ;
				}
				else if (strBlkName.Left(8)==_T("PMT_XHL_")||strBlkName.Left(8)==_T("PMT_ZBS_"))
				{
					strSql.Format(_T("insert into sxt_ent(sxt_ent_handle,  sxt_ent_block, sxt_ent_x, sxt_ent_y,  sxt_ent_type,  sxt_ent_x1, sxt_ent_y1)  \
									 values(%d, '%s', %.10f, %.10f,  %d, %.10f, %.10f) "), nHandle, strBlkName,pt_3d_position.x, pt_3d_position.y, 310, pt_3d_position.x, pt_3d_position.y) ;
					m_AdoDb.Execute(strSql) ;
				}

				if (strBlkType==_T("DC"))
				{
					m_mysys.GetAttValue(pRef, _T("BIANHAO"), strName) ;
					//acutPrintf(_T("\n道岔编号%s"), strName) ;
					//和DC块定/反位连接的线信息
					CLongArray nArrayHandleIntersectLine, nArrayIndexOfVertex ;
					int iDwIntersectMoveToVertex = -1 ;
					AcGePoint3dArray pt3dArrayIntersect ;
					if(this->GetDcConLineDFW(pRef, nArrayHandleIntersectLine, nArrayIndexOfVertex, pt3dArrayIntersect, iDwIntersectMoveToVertex) )
					{
						strSql.Format(_T("insert into sxt_ent(sxt_ent_handle,  sxt_ent_block, sxt_ent_x, sxt_ent_y, sxt_ent_movetovertex, sxt_ent_name, sxt_ent_type,  sxt_ent_online_handle,  sxt_ent_online_vertex,  sxt_ent_online_intersectx,  sxt_ent_online_intersecty,  sxt_ent_fwline_handle,  sxt_ent_fwline_vertex,  sxt_ent_x1, sxt_ent_y1, sxt_ent_online_intersectx1,  sxt_ent_online_intersecty1)  \
										 values(%d, '%s', %.10f, %.10f, %d, '%s', %d, %d, %d, %.10f, %.10f, %d, %d, %.10f, %.10f, %.10f, %.10f) "), nHandle, strBlkName,pt_3d_position.x, pt_3d_position.y, iDwIntersectMoveToVertex, strName, 0, nArrayHandleIntersectLine.GetAt(0), nArrayIndexOfVertex.GetAt(0), pt3dArrayIntersect.at(0).x, pt3dArrayIntersect.at(0).y, nArrayHandleIntersectLine.GetAt(1), nArrayIndexOfVertex.GetAt(1), pt_3d_position.x, pt_3d_position.y, pt3dArrayIntersect.at(0).x, pt3dArrayIntersect.at(0).y) ;
						m_AdoDb.Execute(strSql) ;
					}					
				}
				else if (strBlkType==_T("XHJ")||strBlkType==_T("JYJ")) //信号机要么在某段线上，要么在2段线结合处
				{
					if (nHandle==21306)
					{
						int iiii = 0 ;
					}
					int iEntType = 100 ; //xhj
					if (strBlkType==_T("JYJ"))
					{
						iEntType = 200 ;
						if (strBlkName.Left(6)==_T("JYJ_JX"))
						{
							iEntType=250 ; //为实现极性切割增加的绝缘节
						}
					}

					int iDistToXhl = 0 ;
					CString strDistToXhl ;
					if(m_mysys.GetAttValue(pRef, _T("DIST"), strDistToXhl) )
					{
						strDistToXhl.TrimLeft(_T("(")) ;
						strDistToXhl.TrimRight(_T(")")) ;
						iDistToXhl = _ttoi(strDistToXhl) ;
					}

					m_mysys.GetAttValue(pRef, _T("XHJNAME"), strName) ;

					CLongArray nArrayHandleIntersect, nArrayIndexOfVertex ;
					AcGePoint3dArray pt3dArrayIntersect ;
					int iIntersectNum = GetXhjJyjConLine(pRef, nArrayHandleIntersect, nArrayIndexOfVertex, pt3dArrayIntersect) ;
					int iHandleOnLine = 0, iHandleLeft = 0, iHandleRight = 0, iVertexOnLine = 0, iVertexLeft = 0, iVertexRight = 0 ;
					if (iIntersectNum>0) //特别注意此类条件，不然后面的  pt3dArrayIntersect.at(0)极易崩溃（因为数值没有存储值）
					{
						if (iIntersectNum==2)
						{
							iHandleOnLine = nArrayHandleIntersect.GetAt(0) ;
							iVertexOnLine = nArrayIndexOfVertex.GetAt(0) ;
						}
						else if (iIntersectNum<10)
						{
							if (iIntersectNum==1)
							{
								iHandleLeft = nArrayHandleIntersect.GetAt(0) ;
								iVertexLeft = nArrayIndexOfVertex.GetAt(0) ;
							}
							else if (iIntersectNum==5)
							{
								iHandleRight = nArrayHandleIntersect.GetAt(0) ;
								iVertexRight = nArrayIndexOfVertex.GetAt(0) ;
							}
						}
						else
						{
							if (iIntersectNum/10==1||iIntersectNum%10==1)
							{
								iHandleLeft = nArrayHandleIntersect.GetAt((iIntersectNum/10==1)?1:0) ;
								iVertexLeft = nArrayIndexOfVertex.GetAt((iIntersectNum/10==1)?1:0) ;
							}
							if (iIntersectNum/10==5||iIntersectNum%10==5)
							{
								iHandleRight = nArrayHandleIntersect.GetAt((iIntersectNum/10==5)?1:0) ;
								iVertexRight = nArrayIndexOfVertex.GetAt((iIntersectNum/10==5)?1:0) ;
							}
						}

						strSql.Format(_T("insert into sxt_ent(sxt_ent_handle,  sxt_ent_block, sxt_ent_x, sxt_ent_y, sxt_ent_name, sxt_ent_type,  sxt_ent_online_handle,  sxt_ent_online_vertex,  sxt_ent_online_intersectx,  sxt_ent_online_intersecty,  sxt_ent_conline_left, sxt_ent_conline_left_vertex, sxt_ent_conline_right, sxt_ent_conline_right_vertex, sxt_ent_x1, sxt_ent_y1, sxt_ent_online_intersectx1,  sxt_ent_online_intersecty1, sxt_ent_toxhldist)  \
										 values(%d, '%s', %.10f, %.10f, '%s', %d, %d, %d, %.10f, %.10f, %d, %d, %d, %d, %.10f, %.10f, %.10f, %.10f, %d) "), nHandle, strBlkName, pt_3d_position.x, pt_3d_position.y, strName, iEntType, iHandleOnLine, iVertexOnLine, pt3dArrayIntersect.at(0).x, pt3dArrayIntersect.at(0).y,iHandleLeft, iVertexLeft, iHandleRight, iVertexRight, pt_3d_position.x, pt_3d_position.y, pt3dArrayIntersect.at(0).x, pt3dArrayIntersect.at(0).y, iDistToXhl) ;
						m_AdoDb.Execute(strSql) ;

					}
				}
			}
			pEnt->close() ;
		}	
	}
	//再遍历一遍，将轨道线读入
	for(int i=0; i<nLen; i++)
	{
		AcDbEntity * pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nArrayHandle.GetAt(i), pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				long nHandleLine =nArrayHandle.GetAt(i) ;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d or sxt_ent_fwline_handle=%d or sxt_ent_conline_left=%d or sxt_ent_conline_right=%d"), nHandleLine, nHandleLine, nHandleLine, nHandleLine ) ;
				int iRetSum = m_RecordSet.GetRecordCount(strSql) ;
				if (iRetSum>0)
				{
					AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;	
					int iNumVert = pPolyLine->numVerts() ;
					for (int i=0; i<iNumVert; i++)
					{
						AcGePoint3d pt_3d_vertex(0,0,0) ;
						pPolyLine->getPointAt(i, pt_3d_vertex) ;
						strSql.Format(_T("insert into sxt_line(sxt_line_handle, sxt_line_vertex,  sxt_line_vertex_x, sxt_line_vertex_y, sxt_line_vertex1,  sxt_line_vertex_x1, sxt_line_vertex_y1 )  \
										 values(%d, %d, %.10f, %.10f, %d, %.10f, %.10f) "), nHandleLine, i,  pt_3d_vertex.x, pt_3d_vertex.y, i,  pt_3d_vertex.x, pt_3d_vertex.y) ;
						m_AdoDb.Execute(strSql) ;
					}
				}
			}
			pEnt->close() ;
		}
	}

	//再遍历一遍，将各设备距离中心的距离读入数据库
	vector<vector<vector<CString> > > vecToXhl ;
	this->GetDistToXhl(pt_3d_toxhlheader, vecToXhl) ;
	for (int i=0; i<vecToXhl.size(); i++)
	{
		for (int j=0; j<vecToXhl[i].size(); j++)
		{
			strSql.Format(_T("update sxt_ent set sxt_ent_toxhldist=%d where sxt_ent_name='%s'"), _ttoi(vecToXhl[i][j][2]), vecToXhl[i][j][1]) ;
			m_AdoDb.Execute(strSql) ;
		}
	}

	//计算绝缘节距信号楼距离（要么和信号机并置，要么显式指定了其距信号楼距离）,更新信号机、道岔距信号楼距离（左侧为负数）
	this->UpdateToXhlDist() ;
	//设置实体在上行还是下行，决定ZZJ、盒子之类的朝向
	this->SetEntUpOrDown() ;
	//标出交叉渡线及绝缘节、端头线
	this->FindCrossLineAndDtLine() ;	    
}

// 循环查询轨道线连接的信号机及道岔，已作为计算轨道名称的依据
void CZnSxt::GetGuiDaoInfo(UINT nLineHandle, CLongArray& nArrayHandleXHJ, CLongArray& nArrayHandleDC, CLongArray& nArrayLineDoneCur, CLongArray& nArrayLineCurType)
{
	nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nLineHandle) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		nArrayLineCurType.Add(nLineType) ;

		CLongArray nArrayHandleXHJTmp, nArrayHandleDCTmp ;
		strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d or sxt_ent_conline_right=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 and left(sxt_ent_block,6)<>'XHJ_FS'"), nLineHandle, nLineHandle, nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleXHJTmp) ;
		nArrayHandleXHJ.Append(nArrayHandleXHJTmp) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type>-1 and sxt_ent_type<100"), nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDCTmp) ;
		nArrayHandleDC.Append(nArrayHandleDCTmp) ;

		for (int i=0; i<nArrayHandleDCTmp.GetCount(); i++)
		{
			UINT nHandleDc = nArrayHandleDCTmp.GetAt(i) ;
			strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
			long nHandleFwLine = 0 ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
			if (nHandleFwLine>0)
			{
				this->GetGuiDaoInfo(nHandleFwLine, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGuiDaoInfo"));
	}
}

// 取得轨道电路中最大最小的道岔号
void CZnSxt::GetMaxMinDC(const CLongArray& nArrayHandleDC,  int& iMaxDC, int& iMinDC)
{
	CString strDCHandles ;
	CBlkUtility::ConvertArrayToString(nArrayHandleDC, _T(","),  strDCHandles) ;
	CString strSql ;
	CStringArray strArrayDCName ;
	strSql.Format(_T("select sxt_ent_name from sxt_ent where sxt_ent_handle in (%s)"), strDCHandles) ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strArrayDCName) ;
	int iNumDC = strArrayDCName.GetCount() ;
	for (int i=0; i<iNumDC; i++)
	{
		int iDCNum = 0 ;
		iDCNum = _ttoi(strArrayDCName.GetAt(i)) ;
		if (i==0)
		{
			iMaxDC = iMinDC = iDCNum ;
		}
		else
		{
			if (iDCNum>iMaxDC)
			{
				iMaxDC = iDCNum ;
			}
			else if (iDCNum<iMinDC)
			{
				iMinDC = iDCNum ;
			}
		}
	}
}

long CZnSxt::GetMaxGuiDaoId(void)
{
	long nRet = 0 ;

	AcDbBlockTable * pBlkTbl = NULL ;
	this->m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;
		Acad::ErrorStatus es = pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead) ;

		if (Acad::eOk == es)
		{
			int nId = 0 ;
			if (m_mysys.GetXdata(pEnt, _T("GUIDAOID"), nId))
			{
				if (nId>nRet)
				{
					nRet = nId ;
				}
			}				

			pEnt->close() ;
		}
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return nRet ;
}

//显示平面图信息（比如轨道电路名称，送受电端）,iType=0,显示所有
void CZnSxt::ShowInfo(int iType)
{
	AcDbDatabase* pDb = acdbHostApplicationServices()->workingDatabase() ;
	CUserSystem mysys ;
	mysys.m_pDb = pDb ;
	BOOL bShowHide =  TRUE ; //对某个特性的隐藏FALSE或显示TRUE记录在扩展字典里面
	AcDbObjectId objIdLayerOld  ; 

	//显示/隐藏各区段的送受电设置
	if (iType==1)
	{
		objIdLayerOld = pDb->clayer() ;
		mysys.Set_Layer(_T(""), _T("PMT_SHOWINFO_FSD")) ;

		int iShowHideTmp = 0 ;
		if(mysys.ReadFromRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_FSD"), iShowHideTmp))
		{
			bShowHide = (BOOL)iShowHideTmp ;
		}
		mysys.WriteToRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_FSD"), (int)(!bShowHide)) ;

		this->ClearShowInfo(_T("PMT_SHOWINFO_FSD")) ;//先清理当前图纸中显示的相关信息（不管隐藏还是显示，这一步都要）

		if (bShowHide) 
		{
			AcDbBlockTable * pBlkTbl = NULL ;
			pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

			AcDbBlockTableRecord * pBlkTblRec = NULL ;
			pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
			pBlkTbl->close() ;
			AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
			pBlkTblRec->newIterator( pBlkTblRecIter );
			pBlkTblRec->close();

			AcDbEntity * pEnt = NULL ;
			for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
			{
				//遍历并打开实体 ;
				Acad::ErrorStatus es = pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead) ;
				if (Acad::eOk == es)
				{
					this->ShowGdFS(pEnt) ;
					pEnt->close() ;
				}
			}
			delete pBlkTblRecIter ;
			pBlkTblRecIter = NULL ;
		}
	}
	else 	if (iType==2) 	//显示/隐藏各多段线handle
	{
		objIdLayerOld = pDb->clayer() ;
		mysys.Set_Layer(_T(""), _T("PMT_SHOWINFO_LINEHANDLE")) ;

		int iShowHideTmp = 0 ;
		if(mysys.ReadFromRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_LINEHANDLE"), iShowHideTmp))
		{
			bShowHide = (BOOL)iShowHideTmp ;
		}
		mysys.WriteToRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_LINEHANDLE"), (int)(!bShowHide)) ;

		this->ClearShowInfo(_T("PMT_SHOWINFO_LINEHANDLE")) ;//先清理当前图纸中显示的相关信息（不管隐藏还是显示，这一步都要）
		
		if (bShowHide)
		{
			AcDbBlockTable * pBlkTbl = NULL ;
			pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

			AcDbBlockTableRecord * pBlkTblRec = NULL ;
			pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
			pBlkTbl->close() ;
			AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
			pBlkTblRec->newIterator( pBlkTblRecIter );
			pBlkTblRec->close();

			AcDbEntity * pEnt = NULL ;
			for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
			{
				//遍历并打开实体 ;
				Acad::ErrorStatus es = pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead) ;
				if (Acad::eOk == es)
				{
					if (pEnt->isKindOf(AcDbPolyline::desc()))
					{
						AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;
						AcGePoint3d pt_3d_left(0,0,0), pt_3d_right(0,0,0) ;
						pPolyLine->getStartPoint(pt_3d_left) ;

						CString strHandle ;
						long nHandle = m_mysys.GetHandle(pEnt) ;
						strHandle.Format(_T("%d"), nHandle) ;
						pt_3d_left.x+=1 ;
						pt_3d_left.y+=1 ;
						AcDbObjectId objIdGuiDaoName ;
						mysys.AddText(objIdGuiDaoName, strHandle, pt_3d_left, pt_3d_left, AcDb::kTextLeft, AcDb::kTextBase, 2.5, 0.8, 0, 1) ;
						AcDbEntity* pEntGuiDaoName = NULL ;
						if (mysys.OpenAcDbEntity(objIdGuiDaoName, pEntGuiDaoName))
						{
							mysys.SetXdata(pEntGuiDaoName, _T("PMT_SHOWINFO_LINEHANDLE"), 1) ;
							pEntGuiDaoName->close() ;
						}
					}

					pEnt->close() ;
				}
			}
			delete pBlkTblRecIter ;
			pBlkTblRecIter = NULL ;
		}
	}
	else 	if (iType==3) 	//显示/隐藏各轨道区段名称
	{
		objIdLayerOld = pDb->clayer() ;
		mysys.Set_Layer(_T(""), _T("PMT_SHOWINFO_GUIDAONAME")) ;

		int iShowHideTmp = 0 ;
		if(mysys.ReadFromRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_GUIDAONAME"), iShowHideTmp))
		{
			bShowHide = (BOOL)iShowHideTmp ;
		}
		mysys.WriteToRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_GUIDAONAME"), (int)(!bShowHide)) ;

		this->ClearShowInfo(_T("PMT_SHOWINFO_GUIDAONAME")) ;//先清理当前图纸中显示的相关信息（不管隐藏还是显示，这一步都要）

		if (bShowHide)
		{
			AcDbBlockTable * pBlkTbl = NULL ;
			pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

			AcDbBlockTableRecord * pBlkTblRec = NULL ;
			pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
			pBlkTbl->close() ;
			AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
			pBlkTblRec->newIterator( pBlkTblRecIter );
			pBlkTblRec->close();

			AcDbEntity * pEnt = NULL ;
			for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
			{
				//遍历并打开实体 ;
				Acad::ErrorStatus es = pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead) ;
				if (Acad::eOk == es)
				{
					this->ShowGdName(pEnt) ;
					pEnt->close() ;
				}
			}
			delete pBlkTblRecIter ;
			pBlkTblRecIter = NULL ;
		}
	}

	pDb->setClayer(objIdLayerOld) ;
}

// 增加直弯股切割绝缘节
int CZnSxt::AddCutJYJ(void)
{
	CLongArray nArrayHandleDc ;
	int iNum = this->GetAllDc(nArrayHandleDc) ;
	for (int i=0; i<iNum; i++)
	{
		long nHandle = nArrayHandleDc.GetAt(i) ;
		this->AddCutJYJ(nHandle) ;
	}
	return 0;
}

// 清除属于道岔（nHandleBelong）的切割绝缘节
int CZnSxt::DeleteCutJYJ(long nHandleBelong)
{
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;

				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;				
				if (strBlkName.Left(3)==_T("JYJ"))
				{
					long nHandleBelongTmp= 0, nHandleCloneFrom = 0 ;
					m_mysys.GetXdata(pEnt, _T("BELONGDC"), nHandleBelongTmp) ;		
					m_mysys.GetXdata(pEnt, _T("CloneFrom"), nHandleCloneFrom) ;
					if (nHandleBelongTmp==nHandleBelong&&nHandleCloneFrom==0)
					{
						pEnt->upgradeOpen() ;
						pEnt->erase() ;
					}
				}
			}

			pEnt->close() ;
		}	
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;
	return 0;
}

// 给指定道岔添加切割绝缘节
int CZnSxt::AddCutJYJ(long nHandleDC)
{
	//先清除该DC的关联切割绝缘节
	this->DeleteCutJYJ(nHandleDC) ;

// 	if (nHandleDC==137092)
// 	{
// 		int iii = 0 ;
// 	}

	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandleDC, pEnt, AcDb::kForRead ))
	{
		AcDbBlockReference* pRef = AcDbBlockReference ::cast(pEnt) ;

		CLongArray nArrayHandleIntersectLine, nArrayIndexOfVertex ;
		int iDwIntersectMoveToVertex = -1 ;
		AcGePoint3dArray pt3dArrayIntersect ;
		if(this->GetDcConLineDFW(pRef, nArrayHandleIntersectLine, nArrayIndexOfVertex, pt3dArrayIntersect, iDwIntersectMoveToVertex) )
		{
			int iCutJYJ = 0 ; //默认弯股切割
			m_mysys.GetXdata(pEnt, _T("CUTJYJPOS"), iCutJYJ) ;
			AcGePoint3d pt_3d_cutjyj(0,0,0) ; //切割绝缘节的基点
			double dAngle = 0 ;

			if ((iCutJYJ==0&&iDwIntersectMoveToVertex==-1)||iCutJYJ==1&&iDwIntersectMoveToVertex!=-1) //弯股切割时
			{							
				long nHandleFwLine = nArrayHandleIntersectLine.GetAt(1) ;
				int iFwLineVertex = nArrayIndexOfVertex.GetAt(1) ;
				AcDbEntity* pEntFwLine = NULL ;
				if(m_mysys.OpenAcDbEntity(nHandleFwLine, pEntFwLine, AcDb::kForRead))
				{
					AcDbPolyline* pPolyLineFw = AcDbPolyline::cast(pEntFwLine) ;
					AcGePoint3d pt_3d_start(0,0,0), pt_3d_end(0,0,0) ;
					pPolyLineFw->getPointAt(iFwLineVertex, pt_3d_start) ;
					pPolyLineFw->getPointAt(iFwLineVertex==0?(iFwLineVertex+1):(iFwLineVertex-1), pt_3d_end) ;

					AcDbLine *pLineTmp = new AcDbLine(pt_3d_start, pt_3d_end) ;
					pLineTmp->getPointAtDist(1.5, pt_3d_cutjyj) ;
					AcGeVector2d vecTmp(pt_3d_end.x-pt_3d_start.x, pt_3d_end.y-pt_3d_start.y) ;
					dAngle = vecTmp.angle() ;				
					delete pLineTmp ;
					pLineTmp = NULL ;

					pEntFwLine->close() ;
				}
			}
			else //直股切割或者弯股切割但是定位在弯股时
			{
				long nHandleDwLine = nArrayHandleIntersectLine.GetAt(0) ;
				int iDwLineVertex = nArrayIndexOfVertex.GetAt(0) ;
				AcDbEntity* pEntDwLine = NULL ;
				if(m_mysys.OpenAcDbEntity(nHandleDwLine, pEntDwLine, AcDb::kForRead))
				{
					AcDbPolyline* pPolyLineDw = AcDbPolyline::cast(pEntDwLine) ;
					AcGePoint3d pt_3d_start(0,0,0), pt_3d_end(0,0,0) ;
					pt_3d_start = pt3dArrayIntersect.at(0) ;
					if (nArrayIndexOfVertex.GetAt(1)==0)
					{
						pPolyLineDw->getPointAt(nArrayIndexOfVertex.GetAt(0)+1, pt_3d_end) ;
					}
					else
					{
						pPolyLineDw->getPointAt(nArrayIndexOfVertex.GetAt(0), pt_3d_end) ;
					}

					AcDbLine *pLineTmp = new AcDbLine(pt_3d_start, pt_3d_end) ;
					pLineTmp->getPointAtDist(iDwIntersectMoveToVertex==1?4:3, pt_3d_cutjyj) ;
					AcGeVector2d vecTmp(pt_3d_end.x-pt_3d_start.x, pt_3d_end.y-pt_3d_start.y) ;
					dAngle = vecTmp.angle() ;		
					delete pLineTmp ;
					pLineTmp = NULL ;

					pEntDwLine->close() ;
				}
			}

			AcDbBlockReference* pRefTmp = NULL ;
			if (m_mysys.InsertBlock(pRefTmp, _T("JYJ_JX_0"), pt_3d_cutjyj))
			{
				pRefTmp->setRotation(dAngle) ;
				m_mysys.SetXdata(pRefTmp, _T("BELONGDC"), nHandleDC) ;
				pRefTmp->close() ;
				pRefTmp = NULL ;									
			}	
		}
		pEnt->close() ;
	}

	return 0;
}

// 在sxt_line表中增加切割绝缘节对应的节点 db
int CZnSxt::AddVertexOfCutJYJ(void)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type=250 order by sxt_ent_x")) ;

		if (cSet.Open(strSql))
		{
			while (!cSet.IsEOF())
			{
				int iEntType = -1 ;
				cSet.GetFieldValue(_T("sxt_ent_type"), iEntType) ;
				long nHandleEnt = 0, nHandleLine = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandleEnt) ;
				cSet.GetFieldValue(_T("sxt_ent_online_handle"), nHandleLine) ;

				double dIntersectX = 0.000, dIntersectY = 0.000, dIntersectX1 = 0.000, dIntersectY1 = 0.000 ;
				cSet.GetFieldValue(_T("sxt_ent_online_intersectx"), dIntersectX) ;
				cSet.GetFieldValue(_T("sxt_ent_online_intersecty"), dIntersectY) ;
				cSet.GetFieldValue(_T("sxt_ent_online_intersectx1"), dIntersectX1) ;
				cSet.GetFieldValue(_T("sxt_ent_online_intersecty1"), dIntersectY1) ;
				//在dIntersectX处是否已有顶点
				strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and abs(sxt_line_vertex_x1-%.10f)<0.001"), nHandleLine, dIntersectX1) ;
				int iVertexSame = -1 ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex"), iVertexSame) ;	
				if (iVertexSame!=-1)
				{
					strSql.Format(_T("update sxt_line set sxt_line_vertex_type=11, sxt_line_vertex_handle=%d where sxt_line_handle=%d and sxt_line_vertex=%d"), nHandleEnt, nHandleLine, iVertexSame) ;
					m_AdoDb.Execute(strSql) ;
				}
				else
				{
					strSql.Format(_T("update sxt_line set sxt_line_vertex1=sxt_line_vertex1+1 where sxt_line_vertex_x1>%.10f and sxt_line_handle=%d"), dIntersectX1, nHandleLine) ;
					m_AdoDb.Execute(strSql) ;
					strSql.Format(_T("select top 1 * from sxt_line where sxt_line_vertex_x1<%.10f and sxt_line_handle=%d order by sxt_line_vertex_x1 desc"), dIntersectX1, nHandleLine) ;
					int iVertexTmp = 0 ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex1"), iVertexTmp) ;					
					strSql.Format(_T("insert into sxt_line(sxt_line_handle, sxt_line_vertex_type, sxt_line_vertex1, sxt_line_vertex_x, sxt_line_vertex_y, sxt_line_vertex_x1, sxt_line_vertex_y1, sxt_line_vertex_handle) values(%d, %d, %d, %.10f, %.10f,  %.10f, %.10f, %d)"), nHandleLine, iEntType==0?2:1, iVertexTmp+1, dIntersectX, dIntersectY, dIntersectX1, dIntersectY1, nHandleEnt) ;
					m_AdoDb.Execute(strSql) ;
				}			

				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in AddVertexOfCutJYJ"));
	}

	return 0;
}
//static int iii = 0 ;
// 从一条特定的线开始，递归推出后续连接的所有极性（一条多段线上可能因为切割绝缘节有多个极性）,bForward=true：向右推进，反之向左, iStartVertex，从哪个顶点开始推导，iTestMode=0，仅提示极性冲突段，1，显示极性线条，2，显示动画
void CZnSxt::FillPolar2(long nHandleLine, int iPolar, int iStartVertex, bool bForward, int iTestMode)
{
	if (m_bFillPolarErro==true)
	{
		return ;
	}
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;

		//begin 端头线，不设置极性
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLine) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		if (nLineType==2) 
		{
			return ;
		}
		//end 端头线，不设置极性

		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLine) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLine) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;        
		int nHandleEndConJyj = (bForward?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle

		//检测是否已设置过极性
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex1=%d "), nHandleLine, bForward?iStartVertex:iStartVertex-1) ;
// 		if (bForward==false) //反向时为了保证设置点的极性和正向一致，每次错一位（比如一个线段2个顶点0,1，始终只以0点的极性作为该线段的极性）
// 		{
// 			strSql.Format(_T("select top 1 * from (select top 2 * from sxt_line where sxt_line_handle=%d order by sxt_line_vertex1 desc) order by sxt_line_vertex1 asc"), nHandleLine) ;
// 		}
		int iPolarToCheck = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_polar"), iPolarToCheck) ;

		if (iTestMode==2)
		{
			//m_mysys.SetEntColorIndex(nHandleLine, 1) ;
			m_mysys.FlashEnt(nHandleLine, 500, 50) ;
 			//m_mysys.SetEntColorIndex(nHandleLine, 3) ;
		}

		if (iPolarToCheck==0)
		{
			//遍历所有vertex，遇到切割绝缘节就变极性（sxt_line_vertex_type=1）
			strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex1%s%d order by sxt_line_vertex1 %s"), nHandleLine, bForward?_T(">="):_T("<="), iStartVertex, bForward?_T("asc"):_T("desc")) ;
			if (cSet.Open(strSql))
			{
				int iNumVertex = cSet.GetRecordCount() ;
				int iPolarTmp = iPolar ;
				int iIndexVertex = 0 ;
				while (!cSet.IsEOF())
				{
					int iVertex1 = 0 ;
					cSet.GetFieldValue(_T("sxt_line_vertex1"), iVertex1) ;
					//遇到切割绝缘节，极性要变
					int iVertexType = 0 ;
					cSet.GetFieldValue(_T("sxt_line_vertex_type"), iVertexType) ;
					if ((iIndexVertex>0&&iVertexType==1)|| (iIndexVertex==(iNumVertex-1)&&nHandleEndConJyj>0))
					{
						iPolarTmp = -iPolarTmp ;
					}
					//正向时，最后一个点不设置极性，反向时，第一个不设置极性，所有线段极性取其起点极性
					if (bForward)
					{
						if (iIndexVertex<(iNumVertex-1))
						{
							strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex1=%d"), nHandleLine, iVertex1) ;
							m_RecordSet.SetRecordValue(strSql, _T("sxt_line_polar"),  iPolarTmp) ;

							if (iTestMode>0)
							{
								AcDbObjectId objIdLayer = m_mysys.m_pDb->clayer() ;
								m_mysys.Set_Layer(_T(""), _T("CRSCD_SJY_XTS_PMT_TESTJX")) ;
								double dX1 = 0, dY1 = 0, dX2 = 0, dY2 = 0 ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x"), dX1) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y"), dY1) ;
								strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex1=%d"), nHandleLine, iVertex1+1) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x"), dX2) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y"), dY2) ;
								m_mysys.AddAcDbPolyLine(AcGePoint3d(dX1, dY1, 0), AcGePoint3d(dX2, dY2, 0), 0.8, 0, iPolarTmp==1?3:1) ;
								m_mysys.m_pDb->setClayer(objIdLayer) ;
							}
						}
					}
					else
					{
						if (iVertex1>0)
						{
							strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex1=%d"), nHandleLine, iVertex1-1) ;
							m_RecordSet.SetRecordValue(strSql, _T("sxt_line_polar"),  iPolarTmp) ;

							if (iTestMode>0)
							{
								AcDbObjectId objIdLayer = m_mysys.m_pDb->clayer() ;
								m_mysys.Set_Layer(_T(""), _T("CRSCD_SJY_XTS_PMT_TESTJX")) ;
								double dX1 = 0, dY1 = 0, dX2 = 0, dY2 = 0 ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x"), dX1) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y"), dY1) ;
								strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d and sxt_line_vertex1=%d"), nHandleLine, iVertex1) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x"), dX2) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y"), dY2) ;
								m_mysys.AddAcDbPolyLine(AcGePoint3d(dX1, dY1, 0), AcGePoint3d(dX2, dY2, 0), 0.8, 0, iPolarTmp==1?3:1) ;
								m_mysys.m_pDb->setClayer(objIdLayer) ;
							}
						}
					}

					if (iIndexVertex<(iNumVertex-1))
					{
						//begin 查询此段线上有否道岔
						double dVertexX1 = 0, dVertexX2 = 0, dVertexY1 = 0, dVertexY2 = 0 ;
						cSet.GetFieldValue(_T("sxt_line_vertex_x1"), dVertexX1) ;
						cSet.GetFieldValue(_T("sxt_line_vertex_y1"), dVertexY1) ;
						cSet.MoveNext() ;

						cSet.GetFieldValue(_T("sxt_line_vertex_x1"), dVertexX2) ;
						cSet.GetFieldValue(_T("sxt_line_vertex_y1"), dVertexY2) ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type=0 and sxt_ent_online_handle=%d and sxt_ent_x1>%.3f and sxt_ent_x1<%.3f and sxt_ent_y1>%.3f and sxt_ent_y1<%.3f order by sxt_ent_x1 %s"), nHandleLine, min(dVertexX1,dVertexX2), max(dVertexX1,dVertexX2), min(dVertexY1,dVertexY2)-1.5, max(dVertexY1,dVertexY2)+1.5,  bForward?_T("asc"):_T("desc")) ;
						CLongArray nArrayHandleFwLine  ;
						CLongArray iArrayVertexFwLine ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nArrayHandleFwLine) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_vertex"), iArrayVertexFwLine) ;	
						int iNumFwLine = nArrayHandleFwLine.GetCount() ;
						for (int i=0; i<iNumFwLine; i++)
						{
							int iPolarTmp2 = iPolarTmp ;
							int nHandleFwLine = nArrayHandleFwLine.GetAt(i) ;
							if (nHandleFwLine!=0&&nHandleFwLine!=nHandleLine)
							{
								int iVertexFwLine = iArrayVertexFwLine.GetAt(i) ;
// 								if (iVertexFwLine==0) //只处理顺序向右的
// 								{
									strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleFwLine) ;
									int iNumVertexFwLine = m_RecordSet.GetRecordCount(strSql) ;
									this->FillPolar2(nHandleFwLine, iPolarTmp2, iVertexFwLine==0?0:(iNumVertexFwLine-1), iVertexFwLine==0?true:false, iTestMode) ;
// 								}
							}
						}

						cSet.MovePrevious() ;	
						//end 查询此段线上有否道岔
					}

					//最后一个顶点
					if (iIndexVertex==(iNumVertex-1))
					{
						long nHandleNextLine = 0 ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
						CString strFieldName = (bForward?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine) ;
						if (nHandleNextLine>0)
						{
							strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleNextLine) ;
							int iNumVertexNextLine = m_RecordSet.GetRecordCount(strSql) ;
							this->FillPolar2(nHandleNextLine, iPolarTmp,  bForward?0:(iNumVertexNextLine-1), bForward, iTestMode) ;
						}
						else  //线搜寻前进方向的末端连接的是道岔fw
						{
							long nHandleConDc = 0 ;
							int iVertexToDc = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type=0 and sxt_ent_fwline_handle=%d"), nHandleLine) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleConDc) ;       
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_vertex"), iVertexToDc) ;  
							double dDcX = 0 ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x1"), dDcX) ; 
							if (nHandleConDc>0&&((bForward&&iVertexToDc>0)||(!bForward&&iVertexToDc==0)))
							{
								long nHandleOnLine = 0 ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleOnLine) ; 
								strSql.Format(_T("select top 1 * from sxt_line where sxt_line_handle=%d and sxt_line_vertex_x1%s%.3f order by sxt_line_vertex_x1 %s"), nHandleOnLine, bForward?_T("<"):_T(">"), dDcX, bForward?_T("desc"):_T("asc")) ;
								int iStartVertexTmp = 0 ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex1"), iStartVertexTmp) ;
								//该顶点是纯顶点还是切割顶点，切割顶点是后加在数据库中的，实际线上无此顶点，在数据库中sxt_line_vertex=-1,纯顶点不变换极性
								int iStartVertexOrinal = 0 ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex"), iStartVertexOrinal) ;
								if (nHandleOnLine>0)
								{
									this->FillPolar2(nHandleOnLine, iPolarTmp, iStartVertexTmp, bForward, iTestMode) ;
									//另外方向
									if (bForward)
									{
										if (iStartVertexTmp==0)//反向下一个区段（nHandleOnline左边相邻的区段）
										{
											strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_right=%d"), nHandleOnLine) ;
											long nHandleLeftLine = 0 ;
											m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"), nHandleLeftLine) ;
											if (nHandleLeftLine>0)
											{
												strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLeftLine) ;
												int iNumVertexOfLeftLine = m_RecordSet.GetRecordCount(strSql) ;
												this->FillPolar2(nHandleLeftLine, -iPolarTmp, iNumVertexOfLeftLine-1, !bForward, iTestMode) ;
											}
										}
										else //还是本轨道多段线（nHandleOnLine）//这里要注意，虽然还是本多段线，但是这个顶点可能是切割点也可能是纯顶点，纯顶点不要变极性
										{											
											this->FillPolar2(nHandleOnLine, (iStartVertexOrinal==-1?-iPolarTmp:iPolarTmp), iStartVertexTmp, !bForward, iTestMode) ;
										}
									}
									else
									{
										strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleOnLine) ;
										int iNumOfVertexOnLine =m_RecordSet.GetRecordCount(strSql) ;
										if (iStartVertexTmp==(iNumOfVertexOnLine-1))//正向下一个区段（nHandleOnline右边相邻的区段）
										{
											strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_left=%d"), nHandleOnLine) ;
											long nHandleRightLine = 0 ;
											m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"), nHandleRightLine) ;
											if (nHandleRightLine>0)
											{										
												this->FillPolar2(nHandleRightLine, -iPolarTmp, 0, !bForward, iTestMode) ;
											}
										}
										else //还是本轨道多段线（nHandleOnLine）
										{
											this->FillPolar2(nHandleOnLine, (iStartVertexOrinal==-1?-iPolarTmp:iPolarTmp), iStartVertexTmp, !bForward, iTestMode) ;
										}
									}
								}
							}
						}
					}

					iIndexVertex++ ;

					cSet.MoveNext() ;
				}
				cSet.Close() ;
			}
		}
		else
		{
			if (iPolarToCheck!=iPolar)
			{
				double dX = 0, dY = 0 ;
				strSql.Format(_T("select top 1 * from sxt_line where sxt_line_handle=%d order by sxt_line_vertex1 %s"), nHandleLine, bForward?_T("asc"):_T("desc")) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_x"), dX) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_line_vertex_y"), dY) ;

// 				AcGePoint3d pt_3d_cen ; //(340.47,-5.53, 0)
// 				double dHeight = 0 ;
// 				double dWidth  = 0 ;
				//if (bTestMode)
				{
// 					AcGePoint2d pt_2d_cen = m_mysys.GetViewCenterPoint() ;					
// 					m_mysys.ConvertPoint(pt_2d_cen, pt_3d_cen) ;
// 					dHeight =m_mysys.GetViewHeight() ;
// 					dWidth = m_mysys.GetViewWidth() ;
					m_mysys.ZoomView(AcGePoint3d(dX, dY,0), 200,200) ;
					m_mysys.SetEntColorIndex(nHandleLine, 2) ;
					m_mysys.FlashEnt(nHandleLine, 1000) ;
				}
				CString strMsg ;
				strMsg.Format(_T("进行到handle=%d的线(其坐标为%.3f, %.3f)时极性冲突"), nHandleLine, dX, dY) ;
				acutPrintf(_T("\n%s"), strMsg) ;
				AfxMessageBox(strMsg) ;
				//if (bTestMode)
// 				{
// 					m_mysys.ZoomView(pt_3d_cen, dHeight, dWidth ) ;
// 				}	

				m_bFillPolarErro = true ;
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FillPolar2"));
	}	
}

// 取得上下行分界的y坐标，以上为下行，以下为上行
int CZnSxt::GetBorder(double &dBorderY, double &dBorderX)
{
	int iRet = 0 ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type=100 and sxt_ent_name='X'")) ;
		if (m_RecordSet.GetRecordCount(strSql)==1)
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_y"), dBorderY) ;
			strSql.Format(_T("select * from sxt_ent where sxt_ent_type=100 and sxt_ent_name='S'")) ;
			if (m_RecordSet.GetRecordCount(strSql)==1)
			{
				double dBorderYTmp = 0 ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_y"), dBorderYTmp) ;
				if (fabs(dBorderYTmp-dBorderY)<2) //此处2可议
				{
					//从S出站分界，以左为下行，以右为上行
					strSql.Format(_T("select * from sxt_ent where sxt_ent_type=100 and left(sxt_ent_block,6)='XHJ_CZ' and left(sxt_ent_name,1)='S' and abs(sxt_ent_y-%.3f)<2 ")) ;
					if (m_RecordSet.GetRecordCount(strSql)==1)
					{
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"), dBorderX) ;
						iRet = 2 ;
					}
				}
				else
				{
					iRet = 1 ;
				}
			}
			else
			{
				iRet = 1 ;
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetBorder"));
	}

	return iRet ;
}

// 计算实体是上行还是下行 db
void CZnSxt::SetEntUpOrDown(void)
{
	double dBorderY = 0.000, dBorderX = 0.000 ;
	int iBorderType = this->GetBorder(dBorderY, dBorderX) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent")) ;
		if (cSet.Open(strSql))
		{
			if (cSet.IsBOF())
			{
				cSet.MoveFirst() ;
			}
			while (!cSet.IsEOF())
			{
				int iUpOrDown = 0 ;
				double dX = 0.000, dY = 0.000 ;
				cSet.GetFieldValue(_T("sxt_ent_x"), dX) ;
				cSet.GetFieldValue(_T("sxt_ent_y"), dY) ;
				if ((dY-dBorderY)>2)
				{
					iUpOrDown = 0 ;
				}
				else if ((dY-dBorderY)<-2)
				{
                    iUpOrDown = 1 ;
				}
				else
				{
					if (iBorderType==1)
					{
						iUpOrDown = 0 ;
					}
					else if (iBorderType==2)
					{
						if (dX>dBorderX)
						{
							iUpOrDown = 1 ;
						}
						else
						{
							iUpOrDown = 0 ;
						}
					}
				}
				cSet.Edit() ;
				cSet.SetFieldValue(_T("sxt_ent_upordown"), iUpOrDown) ;
				cSet.Update() ;

				cSet.MoveNext() ;
			}

			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in SetEntUpOrDown"));
	}
}

// 找出交叉渡线并更新数据库，算法是：一个绝缘节2端连接线都连接一个道岔反位就是渡线绝缘节
//找出端头线并更新数据库，算法是：一条线两端都是端头绝缘节或一头是端头，另一头无连接实体
void CZnSxt::FindCrossLineAndDtLine(void)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;

		//交叉渡线
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=2 and (sxt_ent_type mod 100)\\10<>5")) ;
		if (cSet.Open(strSql))
		{
			while (!cSet.IsEOF())
			{
				long nHandleLeftLine = 0, nHandleRightLine = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_conline_left"), nHandleLeftLine) ;
				cSet.GetFieldValue(_T("sxt_ent_conline_right"), nHandleRightLine) ;
				if (nHandleLeftLine!=0&&nHandleRightLine!=0)
				{
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d and sxt_ent_fwline_vertex=0"), nHandleLeftLine) ;
					int iFindDcLeft = m_RecordSet.GetRecordCount(strSql) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d and sxt_ent_fwline_vertex>0"), nHandleRightLine) ;
					int iFindDcRight = m_RecordSet.GetRecordCount(strSql) ;
                    
					if (iFindDcLeft>0 && iFindDcRight>0)
					{
						cSet.Edit() ;
						cSet.SetFieldValue(_T("sxt_ent_type"), 201) ;
						cSet.Update() ;
						//update线类型为渡线
						strSql.Format(_T("update sxt_line set sxt_line_type=1 where sxt_line_handle=%d"), nHandleLeftLine) ;
						m_AdoDb.Execute(strSql) ;
						strSql.Format(_T("update sxt_line set sxt_line_type=1 where sxt_line_handle=%d"), nHandleRightLine) ;
						m_AdoDb.Execute(strSql) ;
					}
				}

				cSet.MoveNext() ;
			}

			cSet.Close() ;
		}

		//端头线
		strSql.Format(_T("select * from sxt_ent where sxt_ent_block='JYJ_DT_0' ")) ;
		if (cSet.Open(strSql))
		{
			while (!cSet.IsEOF())
			{
// 				long nHandle = 0 ;
// 				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;
// 				if (nHandle == 265194)
// 				{
// 					int iii = 0 ;
// 				}
				long nHandleConLines[2] ={ 0, 0} ; 
				cSet.GetFieldValue(_T("sxt_ent_conline_left"), nHandleConLines[0]) ;
				cSet.GetFieldValue(_T("sxt_ent_conline_right"), nHandleConLines[1]) ;
				for (int i=0; i<2; i++)
				{
					BOOL bIsDtLine = FALSE ;
					if (nHandleConLines[i]!=0)
					{
						strSql.Format(_T("select * from sxt_ent where  sxt_ent_conline_%s=%d"), i==0?_T("right"):_T("left"), nHandleConLines[i]) ;
						if (m_RecordSet.GetRecordCount(strSql)>0)  //有连接实体，但实体也是端头
						{
							CStringArray strArrayBlkName ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_block"), strArrayBlkName) ; //一般有2个结果，还有个信号机并置
							if (CBlkUtility::FindStrInArray(strArrayBlkName, _T("JYJ_DT_0"))!=-1)
							{
								bIsDtLine = TRUE ;
							}
						}
						else 	//该线另一侧无连接实体
						{
							strSql.Format(_T("select * from sxt_ent where  sxt_ent_fwline_handle=%d"), nHandleConLines[i]) ;
							if (m_RecordSet.GetRecordCount(strSql)==0)
							{
								bIsDtLine = TRUE ;
							}							
						}
						if (bIsDtLine)
						{
							strSql.Format(_T("update sxt_line set sxt_line_type=2 where sxt_line_handle=%d"), nHandleConLines[i]) ;
							//m_mysys.SetEntColorIndex(nHandleConLines[i], 1) ;
							m_AdoDb.Execute(strSql) ;
						}
					}
				}
				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}      

	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindCrossLine"));
	}
}

// 绝缘节距信号楼距离（和信号机并置的取信号机的值，其他取设定的值的已在读入实体到数据库时处理）
//计算绝缘节距信号楼距离（要么和信号机并置，要么显式指定了其距信号楼距离）,更新信号机、道岔距信号楼距离（左侧为负数）
void CZnSxt::UpdateToXhlDist(void)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=2 and (sxt_ent_type mod 100)\\10<>5 and sxt_ent_toxhldist=0")) ;
		if (cSet.Open(strSql))
		{
			if (cSet.IsBOF())
			{
				cSet.MoveFirst() ;
			}
			while (!cSet.IsEOF())
			{
				double dX = 0, dY = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_x"), dX) ;
				cSet.GetFieldValue(_T("sxt_ent_y"), dY) ;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=1 and abs(sxt_ent_x-%.3f)<0.1 and abs(sxt_ent_y-%.3f)<0.1"), dX, dY) ;
				int iDist = 0 ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_toxhldist"), iDist ) ;
				cSet.Edit() ;
				cSet.SetFieldValue(_T("sxt_ent_toxhldist"), iDist) ;
				cSet.Update() ;

				cSet.MoveNext() ;
			}

			cSet.Close() ;
		}

		//将距信号楼距离按左右区分（左侧为负数，右侧为正数）
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type=310")) ;
		double dX_XHL = 0 ;
		if (m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"), dX_XHL) ==1)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_toxhldist>0")) ;
			if (cSet.Open(strSql))
			{
				while (!cSet.IsEOF())
				{
					double dX = 0 ;
					cSet.GetFieldValue(_T("sxt_ent_x"), dX) ;
					if (dX<dX_XHL)
					{
						int iDist = 0 ;
						cSet.GetFieldValue(_T("sxt_ent_toxhldist"), iDist) ;
						cSet.Edit() ;
						cSet.SetFieldValue(_T("sxt_ent_toxhldist"), -iDist) ;
						cSet.Update() ;
					}
					cSet.MoveNext() ;
				}
				cSet.Close() ;
			}
		}
		else
		{
			AfxMessageBox(_T("在更新距信号楼距离（将左侧设为负数，右侧为正数）时，未正确查询到信号楼x坐标!")) ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in UpdateToXhlDist"));
	}
}

int CZnSxt::ClearShowInfo(const CString& strToClearEntApp)
{
	int iRet = 0 ;
	AcDbDatabase* pDb = acdbHostApplicationServices()->workingDatabase() ;
	CUserSystem mysys ;
	mysys.m_pDb = pDb ;

	AcDbBlockTable * pBlkTbl = NULL ;
	pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;
		Acad::ErrorStatus es = pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead) ;
		if (Acad::eOk == es)
		{
			int iAppValue = 0 ;
			if (mysys.GetXdata(pEnt, strToClearEntApp, iAppValue))
			{
				pEnt->upgradeOpen() ;
				pEnt->erase() ;
				iRet++ ;
			}
			pEnt->close() ;
		}
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return iRet ;
}

// 删除当前图纸指定的扩展数据
int CZnSxt::DeleteXdata(const CStringArray& strArrayAppName)
{
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;
		Acad::ErrorStatus es = pBlkTblRecIter->getEntity(pEnt, AcDb::kForWrite) ;
		if (Acad::eOk == es)
		{
			for (int i=0; i<strArrayAppName.GetCount(); i++)
			{
				m_mysys.DeleteXdata(pEnt, strArrayAppName.GetAt(i)) ;
			}
			pEnt->close() ;
		}
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return 0;
}

// 绘制跳线
void CZnSxt::DrawJumpLine(void)
{
	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(RTDXF0,_T("LWPOLYLINE"), kDxfRegAppName, _T("ForZZJ"), 0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		AcDbEntity* pEntFwInsdie = NULL ;
		if (m_mysys.OpenAcDbEntity(nArrayHandle.GetAt(i), pEntFwInsdie, AcDb::kForRead))
		{
			int nHandleCloneFrom = 0 ;
			m_mysys.GetXdata(pEntFwInsdie, _T("CloneFrom"), nHandleCloneFrom) ;
			if (nHandleCloneFrom==98369)
			{
				int iii = 0 ;
			}

			CString strXdataVal ;
			m_mysys.GetXdata(pEntFwInsdie, _T("ForZZJ"), strXdataVal) ;
			CStringArray strArrayXdataVal ;
			CBlkUtility::DivideString(strXdataVal, _T("-"), strArrayXdataVal) ;
			if (strArrayXdataVal.GetCount()==5)
			{
				CString strDirect = strArrayXdataVal.GetAt(1) ;
				CString strFwVertex = strArrayXdataVal.GetAt(2) ;
				CString strDwLineHandle = strArrayXdataVal.GetAt(3) ;
				int nDwLineHandle = _tstoi(strDwLineHandle) ;
				CString strDwVertex = strArrayXdataVal.GetAt(4) ;
				int iDwVertex = _tstoi(strDwVertex) ;

				AcGePoint2d pt_2d_all[4][2] ; //  pt_2d_fw_inside[2], pt_2d_fw_out[2],pt_2d_dw_inside[2], pt_2d_dw_out[2] ;

				AcDbPolyline* pLineFwInside = AcDbPolyline::cast(pEntFwInsdie) ;
				int iNumVertsFwIn = pLineFwInside->numVerts() ;
				pLineFwInside->getPointAt(strFwVertex==_T("0")?1:iNumVertsFwIn-2, pt_2d_all[0][0]) ;
				pLineFwInside->getPointAt(strFwVertex==_T("0")?2:iNumVertsFwIn-3, pt_2d_all[0][1]) ;

				//fwline outside
				long nHandleFwOut = this->GetPLine(nHandleCloneFrom, strDirect==_T("1")?1:0) ;
				if (nHandleFwOut!=-1)
				{
					AcDbEntity* pEntFwOut = NULL ;
					if (m_mysys.OpenAcDbEntity(nHandleFwOut, pEntFwOut, AcDb::kForRead))
					{
						AcDbPolyline* pLineFwOut= AcDbPolyline::cast(pEntFwOut) ;
						int iNumVertsFwOut = pLineFwOut->numVerts() ;
						pLineFwOut->getPointAt(strFwVertex==_T("0")?0:iNumVertsFwOut-1, pt_2d_all[1][0]) ;
						pLineFwOut->getPointAt(strFwVertex==_T("0")?1:iNumVertsFwOut-2, pt_2d_all[1][1]) ;
						pEntFwOut->close() ;
					}
				}

				//dwline inside
				long nHandleDwInside = this->GetPLine(nDwLineHandle,  strDirect==_T("1")?1:0) ;
				if (nHandleDwInside!=-1)
				{
					AcDbEntity* pEntDWInside = NULL ;
					if (m_mysys.OpenAcDbEntity(nHandleDwInside, pEntDWInside, AcDb::kForRead))
					{
						int iDwVertexSxt = -1 ;
						CString strVertexInfo ;
						m_mysys.GetXdata(pEntDWInside, _T("VertexInfo"), strVertexInfo) ;
						CString strToFind ; 
						strToFind.Format(_T("C:%s"), strDwVertex) ;
						//int iFindLoc1 = strVertexInfo.Find(strToFind) ;
						int iFindLoc1 = -1 ;
						CUIntArray nArrayLoc ;
						int iSumFind = CBlkUtility::FindString(strVertexInfo, strToFind, nArrayLoc) ;
						if (iSumFind>0)
						{
							iFindLoc1 = nArrayLoc.GetAt(iSumFind-1) ;
						}						
						if (iFindLoc1!=-1)
						{
							CString strVertexInfo1 = strVertexInfo.Left(iFindLoc1) ;
							int iFindLoc2 = strVertexInfo1.ReverseFind(_T('A')) ;
							if (iFindLoc2!=-1)
							{
								CString strDwVertex = strVertexInfo1.Mid(iFindLoc2+2, 1)  ;
								iDwVertexSxt = _tstoi(strDwVertex) ;
							}
						}
						AcDbPolyline* pLineDwInside= AcDbPolyline::cast(pEntDWInside) ;
						pLineDwInside->getPointAt(strFwVertex==_T("0")?iDwVertexSxt:(iDwVertexSxt+1), pt_2d_all[2][0]) ;
						pLineDwInside->getPointAt(strFwVertex==_T("0")?(iDwVertexSxt+1):iDwVertexSxt, pt_2d_all[2][1]) ;
						pEntDWInside->close() ;
					}
				}

				//dwline outside
				long nHandleDwOut = this->GetPLine(nDwLineHandle, strDirect==_T("1")?0:1) ;
				if (nHandleDwOut!=-1)
				{
					AcDbEntity* pEntDWOut = NULL ;
					if (m_mysys.OpenAcDbEntity(nHandleDwOut, pEntDWOut, AcDb::kForRead))
					{
						int iDwVertexSxt = -1 ;
						CString strVertexInfo ;
						m_mysys.GetXdata(pEntDWOut, _T("VertexInfo"), strVertexInfo) ;
						CString strToFind ; 
						strToFind.Format(_T("C:%s"), strDwVertex) ;
						int iFindLoc1 = strVertexInfo.Find(strToFind) ;
						if (iFindLoc1!=-1)
						{
							CString strVertexInfo1 = strVertexInfo.Left(iFindLoc1) ;
							int iFindLoc2 = strVertexInfo1.ReverseFind(_T('A')) ;
							if (iFindLoc2!=-1)
							{
								CString strDwVertex = strVertexInfo1.Mid(iFindLoc2+2, 1)  ;
								iDwVertexSxt = _tstoi(strDwVertex) ;
							}
						}
						AcDbPolyline* pLineDwOut= AcDbPolyline::cast(pEntDWOut) ;
						pLineDwOut->getPointAt(strFwVertex==_T("0")?iDwVertexSxt:(iDwVertexSxt+1), pt_2d_all[3][0]) ;
						pLineDwOut->getPointAt(strFwVertex==_T("0")?(iDwVertexSxt+1):iDwVertexSxt, pt_2d_all[3][1]) ;
						pEntDWOut->close() ;
					}
				}	

				//计算绘制跳线
				AcGePoint3d pt_3d_all[4][2] ;
				for (int i=0; i<4; i++)
				{
					for (int j=0; j<2; j++)
					{
						m_mysys.ConvertPoint(pt_2d_all[i][j], pt_3d_all[i][j]) ;
					}
				}
				AcDbLine* pLineFwIn = new AcDbLine(pt_3d_all[0][0], pt_3d_all[0][1]) ;
				AcDbLine* pLineFwOut = new AcDbLine(pt_3d_all[1][0], pt_3d_all[1][1]) ;
				AcDbLine* pLineDwIn = new AcDbLine(pt_3d_all[2][0], pt_3d_all[2][1]) ;
				AcDbLine* pLineDwOut = new AcDbLine(pt_3d_all[3][0], pt_3d_all[3][1]) ;

				AcGeVector2d vecFw = pt_2d_all[0][1] - pt_2d_all[0][0] ;
				AcGeVector2d vecDw = pt_2d_all[2][1] - pt_2d_all[2][0] ;
				double dAngle = vecFw.angleTo(vecDw) ;
				dAngle+=(PI/8) ; //将角度增加一定值
				if (strFwVertex==_T("0")&&strDirect==_T("1")||strFwVertex!=_T("0")&&strDirect==_T("0"))
				{
					dAngle = -dAngle ;
				}                
				AcGePoint3dArray pt3dArrayIn ;
				Acad::ErrorStatus es1 = pLineDwIn->intersectWith(pLineFwIn, AcDb::kExtendBoth, pt3dArrayIn) ;				
				AcGePoint3dArray pt3dArrayOut ;
				Acad::ErrorStatus es2 = pLineDwOut->intersectWith(pLineFwOut, AcDb::kExtendBoth, pt3dArrayOut) ;

				if (es1==Acad::eOk && es2==Acad::eOk)
				{
					int iNum1 = pt3dArrayIn.length() ;
					int iNum2 = pt3dArrayOut.length() ;
					if (iNum2==1&&iNum1==1)
					{
						AcGePoint3d pt_3d_out = pt3dArrayOut.at(0) ;
						AcGePoint3d pt_3d_in = pt3dArrayIn.at(0) ;
						double dLen = pt_3d_in.distanceTo(pt_3d_out)+5.5 ;	
						for (int iLineIndex=0; iLineIndex<2; iLineIndex++)
						{
							AcGePoint3d pt_3d_onlinefw;
							m_mysys.GetPoint(pt_3d_out, dLen+iLineIndex*1.5, vecFw.angle(), pt_3d_onlinefw) ;
							m_mysys.AddAcDbPolyLine(AcGePoint3d(pt_3d_onlinefw.x-0.25, pt_3d_onlinefw.y,0), AcGePoint3d(pt_3d_onlinefw.x+0.25, pt_3d_onlinefw.y,0), 0.5, PI, 7, TRUE) ; //点
							AcGePoint3d pt_3d_onlinedw ;
							m_mysys.GetPoint(pt_3d_out, dLen+iLineIndex*1.5, vecDw.angle(), pt_3d_onlinedw) ;
							m_mysys.AddAcDbPolyLine(AcGePoint3d(pt_3d_onlinedw.x-0.25, pt_3d_onlinedw.y,0), AcGePoint3d(pt_3d_onlinedw.x+0.25, pt_3d_onlinedw.y,0), 0.5, PI, 7, TRUE) ; //点

							m_mysys.AddAcDbPolyLine(pt_3d_onlinefw, pt_3d_onlinedw, 0, dAngle, 7) ;//跳线
						}
					}
				}
                
				delete pLineFwIn ;
				pLineFwIn = NULL ;
				delete pLineFwOut ;
				pLineFwOut = NULL ;				
				delete pLineDwIn ;
				pLineDwIn = NULL ;				
				delete pLineDwOut ;
				pLineDwOut = NULL ;
			}
			pEntFwInsdie->close() ;
		}
	}

}
//取得 CloneFrom=nCloneFromHandle,UPDOWN=iUpOrDwon 的多段线
long CZnSxt::GetPLine(long nCloneFromHandle, int iUpOrDwon)
{
	long nRet = 0 ;
	int iRetNum = 0 ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	//pRb = acutBuildList(RTDXF0,_T("LWPOLYLINE"), 1001, _T("CloneFrom"), 1070, nCloneFromHandle, 1001, _T("UPDOWN"), 1070, iUpOrDwon, 0) ;
	pRb = acutBuildList(RTDXF0,_T("LWPOLYLINE"), 1001, _T("CloneFrom"), 1001, _T("UPDOWN"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;
	for (int i=0; i<nLen; i++)
	{
		AcDbEntity* pEnt = NULL ;
		long nTemp = nArrayHandle.GetAt(i) ;
		if (m_mysys.OpenAcDbEntity(nTemp, pEnt, AcDb::kForRead))
		{
			long  nCloneFrom = 0 ;
			int iUPDOWN = 0 ;
			m_mysys.GetXdata(pEnt, _T("CloneFrom"), nCloneFrom) ;
			m_mysys.GetXdata(pEnt, _T("UPDOWN"), iUPDOWN) ;
			if (nCloneFrom==nCloneFromHandle&&iUPDOWN==iUpOrDwon)
			{
				nRet = nTemp ;
                iRetNum++ ;
			}
			pEnt->close() ;
		}
	}
	if (iRetNum==1)
	{
		return nRet ;
	}
	else
	{
		acutPrintf(_T("\n在查找CloneFrom=%d,UPDOWN=%d的多段线时，结果为%d"), nCloneFromHandle, iUpOrDwon, iRetNum) ;
		return -1 ;
	}
}

// 绘制指定送受电、厄流图形
void CZnSxt::DrawBoxFsE(long nHandleJyj)
{
// 	if (nHandleJyj==2636)
// 	{
// 		int iii = 0 ;
// 	}
	//先清除原来的
	this->ClearBoxFsE(nHandleJyj) ;

	AcGePoint3d pt_3d_up, pt_3d_down ;
	BOOL bGetPtOfSxtJyj = this->GetPtOfSxtJyj(nHandleJyj, pt_3d_up, pt_3d_down) ;
	if (bGetPtOfSxtJyj==FALSE) //没有双线部分，直接退出，解决了没有双线图时运行此函数会导致平面图信号机等移位问题
	{
		return ;
	}

	//保存当前图层，设置要绘制的图层
	AcDbObjectId ojbIdLayerOld = m_pDb->clayer() ;
	m_mysys.SetCLayer(_T("CRSC_SJY_XTS_SXT_DLJL_GD"), 2) ;
	m_iColorIndexCur = 256 ;

	// begin 绘制盒子
	CString strSql ;
	strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleJyj) ;
	int iUpOrDown = 0 ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_upordown"), iUpOrDown) ;

	///begin 绝缘节所在线段信息	
	AcGeVector2d vecOnLine = GetAngleOfJyjOnLine(nHandleJyj) ;
	double dAngleOnLine = 0 ;
	dAngleOnLine = vecOnLine.angle() ;
	//end  绝缘节所在线段信息

	//左右轨道
	long nHandleLeftLine = 0, nHandleRightLine = 0 ;
	this->GetGdBesideJyj(nHandleJyj, nHandleLeftLine, nHandleRightLine) ;
	CGdDATA dataGdLeft, dataGdRight ;
	this->GetEntData(nHandleLeftLine, dataGdLeft) ;
	this->GetEntData(nHandleRightLine, dataGdRight) ;

	AcDbBlockReference* pRef = NULL ;
	AcGePoint3d pt_3d_cen; //双线中间线和绝缘节交点位置，此处为厄流插入点

	pt_3d_cen = m_mysys.GetMidPoint(pt_3d_up, pt_3d_down) ;
	double dEntX = pt_3d_cen.x, dEntY = pt_3d_cen.y ;
	CString strBlkName ;
	AcGePoint3d pt_3d_xb(0,0,0) ; //送受电盒子

	//双线中线一段
	AcGePoint2d pt_2d_cen1 = pt_3d_cen.convert2d(AcGePlane::kXYPlane)+vecOnLine ;
	AcGePoint3d pt_3d_cen1(0,0,0) ;
	m_mysys.ConvertPoint(pt_2d_cen1, pt_3d_cen1) ;

	//绝缘节左边
	if (dataGdLeft.m_bIsDH) //有厄流
	{
		double dAngleE = dAngleOnLine ;
		strBlkName = _T("BOX_E_0") ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_cen))
		{
			if (iUpOrDown==1)
			{
				dAngleE+=PI ;
				AcGeScale3d scale_3d = pRef->scaleFactors()  ;	
				scale_3d.set(-scale_3d.sx, scale_3d.sy, scale_3d.sz) ;
				pRef->setScaleFactors(scale_3d) ;
			}
			pRef->setRotation(pRef->rotation()+dAngleE) ;
			m_mysys.SetXdata(pRef, _T("BELONG_JYJ"), nHandleJyj) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleLeftLine) ;

			pRef->close() ;
			pRef = NULL ;
		}
		//连线
		AcGePoint3d pt_3d_left(pt_3d_cen.x-2, pt_3d_cen.y+6,0), pt_3d_right(pt_3d_cen.x+2, pt_3d_cen.y+6,0) ;						
		AcDbObjectId objIdPline = m_mysys.AddAcDbPolyLine(pt_3d_left, pt_3d_right, 0.2, 0, m_iColorIndexCur) ;
		AcDbEntity* pEntLine = NULL ;
		if (m_mysys.OpenAcDbEntity(objIdPline, pEntLine))
		{
			m_mysys.RotationEnt(pEntLine,dAngleE, pt_3d_cen ) ;	
			m_mysys.SetXdata(pEntLine, _T("BELONG_JYJ"), nHandleJyj) ;
			pEntLine->close() ;
		}
		//左侧点
		pt_3d_left.rotateBy(dAngleE, AcGeVector3d::kZAxis, pt_3d_cen) ;
		AcDbObjectId objIdConNodeLeft= m_mysys.DrawConNode(pt_3d_left, 0.4) ;
		m_mysys.SetXdata(objIdConNodeLeft, _T("BELONG_JYJ"), nHandleJyj) ;
		
		if (!dataGdRight.m_bIsDH)//右侧没有厄流，需要将左侧厄流连上轨道
		{
			AcDbObjectId objIds[3] ;
			AcGePoint3d pt_3d_3(pt_3d_right.x+1, pt_3d_right.y, 0) ;
			AcGePoint3d pt_3d_4(pt_3d_3.x, pt_3d_cen.y+2.5, 0) ;
			AcGePoint3d pt_3d_5(pt_3d_3.x, pt_3d_cen.y-2.5, 0) ;
			AcGePoint3dArray pt3dArray ;
			pt3dArray.append(pt_3d_right) ;
			pt3dArray.append(pt_3d_3) ;
			pt3dArray.append(pt_3d_4) ;
			pt3dArray.append(pt_3d_5) ;
			objIds[0] = m_mysys.AddAcDbPolyLine(pt3dArray, 0.2, m_iColorIndexCur) ;
			AcGePoint3d pt_3d_startArc(pt_3d_4.x-0.2, pt_3d_4.y, 0) ;						
			objIds[1] = m_mysys.AddAcDbPolyLine(pt_3d_startArc, PI, pt_3d_4, 0.4, m_iColorIndexCur) ;
			pt_3d_startArc.y = pt_3d_5.y ;
			objIds[2] = m_mysys.AddAcDbPolyLine(pt_3d_startArc, PI, pt_3d_5, 0.4, m_iColorIndexCur) ;

			for (int i=0; i<3; i++)
			{
				pEntLine = NULL ;
				if (m_mysys.OpenAcDbEntity(objIds[i], pEntLine))
				{
					m_mysys.RotationEnt(pEntLine,dAngleOnLine, pt_3d_cen ) ;	
					if (iUpOrDown==1)
					{
						AcGeMatrix3d matrix ;
						matrix.setToMirroring(AcGeLine3d(pt_3d_cen, pt_3d_cen1)) ;
						pEntLine->transformBy(matrix) ;
					}
					m_mysys.SetXdata(pEntLine, _T("BELONG_JYJ"), nHandleJyj) ;
					pEntLine->close() ;
				}
			}
		}
	}
	if (dataGdLeft.m_strRightFOrS!=_T("N")&&!(m_i4Or2Line==1&&dataGdLeft.m_bIsDMH)) //二线制且是电码化区段时不绘制该送受电（和电码化同缆）
	{
		strBlkName.Format(_T("BOX_FSD_%s_0"), dataGdLeft.m_strRightFOrS) ;
		double dBoxX = dEntX-4 ;
		double dBoxY = dEntY+(iUpOrDown==0?(dataGdLeft.m_bIsDH?10:6):-(dataGdRight.m_bIsDH?10:6)) ;
		pt_3d_xb.x = dBoxX ;
		pt_3d_xb.y = dBoxY ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_xb))
		{
			m_mysys.RotationEnt(pRef, dAngleOnLine, pt_3d_cen) ;
			m_mysys.SetXdata(pRef, _T("BELONG_JYJ"), nHandleJyj) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleLeftLine) ;
			m_mysys.SetXdata(pRef, _T("LEFT_RIGHT"), (long)0) ;

			pRef->close() ;
			pRef = NULL ;
		}
	}
	//绝缘节右边
	if (dataGdRight.m_bIsDH) //有厄流
	{
		double dAngleE = dAngleOnLine ;
		if (m_mysys.InsertBlock(pRef, _T("BOX_E_0"), pt_3d_cen))
		{
			if (iUpOrDown==0)
			{
				AcGeScale3d scale_3d = pRef->scaleFactors()  ;	
				scale_3d.set(-scale_3d.sx, scale_3d.sy, scale_3d.sz) ;
				pRef->setScaleFactors(scale_3d) ;
			}
			else if (iUpOrDown==1)
			{
				dAngleE+=PI ;
			}
			pRef->setRotation(pRef->rotation()+dAngleE) ;
			m_mysys.SetXdata(pRef, _T("BELONG_JYJ"), nHandleJyj) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleRightLine) ;

			pRef->close() ;
			pRef = NULL ;
		}
		//右侧点
		AcGePoint3d pt_3d_node(pt_3d_cen.x+2, pt_3d_cen.y+6,0) ;
		pt_3d_node.rotateBy(dAngleE, AcGeVector3d::kZAxis, pt_3d_cen) ;
		AcDbObjectId objIdConNodeRight= m_mysys.DrawConNode(pt_3d_node, 0.4) ;
		m_mysys.SetXdata(objIdConNodeRight, _T("BELONG_JYJ"), nHandleJyj) ;
		//连线
		if (!dataGdLeft.m_bIsDH)
		{
			AcGePoint3d pt_3d_left(pt_3d_cen.x-2, pt_3d_cen.y+6,0), pt_3d_right(pt_3d_cen.x+2, pt_3d_cen.y+6,0) ;							
			AcDbObjectId objIdPline = m_mysys.AddAcDbPolyLine(pt_3d_left, pt_3d_right, 0.2, m_iColorIndexCur) ;
			AcDbEntity* pEntLine = NULL ;
			if (m_mysys.OpenAcDbEntity(objIdPline, pEntLine))
			{
				m_mysys.RotationEnt(pEntLine,dAngleE, pt_3d_cen ) ;	
				m_mysys.SetXdata(pEntLine, _T("BELONG_JYJ"), nHandleJyj) ;
				pEntLine->close() ;
			}

			AcDbObjectId objIds[3] ;
			AcGePoint3d pt_3d_3(pt_3d_left.x-1, pt_3d_left.y, 0) ;
			AcGePoint3d pt_3d_4(pt_3d_3.x, pt_3d_cen.y+2.5, 0) ;
			AcGePoint3d pt_3d_5(pt_3d_3.x, pt_3d_cen.y-2.5, 0) ;
			AcGePoint3dArray pt3dArray ;
			pt3dArray.append(pt_3d_right) ;
			pt3dArray.append(pt_3d_3) ;
			pt3dArray.append(pt_3d_4) ;
			pt3dArray.append(pt_3d_5) ;
			objIds[0] = m_mysys.AddAcDbPolyLine(pt3dArray, 0.2, m_iColorIndexCur) ;
			AcGePoint3d pt_3d_startArc(pt_3d_4.x-0.2, pt_3d_4.y, 0) ;						
			objIds[1] = m_mysys.AddAcDbPolyLine(pt_3d_startArc, PI, pt_3d_4, 0.4, m_iColorIndexCur) ;
			pt_3d_startArc.y = pt_3d_5.y ;
			objIds[2] = m_mysys.AddAcDbPolyLine(pt_3d_startArc, PI, pt_3d_5, 0.4, m_iColorIndexCur) ;

			for (int i=0; i<3; i++)
			{
				pEntLine = NULL ;
				if (m_mysys.OpenAcDbEntity(objIds[i], pEntLine))
				{
					m_mysys.RotationEnt(pEntLine,dAngleOnLine, pt_3d_cen ) ;	
					if (iUpOrDown==1)
					{
						AcGeMatrix3d matrix ;
						matrix.setToMirroring(AcGeLine3d(pt_3d_cen, pt_3d_cen1)) ;
						pEntLine->transformBy(matrix) ;
					}
					m_mysys.SetXdata(pEntLine, _T("BELONG_JYJ"), nHandleJyj) ;

					pEntLine->close() ;
				}
			}							
		}
	}
	if (dataGdRight.m_strLeftFOrS!=_T("N")&&!(m_i4Or2Line==1&&dataGdRight.m_bIsDMH))
	{
		strBlkName.Format(_T("BOX_FSD_%s_0"), dataGdRight.m_strLeftFOrS) ;
		double dBoxX = dEntX+4 ;
		double dBoxY = dEntY+(iUpOrDown==0?(dataGdRight.m_bIsDH?10:6):-(dataGdRight.m_bIsDH?10:6)) ;
		pt_3d_xb.x = dBoxX ;
		pt_3d_xb.y = dBoxY ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_xb))
		{
			m_mysys.RotationEnt(pRef, dAngleOnLine, pt_3d_cen) ;
			m_mysys.SetXdata(pRef, _T("BELONG_JYJ"), nHandleJyj) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleRightLine) ;
			m_mysys.SetXdata(pRef, _T("LEFT_RIGHT"), (long)1) ;

			pRef->close() ;
			pRef = NULL ;
		}
	}		
	//end 绘制盒子

	//移动信号机
	long nHandleXhj = 0 ;
	this->GetXhjInSxt(nHandleLeftLine, nHandleRightLine, nHandleXhj) ;
	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandleXhj, pEnt))
	{
		AcDbBlockReference* pRefXhj = AcDbBlockReference::cast(pEnt) ;
		m_mysys.GetBlockName(pRefXhj, strBlkName) ;	
		double dAngle = pRefXhj->rotation() ;
		AcGePoint3d pt_3d_ref = pRefXhj->position() ;

		//盒子高度
		int iLeft = (dataGdLeft.m_strRightFOrS!=_T("N")?1:0)+(dataGdLeft.m_bIsDH?1:0) ;
		int iRight = (dataGdRight.m_strLeftFOrS!=_T("N")?1:0)+(dataGdRight.m_bIsDH?1:0) ;
		double dBoxHeight = 0.000 ;
		int iMax = max(iLeft, iRight) ;
		if (iMax==1)
		{
			dBoxHeight+=5 ;
		}
		else if (iMax==2)
		{
			dBoxHeight+=9 ;
		}

		//begin 在双线图中，信号机基点不能在中线上，要至少上/下移2.5
		AcGePoint3d pt_3d_new2(pt_3d_cen) ;
		int iMarkLoc = strBlkName.Find(_T("_Z_")) ;//正向信号机, 逆向信号机
		//角度在90度~270度之间是倒置了
		if (dAngle>PI/2&&dAngle<PI*3/2)
		{
			pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?2.5:-2.5) ;
			if (iUpOrDown==0) //下行
			{
				pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?dBoxHeight:0) ;
			}
			else
			{
				pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?0:-dBoxHeight) ;
			}
		}
		else
		{
			pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?-2.5:2.5) ;
			if (iUpOrDown==0) //下行
			{
				pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?0:dBoxHeight) ;
			}
			else
			{
				pt_3d_new2.x=pt_3d_new2.x+(iMarkLoc==-1?-dBoxHeight:0) ;
			}
		}
		pt_3d_new2.rotateBy(PI/2+dAngleOnLine, AcGeVector3d::kZAxis, pt_3d_cen) ;
		AcGeVector3d vec = pt_3d_new2 - pt_3d_ref ;
		AcGeMatrix3d matrix ;
		matrix.setToTranslation(vec) ;
		pRefXhj->transformBy(matrix) ; 

		pEnt->close() ;
	}

	m_pDb->setClayer(ojbIdLayerOld) ; //恢复当前图层
}

// 绝缘节所在线的vec
AcGeVector2d CZnSxt::GetAngleOfJyjOnLine(long nHandleJyj)
{
	AcGeVector2d vecOnLine(0,0) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		//begin 绝缘节所在线段信息
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleJyj ) ;
		if (cSet.Open(strSql))
		{
			int iRsCount = cSet.GetRecordCount() ;
			if (iRsCount==1)
			{
				long nHandleOnLine  = 0 , nVertexOnLine ;
				cSet.GetFieldValue(_T("sxt_ent_online_handle"), nHandleOnLine) ;
				if (nHandleOnLine!=0)//未分段pmt
				{
					cSet.GetFieldValue(_T("sxt_ent_online_vertex"), nVertexOnLine) ;
				}
				else //分段平面图
				{
					cSet.GetFieldValue(_T("sxt_ent_conline_left"), nHandleOnLine) ;
					cSet.GetFieldValue(_T("sxt_ent_conline_left_vertex"), nVertexOnLine) ;
					//防止端头绝缘节(不能同时采用left和right线)
					if (nHandleOnLine!=0)
					{
						nVertexOnLine-- ;
					}
					else
					{
						cSet.GetFieldValue(_T("sxt_ent_conline_right"), nHandleOnLine) ;
						cSet.GetFieldValue(_T("sxt_ent_conline_right_vertex"), nVertexOnLine) ;
					}
				}

				AcGePoint2d pt_2d_online1, pt_2d_online2 ;
				AcDbEntity* pEntOnLine = NULL ;
				if (m_mysys.OpenAcDbEntity(nHandleOnLine, pEntOnLine, AcDb::kForRead))
				{
					if (pEntOnLine->isKindOf(AcDbPolyline::desc()))
					{
						AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEntOnLine) ;
						pPolyLine->getPointAt(nVertexOnLine, pt_2d_online1) ;
						pPolyLine->getPointAt(nVertexOnLine+1, pt_2d_online2) ;
					}
					pEntOnLine->close() ;
				}
				vecOnLine = pt_2d_online2-pt_2d_online1 ;
			}
			else
			{
				CString strMsg ;
				strMsg.Format(_T("handle为%d的绝缘节个数为%d"), nHandleJyj, iRsCount) ;
				AfxMessageBox(strMsg) ;
			}
		}

		//end  绝缘节所在线段信息
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetAngleOfJyjOnLine"));
	}

	return vecOnLine ;
}

// 双线图中上下2个绝缘节
BOOL CZnSxt::GetPtOfSxtJyj(long nHandleJyj, AcGePoint3d& pt_3d_up, AcGePoint3d& pt_3d_down)
{
	BOOL bRet = FALSE ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(RTDXF0,_T("INSERT"), 1001, _T("CloneFrom"), 1001, _T("UPDOWN"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	int iTimeSetUp = 0, iTimeSetDown = 0 ;
	
	for (int i=0; i<nLen; i++)
	{
		long nHandle = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			long nHandleCloneFrom = 0 ;
			m_mysys.GetXdata(pEnt, _T("CloneFrom"), nHandleCloneFrom) ;
			if (nHandleCloneFrom==nHandleJyj)
			{
				int iUPDOWN = -1 ;
				m_mysys.GetXdata(pEnt, _T("UPDOWN"), iUPDOWN) ;
				if (iUPDOWN>-1)
				{
					AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
					AcGePoint3d pt_3d_tmp = pRef->position() ;
					if (iUPDOWN==1)
					{
						pt_3d_up = pt_3d_tmp ;
						iTimeSetUp++ ;
					}
					else
					{
						pt_3d_down = pt_3d_tmp ;
						iTimeSetDown++ ;
					}
				}
			}
			pEnt->close() ;
		}		
	}

	if (iTimeSetUp==1&&iTimeSetDown==1)
	{
		bRet = TRUE ;
	}

	return bRet ;
}

// 绘制所有送受电、厄流
void CZnSxt::DrawBoxFsE(void)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=2 and ((sxt_ent_type mod 100)\\10)<>5 and sxt_ent_type<>201")) ; //整除为2的,且不是250、251之类的切割绝缘节，也不是201之类的渡线绝缘节
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;
				this->DrawBoxFsE(nHandle) ;
				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in DrawBoxFsE"));
	}
}

// 取得指定绝缘节两侧的轨道
int CZnSxt::GetGdBesideJyj(long nHandleJyj, long& nHandleLeftLine, long& nHandleRightLine)
{
	int iRet = 0 ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleJyj) ;
		long nHandleLeftLineTmp = 0, nHandleRightLineTmp = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"), nHandleLeftLine) ;
		if (nHandleLeftLineTmp!=0)
		{
			nHandleLeftLine = nHandleLeftLineTmp ;
			iRet++ ;
		}
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"), nHandleRightLine) ;
		if (nHandleRightLineTmp!=0)
		{
			nHandleRightLine = nHandleRightLineTmp ;
			iRet++ ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGdBesideJyj"));
	}

	return iRet ;
}

// 清除指定的送受电、厄流图形
void CZnSxt::ClearBoxFsE(long nHandleJyj)
{
	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(1001, _T("BELONG_JYJ"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		long nHandle = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			long nHandleBelong = 0 ;
			m_mysys.GetXdata(pEnt, _T("BELONG_JYJ"), nHandleBelong) ;
			if (nHandleBelong==nHandleJyj)
			{
				long iIsFor = 0 ;
				m_mysys.GetXdata(pEnt, _T("IS_FOR"), iIsFor) ;
				if (iIsFor==0) //is_for=0表示是轨道电路送受电的盒子等，=1表示电码化的
				{
					pEnt	->upgradeOpen() ;
					pEnt->erase() ;
				}
			}
			pEnt->close() ;
		}		
	}
}

// 取得两线间的信号机在sxt中的copy
int CZnSxt::GetXhjInSxt(long nHandleLeftLine, long nHandleRightLine, long& nHandleXhj)
{
	int iRet = 0 ;
	CString strSql ;
	long nHandleXhjInPmt = 0 ;
	if (nHandleLeftLine==0&&nHandleRightLine==0)
	{
		return 0 ;
	}
	else if (nHandleLeftLine>0&&nHandleRightLine==0)
	{
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=1 and sxt_ent_conline_left=%d "), nHandleLeftLine) ;
	}
	else if (nHandleLeftLine==0&&nHandleRightLine>0)
	{
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=1 and sxt_ent_conline_right=%d"), nHandleRightLine) ;
	}
	else if (nHandleLeftLine>0&&nHandleRightLine>0)
	{
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=1 and (sxt_ent_conline_left=%d or sxt_ent_conline_right=%d)"), nHandleLeftLine, nHandleRightLine) ;
	}
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleXhjInPmt) ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(RTDXF0, _T("INSERT"), 1001, _T("CloneFrom"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		long nHandle = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			long nHandleCloneFrom = 0 ;
			m_mysys.GetXdata(pEnt, _T("CloneFrom"), nHandleCloneFrom) ;
			if (nHandleCloneFrom==nHandleXhjInPmt)
			{
				nHandleXhj = nHandle ;
				iRet++ ;
			}
			pEnt->close() ;
		}		
	}
	return iRet;
}

// 绘制指定道岔的转辙机
void CZnSxt::DrawZzj(long nHandleDc)
{
// 	if (nHandleDc==116158)
// 	{
// 		int iii = 0 ;
// 	}
	//先清除原有图形
	//this->ClearZzj(nHandleDc) ;
	this->ClearEnt(nHandleDc, 1) ;
	long nHandlePlineBelongDc = 0 ;
	if (this->GetSxBelongDc(nHandleDc, nHandlePlineBelongDc)==0) //没找到相应的双线，直接退出
	{
		return ;
	}

	//保存当前图层，设置要绘制的图层
	AcDbObjectId ojbIdLayerOld = m_pDb->clayer() ;
	m_mysys.SetCLayer(_T("CRSC_SJY_XTS_SXT_DLJL_ZZJ"), 3) ;
	m_iColorIndexCur = 256 ;

	CString strSql ;
	strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
	int iUpOrDownDc = 0 ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_upordown"), iUpOrDownDc) ;

	//道岔信息
	CDcDATA dcData ;
	this->GetEntData(nHandleDc, dcData) ;
	double dAngleDc = 	m_mysys.GetAngle(nHandleDc) ; //道岔块旋转角度	

	int iDcDirectV = 0 ; //道岔FW朝向（1，朝上；0，朝下） 
	int iFwIndexVertex = 0 ; //FW端线的顶点vertex（起点或终点）
	AcGePoint2d pt_2d_ext0, pt_2d_ext1, pt_2d_ext2 ; //双线中和online平行的一小段线的端头点和紧邻的点
	AcGeVector2d vecDw ;

	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandlePlineBelongDc, pEnt, AcDb::kForRead))
	{
		CString strForZZJ ;
		m_mysys.GetXdata(pEnt, _T("ForZZJ"), strForZZJ) ;
		CStringArray strArrayForZZJ ;
		CBlkUtility::DivideString(strForZZJ, _T("-"), strArrayForZZJ) ;
		if (strArrayForZZJ.GetCount()==5)
		{
			CString strTmp = strArrayForZZJ.GetAt(0) ;
			long nHandleDcTmp = 0 ;
			nHandleDcTmp = _ttol(strTmp) ;
			if (nHandleDcTmp==nHandleDc)
			{
				AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
				iDcDirectV = _ttoi(strArrayForZZJ.GetAt(1)) ; //道岔FW朝向（1，朝上；0，朝下） 
				iFwIndexVertex =  _ttoi(strArrayForZZJ.GetAt(2)) ; //FW端线的顶点vertex（起点或终点）
				if (iFwIndexVertex==0)
				{
					pPolyLine->getPointAt(0, pt_2d_ext0) ;
					pPolyLine->getPointAt(1, pt_2d_ext1) ;
					pPolyLine->getPointAt(2, pt_2d_ext2) ;
					vecDw = pt_2d_ext1-pt_2d_ext0 ;
				}
				else
				{
					int iNumOfPline = pPolyLine->numVerts() ;
					pPolyLine->getPointAt(iNumOfPline-1, pt_2d_ext0) ;
					pPolyLine->getPointAt(iNumOfPline-2, pt_2d_ext1) ;
					pPolyLine->getPointAt(iNumOfPline-3, pt_2d_ext2) ;
					vecDw = pt_2d_ext0-pt_2d_ext1 ;
				}
			}
		}
		pEnt->close() ;
	}	

	//begin draw zzj
	CStringArray strArrayDrag ;
	dcData.GetDrag(strArrayDrag, 0) ;

	int iDcDirectH =(iFwIndexVertex==0?0:1) ; //道岔FW水平朝向，0朝右，1，朝左
	AcGeLineSeg2d line2d(pt_2d_ext0, pt_2d_ext1) ;		
	
	AcGePoint2d pt_2d_extcen =line2d.midPoint() ;
	AcGePoint2d pt_2d_extcen_mid = pt_2d_extcen ;
	pt_2d_extcen_mid.y+=(iDcDirectV==1?1.5:-1.5) ;
	pt_2d_extcen_mid.rotateBy(vecDw.angle(), pt_2d_extcen) ; //双线中心线

	//映射到双线的一边
	AcGePoint2d pt_2d_extcen_jg = pt_2d_extcen_mid ;
	pt_2d_extcen_jg.y +=(iUpOrDownDc==0?-2.5:2.5); 
	pt_2d_extcen_jg.rotateBy(vecDw.angle(), pt_2d_extcen) ;
	AcDbBlockReference* pRefZzj = NULL ;
	CString strBlkNameZzj ;
	strBlkNameZzj.Format(_T("ZZJ_SXT_JX_0")) ;

	//第几动（对于交流直捅到楼的，即使多动也各自按一动处理）
	CString strActionInfo ;
	this->GetDcActionInfo(dcData.m_strJG_QyType, dcData.GetActionNum(), dcData.m_nActIndex==0?1:dcData.m_nActIndex, strActionInfo) ;

	for (int i=0; i<dcData.m_nJG_QyNum; i++)
	{
		double dX_Jg = pt_2d_extcen_jg.x+(iDcDirectH==0?-1:1)*dcData.m_nJG_QyNum*3/2+(iDcDirectH==0?1:-1)*1.5+i*3*(iDcDirectH==0?1:-1) ;
		AcGePoint2d pt_2d_zzj(dX_Jg, pt_2d_extcen_jg.y) ;
		pt_2d_zzj.rotateBy(vecDw.angle(), pt_2d_extcen_jg) ;
		AcGePoint3d pt_3d_zzj(pt_2d_zzj.x, pt_2d_zzj.y, 0) ;
		CStringArray strArrayVal ;
		CString strVal ;
		strVal.Format(_T("J%d"), i+1) ;
		strArrayVal.Add(strVal) ;	
		strArrayVal.Add(strArrayDrag.GetAt(i)) ;
		strArrayVal.Add(strActionInfo) ;
		if (m_mysys.InsertBlock(pRefZzj, strBlkNameZzj, pt_3d_zzj, &strArrayVal, FALSE))
		{
			m_mysys.RotationEnt(pRefZzj, vecDw.angle()+(iUpOrDownDc==1?PI:0), pt_3d_zzj) ;
			m_mysys.SetXdata(pRefZzj, _T("IS_JXG"), 1) ;
			m_mysys.SetXdata(pRefZzj, _T("BELONG_ENT"), nHandleDc) ;
			//m_mysys.SetXdata(pRefZzj, _T("ACTION_INFO"), strActionInfo) ;
			//绘制对应的箱盒
			this->DrawBoxZzj(pRefZzj, dcData.m_strJG_QyType, dcData.m_nJG_QyNum, i, iDcDirectH) ;
			pRefZzj->close() ;
			pRefZzj = NULL ;
		}										
	}

	//求芯轨绘制中心点
	strArrayDrag.RemoveAll() ;
	dcData.GetDrag(strArrayDrag, 1) ;

	AcGePoint2d pt_2d_xg(0,0) ; //芯轨绘制中心点
	AcGeLineSeg2d lineseg2d_xg1(pt_2d_ext1 , pt_2d_ext2) ;
	AcGePoint3d pt_3d_xg ;
	this->GetXgInsertPt(nHandleDc, iDcDirectV, pt_3d_xg) ;	
	pt_2d_xg = pt_3d_xg.convert2d(AcGePlane::kXYPlane) ;
	//第几动（对于交流直捅到楼的，即使多动也各自按一动处理）
	strActionInfo = _T("") ;
	this->GetDcActionInfo(dcData.m_strXG_QyType, dcData.GetActionNum(), dcData.m_nActIndex, strActionInfo) ;
	for (int i=0; i<dcData.m_nXG_QyNum; i++)
	{
		double dX_Xg = pt_2d_xg.x+(iDcDirectH==0?-1:1)*dcData.m_nXG_QyNum*3/2+(iDcDirectH==0?1:-1)*1.5+i*3*(iDcDirectH==0?1:-1) ;
		AcGePoint2d pt_2d_zzj(dX_Xg, pt_2d_xg.y) ;
		pt_2d_zzj.rotateBy(vecDw.angle(), pt_2d_xg) ;
		AcGePoint3d pt_3d_zzj(pt_2d_zzj.x, pt_2d_zzj.y, 0) ;
		CStringArray strArrayVal ;
		CString strVal ;
		strVal.Format(_T("X%d"), i+1) ;
		strArrayVal.Add(strVal) ;
		strArrayVal.Add(strArrayDrag.GetAt(i)) ;
		strArrayVal.Add(strActionInfo) ;
		if (m_mysys.InsertBlock(pRefZzj, strBlkNameZzj, pt_3d_zzj, &strArrayVal, FALSE))
		{
			m_mysys.RotationEnt(pRefZzj, vecDw.angle()+(iUpOrDownDc==1?PI:0), pt_3d_zzj) ;
			m_mysys.SetXdata(pRefZzj, _T("IS_JXG"), 2) ;
			m_mysys.SetXdata(pRefZzj, _T("BELONG_ENT"), nHandleDc) ;
			//m_mysys.SetXdata(pRefZzj, _T("ACTION_INFO"), strActionInfo) ;
			//绘制对应的箱盒
			this->DrawBoxZzj(pRefZzj, &dcData, i, iDcDirectH) ;
			pRefZzj->close() ;
			pRefZzj = NULL ;
		}										
	}
	//end draw zzj
	m_pDb->setClayer(ojbIdLayerOld) ; //恢复当前图层
}

// 清除指定道岔的转辙机
void CZnSxt::ClearZzj(long nHandleDc)
{
	CLongArray nArrayHandle ;
	this->FindEntBelong(nHandleDc, nArrayHandle) ;
	for (int i=0; i<nArrayHandle.GetCount(); i++)
	{
		long nHandle = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForWrite))
		{
			long nHandleBelong = 0 ;
			m_mysys.GetXdata(pEnt, _T("BELONG_ENT"), nHandleBelong) ;
			if (nHandleBelong==nHandleDc)
			{
				pEnt->erase() ;
			}
			pEnt->close() ;
		}		
	}
}

// 绘制所有道岔的转辙机
void CZnSxt::DrawZzj(void)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type=0")) ; 
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;
				this->DrawZzj(nHandle) ;
				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in DrawZzj"));
	}
}

// 取得芯轨绘制中心点
int CZnSxt::GetXgInsertPt(long nHandleDc, int iDcDirectV, AcGePoint3d &pt_3d_ret)
{
	int iRet = 0 ;

	CString strSql ;
	strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
	long nHandleDW = 0 ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleDW) ;
	long nHandleFW = 0 ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFW) ;
	CString strDcName ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strDcName) ;

	long nHandleDwSxt = 0, nHandleFwSxt = 0 ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(RTDXF0, _T("LWPOLYLINE"), 1001, _T("CloneFrom"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		long nHandle = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			long nHandleCloneFrom = 0 ;
			m_mysys.GetXdata(pEnt, _T("CloneFrom"), nHandleCloneFrom) ;
			int iUpOrDownTmp = -1 ;
			m_mysys.GetXdata(pEnt, _T("UPDOWN"), iUpOrDownTmp) ;

			if (nHandleCloneFrom==nHandleDW)
			{
				if (iDcDirectV==iUpOrDownTmp)
				{
					nHandleDwSxt = nHandle ;
				}				
			}
			else if (nHandleCloneFrom==nHandleFW)
			{
				if (iDcDirectV!=iUpOrDownTmp)
				{
					nHandleFwSxt = nHandle ;
				}
			}
			pEnt->close() ;
		}		
	}

	if (nHandleDwSxt!=0&&nHandleFwSxt!=0)
	{
		AcDbEntity* pEnt1 = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandleDwSxt, pEnt1, AcDb::kForRead))
		{
			AcDbEntity* pEnt2 = NULL ;
			if (m_mysys.OpenAcDbEntity(nHandleFwSxt, pEnt2, AcDb::kForRead))
			{
				AcGePoint3dArray pt3dArray ;
				pEnt2->intersectWith(pEnt1, AcDb::kOnBothOperands, pt3dArray) ;
				iRet = pt3dArray.length() ;
				if (iRet==1)
				{
					pt_3d_ret = pt3dArray.at(0) ;
				}

				pEnt2->close() ;
			}

			pEnt1->close() ;
		}
	}

	if (iRet!=1)
	{
		acutPrintf(_T("\n求道岔%s的双线中芯轨绘制点时,交点为%d"), strDcName, iRet) ;
	}

	return iRet;
}

// 绘制信号机箱盒
void CZnSxt::DrawBoxXhj(long nHandleXhj)
{
// 	if (nHandleXhj==67352)
// 	{
// 		int ii = 0 ;
// 	}
	this->ClearEnt(nHandleXhj, 1) ;
	long nHandleCloneXhj = 0 ; 
	if (this->GetCloneXhj(nHandleXhj, nHandleCloneXhj)==0)
	{
		return ;
	}

	//保存当前图层，设置要绘制的图层
	AcDbObjectId ojbIdLayerOld = m_pDb->clayer() ;
	m_mysys.SetCLayer(_T("CRSC_SJY_XTS_SXT_DLJL_XHJ"), 6) ;
	m_iColorIndexCur = 256 ;


	CString strSql ;
	strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleXhj) ;
	CString strXhjBlkName, strDevName ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_block"), strXhjBlkName) ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), strDevName) ;
	CStringArray strArrayXhjBlkName ;
	CBlkUtility::DivideString(strXhjBlkName, _T("_"), strArrayXhjBlkName) ;
	CString strXhjType, strLightUnit, strIndicatorNum, strZorF, strGorA ;

	if (strArrayXhjBlkName.GetCount()==8) //有前面导入时的筛选，这步应能确保是标准块
	{
		strXhjType = strArrayXhjBlkName.GetAt(1) ;
		strLightUnit = strArrayXhjBlkName.GetAt(2) ;
		strIndicatorNum = strArrayXhjBlkName.GetAt(3) ;
		strZorF = strArrayXhjBlkName.GetAt(5) ;
		strGorA = strArrayXhjBlkName.GetAt(6) ;		
	}
	AcGePoint3d pt_3d_clonexhj ;
	double dAngleCloneXhj = 0 ;
	double dOffsetBox = 9 ;
	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandleCloneXhj, pEnt, AcDb::kForRead))
	{
		AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
		AcDbExtents extCloneXhj ;
		pRef->getGeomExtents(extCloneXhj) ;
		if (extCloneXhj.maxPoint().y-extCloneXhj.minPoint().y>6.5)
		{
			dOffsetBox = 13 ;
		}
		pt_3d_clonexhj = pRef->position() ;
		dAngleCloneXhj = pRef->rotation() ;
		pEnt->close() ;
	}

	//箱盒类型
	CString strBoxType, strBoxType1, strBoxType2 ;
	//default
	CString strDefaultBox ; //从数据取的该信号机默认箱盒列表（取第一个做默认值）
	strSql.Format(_T("select * from define_default_xhj where block_name='%s'"), strXhjBlkName) ;
	m_RecordSet.GetRecordValue(strSql, _T("box_type"), strDefaultBox) ;
	int iLoc1 = strDefaultBox.Find(_T(";")) ;
	strBoxType = (iLoc1==-1?strDefaultBox:strDefaultBox.Left(iLoc1)) ;
	int iLoc2 = strBoxType.Find(_T("-")) ;
	if (iLoc2!=-1)
	{
		strBoxType1 = strBoxType.Left(iLoc2) ;
		strBoxType2 =strBoxType.Right(strBoxType.GetLength()-iLoc2-1) ;
	}
	else
	{
		strBoxType1 = strBoxType ;
	}

	//是否已实际设置
	CString strBoxTypeSet ;
	if (m_mysys.GetXdata(nHandleXhj, _T("BOXTYPE"), strBoxTypeSet))
	{
		int iLoc3 = strBoxTypeSet.Find(_T("-")) ;
		if (iLoc3!=-1)
		{
			strBoxType1 = strBoxTypeSet.Left(iLoc3) ;
			strBoxType2 =strBoxTypeSet.Right(strBoxTypeSet.GetLength()-iLoc3-1) ;
		}
		else
		{
			strBoxType1 = strBoxTypeSet ;
			strBoxType2 = _T("") ;
		}
	}

	AcGePoint3d pt_3d_insert = pt_3d_clonexhj ;
	pt_3d_insert.y = pt_3d_clonexhj.y+(strZorF==_T("Z")?dOffsetBox:-dOffsetBox) ;
	CString strBlkName ;
	CStringArray strArrayAtt ;

	AcDbBlockReference* pRef = NULL ;	

	//XB1
	long nHandleXB1 = 0 ;
	strBlkName.Format(_T("BOX_%s_0"), strBoxType1.Left(2)) ;
	CString strAtt ;
	if (strBoxType1.Left(2)==_T("XB"))
	{
		strAtt = strBoxType1 ;
	}
	else if (strBoxType1.Left(2)==_T("HZ"))
	{
		strAtt = strBoxType1.Right((strBoxType1.GetLength()>2?strBoxType1.GetLength():2)-2) ;
	}
	strArrayAtt.Add(strAtt) ;
	if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_insert, &strArrayAtt, FALSE ))
	{
		//增加属性盒子编号，以便做径路图
		if (!strBoxType2.IsEmpty())
		{
			AcGePoint3d pt_3d_att = pt_3d_insert ;
			pt_3d_att.y+=2.6 ;
			m_mysys.AddAttValue(pRef, _T("BOXINDEX"), _T("II"), pt_3d_att, 0, FALSE, 1, 1, 0, 256 ) ;
		}
		m_mysys.RotationEnt(pRef, dAngleCloneXhj, pt_3d_clonexhj) ;
		m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleXhj) ;
		m_mysys.SetXdata(pRef, _T("BOX_INDEX"), 1) ;
		m_mysys.SetXdata(pRef, _T("BOX_SUM"), strBoxType2.IsEmpty()?1:2) ;

		nHandleXB1 = m_mysys.GetHandle(pRef) ;
		pRef->close() ;
	}
	if (!strBoxType2.IsEmpty())
	{
		strArrayAtt.RemoveAll() ;
		strAtt = _T("") ;
		if (strBoxType2.Left(2)==_T("XB"))
		{
			strAtt = strBoxType2 ;
		}
		else if (strBoxType2.Left(2)==_T("HZ"))
		{
			strAtt = strBoxType2.Right((strBoxType2.GetLength()>2?strBoxType2.GetLength():2)-2) ;
		}
		strArrayAtt.Add(strAtt) ;
		AcGePoint3d pt_3d_insert2 = pt_3d_insert ;
		pt_3d_insert2.x+=15 ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_insert2, &strArrayAtt, FALSE ))
		{
			//增加属性盒子编号，以便做径路图
			AcGePoint3d pt_3d_att = pt_3d_insert2 ;
			pt_3d_att.y+=2.6 ;
			m_mysys.AddAttValue(pRef, _T("BOXINDEX"), _T("I"), pt_3d_att, 0, FALSE, 1, 1, 0, 256 ) ;

			m_mysys.RotationEnt(pRef, dAngleCloneXhj, pt_3d_clonexhj) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleXhj) ;
			m_mysys.SetXdata(pRef, _T("BOX_INDEX"), 2) ;
			m_mysys.SetXdata(pRef, _T("BOX_SUM"), 2) ;
			pRef->close() ;
		}
		//连线
		AcGePoint3d pt_3d_start = pt_3d_insert ;
		pt_3d_start.x+=2.5 ;
		AcGePoint3d pt_3d_end = pt_3d_start ;
		pt_3d_end.x+=10 ;
		AcDbObjectId objIdLine = m_mysys.AddAcDbPolyLine(pt_3d_start, pt_3d_end, 0, 0, 256) ;
		long nHandleCable = 0 ;
		nHandleCable = m_mysys.GetHandle(objIdLine) ;
		m_mysys.SetXdata(objIdLine, _T("BELONG_ENT"), nHandleXB1) ;
		m_mysys.SetXdata(nHandleCable, _T("IS_CABLE"), 1) ;
		m_mysys.RotationEnt(objIdLine, dAngleCloneXhj, pt_3d_clonexhj) ;
		//电缆信息
		CString strDevType ;
		strDevType.Format(_T("XHJB_%s_%s_%s-%s"), strArrayXhjBlkName.GetAt(2), strArrayXhjBlkName.GetAt(4), strBoxType1, strBoxType2) ;
		vector<CCableCore> vec ;
		int iNumCore=0, iBackup = 0 ;
		CBoxNodeEnt boxNode(strBoxType1, strDevName, strDevType, 1) ;
		boxNode.m_iEntType = 1 ;
// 		boxNodeXhj.m_strDevType = strDevType ;
// 		boxNodeXhj.m_strDevName = strDevName ;
		iNumCore = this->GetDevCore(boxNode) ;		
		CString strCableTypeName ;
		this->GetUseCableType(iNumCore, 0, iBackup, strCableTypeName, 1 ) ;
		CString strCableInfo ;
		strCableInfo.Format(_T("10-%s(%d)"), strCableTypeName, iBackup) ;

		this->DrawCableString(nHandleCable, strCableInfo) ;
		CString strAppNames[7] = {_T("DIST1"), _T("DIST2"), _T("CROSSGD"),  _T("BOXNUM"), _T("PLUS"), _T("BOXFNUM"), _T("INTOXHL")} ;
		long iDatas[7] = {0, 0, 0, 2, 0, 0, 0} ;
		for (int i=0; i<7; i++)
		{
			m_mysys.SetXdata(nHandleCable, strAppNames[i], iDatas[i]) ;
		}	
	}
	m_pDb->setClayer(ojbIdLayerOld) ; //恢复当前图层
}

// 绘制所有信号机盒子
void CZnSxt::DrawBoxXhj(void)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=1 ")) ; //整除为1的
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;
				this->DrawBoxXhj(nHandle) ;
				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in DrawBoxXhj"));
	}
}

// 绘制ZZJ箱盒
void CZnSxt::DrawBoxZzj(AcDbBlockReference* pRefJxg, const CDcDATA* pDataDc, int iQyIndex, int iDcDirectH)
{
	if (pRefJxg!=NULL)
	{ 	
		CStringArray strArrayAtt ;
		CString strBlkName = _T("BOX_HZ_0") ;
		double dOffsetBox = 1.0 ;

		long iIsJxg = 1 ;
		m_mysys.GetXdata(pRefJxg, _T("IS_JXG"), iIsJxg) ;
		CString strQyType = (iIsJxg==1?pDataDc->m_strJG_QyType:pDataDc->m_strXG_QyType);
		int nQyNum = (iIsJxg==1?pDataDc->m_nJG_QyNum:pDataDc->m_nXG_QyNum);

		long nHandleCurJxg = m_mysys.GetHandle(pRefJxg) ;

		double dAngle = pRefJxg->rotation() ;
		AcGePoint3d pt_3d_ref = pRefJxg->position() ;
		AcGePoint3d pt_3d_box ;
		m_mysys.GetPoint(pt_3d_ref, 15, dAngle+PI/2, pt_3d_box) ;

		long nHandleBox = 0 ; //记录绘制的箱盒的handle，后面连线的belong设置会用

		double dAngleFmod = fmod(dAngle, PI) ;
		if (abs(dAngleFmod-PI)<0.1) //3.14、3.15角度基本一样
		{
			dAngleFmod = 0 ;
		}

		//大于1个盒子则间距设为dOffsetBox
		if (nQyNum>1)
		{
			AcGePoint3d pt_3d_boxTmp = pt_3d_box ;
			int iQyIndexReverse = (iDcDirectH==0?iQyIndex:(nQyNum-iQyIndex-1)) ;


			if (iQyIndexReverse<(nQyNum/2)) //统一左移
			{
				m_mysys.GetPoint(pt_3d_box, dOffsetBox*(nQyNum/2-iQyIndexReverse-(nQyNum%2==0?0.5:0)), dAngleFmod+PI, pt_3d_boxTmp) ;					
			}
			else if (iQyIndexReverse>(nQyNum/2-1+nQyNum%2))//统一右移
			{
				m_mysys.GetPoint(pt_3d_box, dOffsetBox*(iQyIndexReverse-nQyNum/2+(nQyNum%2==0?0.5:0)), dAngleFmod, pt_3d_boxTmp) ;
			}
			pt_3d_box = pt_3d_boxTmp ;
		}

		strArrayAtt.RemoveAll() ;
		strArrayAtt.Add(pDataDc->m_strBoxType.Mid(2)) ;
		AcDbBlockReference* pRef = NULL ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_box, &strArrayAtt, FALSE ))
		{
			//m_mysys.SetXdata(pRef, _T("BELONG_DC"), nHandleDc) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleCurJxg) ;
			nHandleBox = m_mysys.GetHandle(pRef) ;
			pRef->close() ;
			pRef = NULL ;
		}

		//若>1机牵引，且串联，先预先把这几机盒子连起来
		if (iQyIndex>0)
		{
			CString strCableString ;
			CString strJxgType ;

			if (strQyType==_T("ZD6-EJ"))
			{
				if (m_mysys.GetAttValue(pRefJxg, _T("TYPE"), strJxgType)&&strJxgType==_T("ZD6-J"))
				{
					strCableString = _T("15-14(3)") ;
					if (m_iQkNum==1)
					{
						strCableString = _T("15-16(3)") ;
					}
				}
			}
			else if (strQyType.Left(8)==_T("ZYJ7+SH6"))
			{
				if (m_mysys.GetAttValue(pRefJxg, _T("TYPE"), strJxgType)&&strJxgType==_T("SH6"))
				{
					strCableString = _T("15-16(4)") ;
					if (m_iQkNum==1)
					{
						strCableString = _T("15-16(2)") ;
					}
				}
			}

			if (!strCableString.IsEmpty())
			{
				AcGePoint3d pt_3d_start, pt_3d_end ;
				m_mysys.GetPoint(pt_3d_box, iDcDirectH==1?1.5:-1.5, dAngleFmod, pt_3d_start) ;
				m_mysys.GetPoint(pt_3d_box, iDcDirectH==1?2.5:-2.5,  dAngleFmod, pt_3d_end) ;
				AcDbObjectId ojbIdLine = m_mysys.AddAcDbPolyLine(pt_3d_start, pt_3d_end) ;
				m_mysys.SetXdata(ojbIdLine, _T("BELONG_ENT"),  nHandleBox) ;
				long nHandleLine = m_mysys.GetHandle(ojbIdLine) ;
				this->DrawCableString(nHandleLine, strCableString) ;

				CString strAppNames[8] = {_T("IS_CABLE"), _T("DIST1"), _T("DIST2"), _T("CROSSGD"),  _T("BOXNUM"), _T("PLUS"), _T("BOXFNUM"), _T("INTOXHL")} ;
				long iDatas[8] = {1, 0, 0, 0, 2, 0, 0, 0} ;
				for (int i=0; i<8; i++)
				{
					m_mysys.SetXdata(nHandleLine, strAppNames[i], iDatas[i]) ;
				}
			}            
		}
	}
}

// 取得clone信号机
int CZnSxt::GetCloneXhj(long nHandleXhj, long& nHandleCloneXhj)
{
	int iRet = 0 ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(RTDXF0, _T("INSERT"), 1001, _T("CloneFrom"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		long nHandle = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			long nHandleCloneFrom = 0 ;
			m_mysys.GetXdata(pEnt, _T("CloneFrom"), nHandleCloneFrom) ;
			if (nHandleCloneFrom==nHandleXhj)
			{
				nHandleCloneXhj = nHandle ;
				iRet++ ;
			}
			pEnt->close() ;
		}		
	}
	return iRet;
}

// 计算并绘制电缆信息
void CZnSxt::ComputeCableInfo(long nHandleBoxStart, long nHandleBoxEnd, long nHandleCable,  int iJigType)
{
// 	if (nHandleBoxStart==148096)
// 	{
// 		int iii = 0 ;
// 	}
	long nHandleCableString = 0 ; //电缆（箱盒之间的多段线）对应的文本
	this->GetCableString(nHandleCable, nHandleCableString, 0) ;
	CString strCableString ;
	if (nHandleCableString!=0)
	{
		m_mysys.GetTextString(nHandleCableString, strCableString) ;
	}

	long nHandleCableName = 0 ;
	this->GetCableString(nHandleCable, nHandleCableName, 2) ;
	CString strCableName ;
	if (nHandleCableName!=0)
	{
		m_mysys.GetTextString(nHandleCableName, strCableName) ;
	}

	long nHandleCableSn = 0 ;
	this->GetCableString(nHandleCable, nHandleCableSn, 3) ;
	CString strCableSn ;
	if (nHandleCableSn!=0)
	{
		m_mysys.GetTextString(nHandleCableSn, strCableSn) ;
	}

	CCableInfoDlg dlg ;

	//2个连接盒子距信号楼的距离
	long iDIST1=0, iDIST2=0, iDIST=0 ;
// 	if (!m_mysys.GetXdata(nHandleCable, _T("DIST1"), iDIST1))
// 	{
		iDIST1 = this->GetBoxDistToXhl(nHandleBoxStart) ;
// 	}
// 	if (!m_mysys.GetXdata(nHandleCable, _T("DIST2"), iDIST2))
// 	{
		iDIST2 = this->GetBoxDistToXhl(nHandleBoxEnd) ;
// 	}
	iDIST = abs(iDIST1-iDIST2) ;
	dlg.m_nArrayData.Add(iDIST1) ;
	dlg.m_nArrayData.Add(iDIST2) ;

	//过股
	long iNumCrossGd = 0 ;
// 	if (!m_mysys.GetXdata(nHandleCable, _T("CROSSGD"), iNumCrossGd))
// 	{
		CLongArray nArrayHandleGd ;
		iNumCrossGd = this->GetCrossGd(nHandleCable, nArrayHandleGd) ;

		//其他
		long iIsXhlCable = 0 ;
		if (m_mysys.GetXdata(nHandleBoxEnd, _T("IS_XHLCABLE"), iIsXhlCable))
		{
			long iNumCrossGd2 = 0  ;
			if (m_mysys.GetXdata(nHandleBoxEnd, _T("CROSSGD_CABLE"), iNumCrossGd2))
			{
				iNumCrossGd+=iNumCrossGd2 ;
			}
		}
// 	}
	dlg.m_nArrayData.Add(iNumCrossGd) ;

	//箱盒
	long iNumBox = 2 ;
// 	if (!m_mysys.GetXdata(nHandleCable, _T("BOXNUM"), iNumBox))
// 	{		
// 		long iIsXhlCable = 0 ;
// 		if (m_mysys.GetXdata(nHandleBoxEnd, _T("IS_XHLCABLE"), iIsXhlCable))
		if (iIsXhlCable>0)
		{
			iNumBox =1 ;
		}
// 	}
	dlg.m_nArrayData.Add(iNumBox) ;

	//修正
	long iNumPlus = 0 ;
	m_mysys.GetXdata(nHandleCable, _T("PLUS"), iNumPlus) ;
	dlg.m_nArrayData.Add(iNumPlus) ;

	//进楼
	long iIntoXhl = 0 ;
// 	if (!m_mysys.GetXdata(nHandleCable, _T("INTOXHL"), iIntoXhl))
// 	{
// 		long iIsXhlCable = 0 ;
// 		if (m_mysys.GetXdata(nHandleBoxEnd, _T("IS_XHLCABLE"), iIsXhlCable))
		if (iIsXhlCable>0)
		{
			long iIntoXhlTmp = 0 ;
			if(m_mysys.GetXdata(nHandleBoxEnd, _T("INTOXHL_CABLE"), iIntoXhlTmp) )
			{
				iIntoXhl = iIntoXhlTmp ;
			}			
		}
// 	}
	dlg.m_nArrayData.Add(iIntoXhl) ;

	//接续盒 ，接续本来要放到进楼前面，但是接续要推算，故放到最后，但是在数组里面插入位置仍在进楼前
	long iNumBoxF = 0 ;
// 	if (!m_mysys.GetXdata(nHandleCable, _T("BOXFNUM"), iNumBoxF))
// 	{
		int iLen1 =(iDIST+iNumCrossGd*dlg.m_iPerGd+(iNumCrossGd>1?(iNumCrossGd-1)*dlg.m_iPerBetweenGd:0)+iNumBox*dlg.m_iPerBox+iNumPlus+iIntoXhl) * dlg.m_dCoefficient ;
		int iNumBoxF1 = iLen1/dlg.m_iPerBetweenBoxF ;
		iNumBoxF = iNumBoxF1 ;
		int iLen2 = (iDIST+iNumCrossGd*dlg.m_iPerGd+(iNumCrossGd>1?(iNumCrossGd-1)*dlg.m_iPerBetweenGd:0)+iNumBox*dlg.m_iPerBox+iNumPlus+iNumBoxF1*dlg.m_iPerBoxF+iIntoXhl) * dlg.m_dCoefficient ;
		int iNumBoxF2 = iLen2/dlg.m_iPerBetweenBoxF ;
		if (iNumBoxF2>iNumBoxF1)
		{
			iNumBoxF = iNumBoxF2 ;
		}
// 	}
	dlg.m_nArrayData.InsertAt(5, iNumBoxF) ;


	//计算此盒子容纳的电缆芯线
// 	m_iCurDljlType = -1 ; //reset当前进行的径路类型 -1：通用（混合），0：道岔，1，信号机，2：轨道电路, 3:电码化

	sequential_tree<CBoxNodeEnt> cableBoxTree ;
	this->BuildCableBoxTree(nHandleBoxStart, nHandleCable, cableBoxTree) ;
	long iLenForPlus =0 ;
	if (!m_mysys.GetXdata(nHandleCable, _T("LENFORPLUS"), iLenForPlus))
	{
		int iLen1 = (abs(iDIST1)+iNumCrossGd*dlg.m_iPerGd+(iNumCrossGd>1?(iNumCrossGd-1)*dlg.m_iPerBetweenGd:0)+iNumBox*dlg.m_iPerBox+iNumPlus+iNumBoxF*dlg.m_iPerBoxF+iIntoXhl) * dlg.m_dCoefficient ;
		iLenForPlus = (iLen1/10)*10+((iLen1%10)<5?5:10) ; //此处是用以初步计算转辙机加芯，该距离是当前距信号楼距离，不是前后箱盒距离
	}
	dlg.m_iLenForPlus = iLenForPlus ;
	//CString strCableTypeAndBackup ;

	CString strCableTypeName ;
	int iBackup = 0 ;

	int iNumCore = this->GetCableCoreNum(cableBoxTree, strCableTypeName, iBackup, iLenForPlus) ; 
// 	int iFind1 = strCableTypeAndBackup.Find(_T("(")) ;
// 	int iFind2 = strCableTypeAndBackup.Find(_T(")")) ;
// 	if (iFind1!=-1)
// 	{
		CBoxNodeEnt boxNode ;
		this->GetBoxInfo(nHandleBoxStart, boxNode) ;
		int iLen3 = (abs(iDIST)+iNumCrossGd*dlg.m_iPerGd+(iNumCrossGd>1?(iNumCrossGd-1)*dlg.m_iPerBetweenGd:0)+iNumBox*dlg.m_iPerBox+iNumPlus+iNumBoxF*dlg.m_iPerBoxF+iIntoXhl) * dlg.m_dCoefficient ;
		int iLenBetweenBox = (iLen3/10)*10+((iLen3%10)<5?5:10) ; //前后箱盒距离

// 		strCableTypeName = strCableTypeAndBackup.Left(iFind1) ;
		if (boxNode.m_iEntType==-1||iLenBetweenBox>400)
		{
			strCableTypeName.Append(_T("L")) ;
		}
// 		iBackup = _ttoi(strCableTypeAndBackup.Mid(iFind1+1, iFind2-iFind1-1)) ;
// 	}	

	dlg.m_strCableOld = strCableString ;
	dlg.m_strCableIntoXhlName = strCableName ;
	dlg.m_strCableSn = strCableSn ;
	dlg.m_strCableTypeName = strCableTypeName ;
	dlg.m_nBackup = iBackup ;
	dlg.m_grid.m_vecCableCore =cableBoxTree.get()->m_vecCableCore ;
	
	if(dlg.DoModal()==IDOK)
	{
		this->SetCableString(nHandleCable, nHandleCableString, dlg.m_strCableAll, 0) ;
		if (iJigType!=2)
		{
			this->SetCableString(nHandleCable, nHandleCableSn, dlg.m_strCableSn, 1) ;
		}
		else if (iJigType==2) // 0，箱盒之间的电缆；1，信号楼主电缆；2，起始连接盒子，末端连在信号楼主电缆
		{
			this->SetCableName(nHandleCable, nHandleCableName, dlg.m_strCableIntoXhlName) ;
		}
		CString strAppNames[8] = {_T("DIST1"), _T("DIST2"), _T("CROSSGD"),  _T("BOXNUM"), _T("PLUS"), _T("BOXFNUM"), _T("INTOXHL"), _T("LENFORPLUS")} ;
		for (int i=0; i<8; i++)
		{
			int iData = (i==7?dlg.m_iLenForPlus:	dlg.m_nArrayData.GetAt(i) ) ;
			m_mysys.SetXdata(nHandleCable, strAppNames[i], (long)iData) ;
		}		
	}
}

// 通过电缆多线段的handle取得其连接字符串,iType=2时是电缆name,=3时是电缆编号
int CZnSxt::GetCableString(long nHandleCableLine, long& nHandleCableString, int iType)
{
	int iRet = 0 ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	if (iType==3)
	{
		pRb = acutBuildList(RTDXF0,_T("TEXT"), kDxfRegAppName, _T("BELONG_ENT"), kDxfRegAppName, _T("IS_CABLESN"), 0) ;
	}
	else if (iType==2)
	{
		pRb = acutBuildList(RTDXF0,_T("TEXT"), kDxfRegAppName, _T("BELONG_ENT"), kDxfRegAppName, _T("IS_CABLENAME"), 0) ;
	}
	else
	{
		pRb = acutBuildList(RTDXF0,_T("TEXT"), kDxfRegAppName, _T("BELONG_ENT"), kDxfRegAppName, _T("IS_CABLEINFO"), 0) ;
	}
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		long nHandleTmp = 0 ;
		if (m_mysys.GetXdata(nArrayHandle.GetAt(i), _T("BELONG_ENT"), nHandleTmp ))
		{
			if (nHandleTmp == nHandleCableLine)
			{
				nHandleCableString = nArrayHandle.GetAt(i) ;
				//
				iRet++ ;
			}
		}
	}

	return iRet ;
}

// 获取盒子距信号楼距离
int CZnSxt::GetBoxDistToXhl(long nHandleBox)
{
	int iDist = 0 ;

	CString strSql ;
	long nHandleBelong = 0 ; 
	if (m_mysys.GetXdata(nHandleBox, _T("IS_XHLCABLE"), nHandleBelong))
	{
		iDist = 0 ;
	}
	else if(m_mysys.GetXdata(nHandleBox, _T("BELONG_ENT"), nHandleBelong))
	{
		//默认是信号机
		long nHandleTmp = 0 ;
		CString strBoxBelongBlkName ;
		if (m_mysys.GetXdata(nHandleBox, _T("BELONG_JYJ"), nHandleTmp)&&nHandleTmp>0) //送受电
		{
			nHandleBelong = nHandleTmp ;
		}
		else if (m_mysys.GetBlockName(nHandleBelong, strBoxBelongBlkName )&&strBoxBelongBlkName.Left(3)==_T("ZZJ")) //转辙机
		{
			 if(m_mysys.GetXdata(nHandleBelong, _T("BELONG_ENT"), nHandleTmp))
			 {
				 nHandleBelong = nHandleTmp ;
			 }
		}
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleBelong) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_toxhldist"), iDist) ;
	}
	else //分向盒
	{
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandleBox, pEnt,AcDb::kForRead))
		{
			AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
			int iDistToXhl = 0 ;
			CString strDistToXhl ;
			if(m_mysys.GetAttValue(pRef, _T("DIST"), strDistToXhl) )
			{
				CString strReg = _T("^([1-9]+[0-9]*)$") ;
				if (CBlkUtility::IsStrMatch(strReg, strDistToXhl))
				{
					CString strRet ;
					CBlkUtility::RegReplace(strReg, _T("$1"), strDistToXhl, strRet) ;
					iDist = _ttoi(strRet) ;
					
				}
			}			
			pEnt->close() ;
		}
	}
	return abs(iDist) ;
}

// 电缆穿过的轨道
int CZnSxt::GetCrossGd(long nHandleCable, CLongArray& nArrayHandleGd)
{
	int iRet = 0 ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(RTDXF0,_T("LWPOLYLINE"), kDxfRegAppName, _T("CloneFrom"), kDxfRegAppName, _T("UPDOWN"), 0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandleCable, pEnt, AcDb::kForRead))
	{
		AcDbPolyline* pPlineCable = AcDbPolyline::cast(pEnt) ;

		for(int i=0; i<nLen; i++)
		{
			AcDbEntity* pEnt2 = NULL ;
			if (m_mysys.OpenAcDbEntity(nArrayHandle.GetAt(i), pEnt2, AcDb::kForRead))
			{
				int iUPDOWN = 0 ;
				m_mysys.GetXdata(pEnt2, _T("UPDOWN"), iUPDOWN) ;
				if (iUPDOWN==1)
				{
					AcGePoint3dArray pt3dArray ;
					pPlineCable->intersectWith(pEnt2, AcDb::kOnBothOperands, pt3dArray) ;
					if (pt3dArray.length()>0)
					{
						nArrayHandleGd.Add(nArrayHandle.GetAt(i)) ;
						iRet++;
					}
				}

				pEnt2->close() ;
			}
		}
		pEnt->close() ;
	}

	return iRet;
}

// 设置电缆字符串，若nHandleCableString=0，则需要创建一个文本对象
int CZnSxt::SetCableString(long nHandleCableLine, long nHandleCableString, CString& strCableString, int iStringType)
{
	if (nHandleCableString<1)
	{
		AcDbEntity* pEnt = NULL ;
		if(m_mysys.OpenAcDbEntity(nHandleCableLine, pEnt, AcDb::kForRead))
		{
			this->DrawCableString(nHandleCableLine, strCableString, iStringType) ;		
			pEnt->close() ;
		}
	}
	else
	{
		AcDbEntity* pEnt = NULL ;
		if(m_mysys.OpenAcDbEntity(nHandleCableString, pEnt, AcDb::kForWrite))
		{
			AcDbText* pText = AcDbText::cast(pEnt) ;
			pText->setTextString(strCableString) ;
			pEnt->close() ;
		}
	}
	return 0;
}

// 设置电缆名称,只有如楼端有
int CZnSxt::SetCableName(long nHandleCableLine, long nHandleCableName, CString& strCableName)
{
	if (nHandleCableName<1)
	{
		AcDbEntity* pEnt = NULL ;
		if(m_mysys.OpenAcDbEntity(nHandleCableLine, pEnt, AcDb::kForRead))
		{
			AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
			int iNumVert = pPolyLine->numVerts() ;
			AcGeLineSeg3d lineSeg ;
			pPolyLine->getLineSegAt(iNumVert-2, lineSeg) ;
			AcGeVector3d vec = lineSeg.direction() ;
			AcGePoint3d pt_3d_end = lineSeg.endPoint() ;
			AcGePoint3d pt_3d_text ;
			m_mysys.GetPoint(pt_3d_end, 1.5, vec.angleOnPlane(AcGePlane::kXYPlane), pt_3d_text) ;
			AcDbObjectId objId ;
			if (strCableName.IsEmpty())
			{
				strCableName = _T("XX-XX#") ;
			}
			m_mysys.AddText(objId, strCableName, pt_3d_text, pt_3d_text, AcDb::kTextMid, AcDb::kTextBase, 2, 0.7, vec.angleOnPlane(AcGePlane::kXYPlane)-PI/2, 256) ;
			this->SetLayer(objId, m_iCurDljlType) ;
			m_mysys.SetXdata(objId, _T("IS_CABLENAME"), 1) ;
			m_mysys.SetXdata(objId, _T("BELONG_ENT"), nHandleCableLine) ;
			pEnt->close() ;
		}
	}
	else
	{
		AcDbEntity* pEnt = NULL ;
		if(m_mysys.OpenAcDbEntity(nHandleCableName, pEnt, AcDb::kForWrite))
		{
			AcDbText* pText = AcDbText::cast(pEnt) ;
			pText->setTextString(strCableName) ;
			pEnt->close() ;
		}
	}
	return 0;
}

// 从信号楼出来的主电缆，各分向盒出来的电缆连上次电缆等同于连到信号楼
void CZnSxt::ComputeCableInfo(long nHandleCable)
{
	CAcModuleResourceOverride myResources ; 

	CLongArray nArrayHandleGd ;
	int iNumCrossGd = this->GetCrossGd(nHandleCable, nArrayHandleGd) ;

	CXhlCableInfoDlg dlg ;
	dlg.m_iCrossGd = iNumCrossGd ;
	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandleCable, pEnt, AcDb::kForRead))
	{
		dlg.m_pEnt = pEnt ;
        dlg.DoModal() ;

		pEnt->close() ;
	}
}

// 读取径路图到数据库
void CZnSxt::ReadJltToDb(void)
{
	CString strSql ;

	m_AdoDb.ClearTable(_T("cablenet_ent")) ;

	CLongArray nArrayHandleCable[2] ;
	this->GetCable(nArrayHandleCable) ;

	int nSumCable = 0 ;
	nSumCable = nArrayHandleCable[1].GetCount() ;
	acutPrintf(_T("\n电缆:%d根"), nSumCable) ;

	int nSumXhlCable = 0 ;
	nSumXhlCable = nArrayHandleCable[0].GetCount() ;
	acutPrintf(_T("\n信号楼电缆:%d根"), nSumXhlCable) ;

	for (int i=0; i<nSumXhlCable; i++)
	{
		AcDbEntity* pEntXhlCable = NULL ;
		long nHandleXhlCable = nArrayHandleCable[0].GetAt(i) ;
		if (m_mysys.OpenAcDbEntity(nHandleXhlCable, pEntXhlCable, AcDb::kForRead))
		{
			AcDbPolyline* pPolyLineXhlCable = AcDbPolyline::cast(pEntXhlCable) ;
			AcGePoint3d pt_3d_start_xhlcable, pt_3d_end_xhlcable ;
			pPolyLineXhlCable->getStartPoint(pt_3d_start_xhlcable) ;
			pPolyLineXhlCable->getEndPoint(pt_3d_end_xhlcable) ;
			//acutPrintf(_T("\n主缆线：%d, end_point(%.3f, %.3f)"),nHandleXhlCable, pt_3d_end_xhlcable.x, pt_3d_end_xhlcable.y) ;
			int iIsXhlLeftOrRight = (pt_3d_end_xhlcable.x>pt_3d_start_xhlcable.x?1:0) ; //0:左侧,1:右侧

			for (int j=0; j<nSumCable; j++)
			{
				AcDbEntity* pEntCable = NULL ;
				long nHandleCable = nArrayHandleCable[1].GetAt(j) ;
				if (m_mysys.OpenAcDbEntity(nHandleCable, pEntCable, AcDb::kForRead))
				{
					AcDbPolyline* pPolyLineCable = AcDbPolyline::cast(pEntCable) ;
					AcGePoint3d pt_3d_start_cable, pt_3d_end_cable ;
					pPolyLineCable->getStartPoint(pt_3d_start_cable) ;
					pPolyLineCable->getEndPoint(pt_3d_end_cable) ;
					UINT nVertexIndex_Start = -1, nVertexIndex_End = -1 ;		
					int iIsPtOnPline_Start = -1, iIsPtOnPline_End = -1 ;
					iIsPtOnPline_Start = m_mysys.IsPointOnPolyLine(pPolyLineXhlCable, pt_3d_start_cable, nVertexIndex_Start, 0.25) ;
					iIsPtOnPline_End = m_mysys.IsPointOnPolyLine(pPolyLineXhlCable, pt_3d_end_cable, nVertexIndex_End, 0.25) ;
					if ((iIsPtOnPline_Start!=-1&&iIsPtOnPline_End==-1) || (iIsPtOnPline_Start==-1&&iIsPtOnPline_End!=-1))
					{					
						//acutPrintf(_T("\n连接到主缆的线：%d, start_point(%.3f, %.3f), end_point(%.3f, %.3f)"),nHandleCable, pt_3d_start_cable.x, pt_3d_start_cable.y, pt_3d_end_cable.x, pt_3d_end_cable.y) ;

						CString strCableName ;
						this->GetCableName(nHandleCable, strCableName) ;
						m_strCurNameIntoXhl = strCableName ;
						if (strCableName.GetLength()>1)
						{
							int iTypeJlt = CZnUtility::GetJltType(strCableName.Left(2)) ;
							if (iTypeJlt!=-1)
							{
								m_iCurDljlType = iTypeJlt ;
							}
						}

						CString strBranchIndex = _T("1") ;

						strSql.Format(_T("insert into cablenet_ent(handle_low, devname, dev_for, boxtype, box_block, left_or_right, belong_xhl_handle_low, branch_index) \
										 values(%d,'%s','%s','%s', '%s', %d, %d, '%s')"),\
										 nHandleCable, strCableName, _T("JY1"), _T("XHL"), _T("DZ_XHL_0"), iIsXhlLeftOrRight,  nHandleCable, strBranchIndex) ;
						m_AdoDb.Execute(strSql) ;

						strBranchIndex.AppendFormat(_T("-1")) ;
						this->FindBox(nHandleCable, nHandleCable, nHandleCable, strBranchIndex) ;

						strSql.Format(_T("update cablenet_ent as a, (select left_or_right from cablenet_ent where handle_low=%d) as b set a.left_or_right=b.left_or_right where belong_xhl_handle_low=%d"), nHandleCable, nHandleCable) ;
						m_AdoDb.Execute(strSql) ;
					}

					pEntCable->close() ;
				}
			}
			pEntXhlCable->close() ;
		}
	}
}

int CZnSxt::GetCableName(long nHandleCable, CString& strCableName)
{
	int iRet = 0 ;

	struct resbuf* pRb ;
	int nSum = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(RTDXF0,_T("TEXT"), kDxfRegAppName, _T("IS_CABLENAME"), kDxfRegAppName, _T("BELONG_ENT"), 0) ;
	nSum = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nSum; i++)
	{
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nArrayHandle.GetAt(i), pEnt, AcDb::kForRead))
		{
			long nHandleCableBelong = 0 ;
			if (m_mysys.GetXdata(pEnt, _T("BELONG_ENT"), nHandleCableBelong) )
			{
				if (nHandleCableBelong==nHandleCable)
				{
					AcDbText* pText = AcDbText::cast(pEnt) ;
					strCableName = pText->textString() ;
					iRet = 1 ;
				}
			}
			pEnt->close() ;
		}
	}

	return iRet ;
}

// 循环查询一条线所连接的盒子(从信号楼往末端查询,需要保证在绘径路图电缆时始终从末端往信号楼方向), 20150728改：默认（从根节点往子节点搜）iDirect=0，表示本段线搜寻方向为从末端向始端
void CZnSxt::FindBox(long nHandlePline, long nHandleNextBox, long nHandleBelongXhl, CString& strBranchIndex)
{
	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandlePline, pEnt, AcDb::kForRead))
	{
		AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
		AcGePoint3d pt_3d_start, pt_3d_end ;
		pPolyLine->getStartPoint(pt_3d_start) ;
		pPolyLine->getEndPoint(pt_3d_end) ;

		CLongArray nArrayHandleFindBox_Start, nArrayHandleFindBox_End ;
		long nHandleBoxFind = 0 ;

		int iRetFind_Start =CZnUtility::FindConBox(pt_3d_start, nArrayHandleFindBox_Start) ;
		int iRetFind_End =CZnUtility::FindConBox(pt_3d_end, nArrayHandleFindBox_End) ;
		int iLoc_Start = CBlkUtility::FindLongInArray(nArrayHandleFindBox_Start, nHandleNextBox) ;
		int iLoc_End = CBlkUtility::FindLongInArray(nArrayHandleFindBox_End, nHandleNextBox) ;

		if (nHandleNextBox==nHandleBelongXhl) //连接到主电缆的缆，其一侧连接为主栏，没盒子(此时其信号楼端盒子nHandleNextBox==信号楼端nHandleBelongXhl，其实都是该电缆的nHandlePline)
		{
			if (iRetFind_Start>1&&iRetFind_End==1)
			{
				nHandleBoxFind = nArrayHandleFindBox_Start.GetAt(0) ;
			}
			else if (iRetFind_End>1&&iRetFind_Start==1)
			{
				nHandleBoxFind = nArrayHandleFindBox_End.GetAt(0) ;
			}
			else
			{
				pEnt->close() ;
				acutPrintf(_T("\n连接到主电缆的线缆在线起点或终点（%.3f,%.3f）-（%.3f,%.3f），在非入楼端发现不是1个连接的盒子！"), pt_3d_start.x, pt_3d_start.y ,pt_3d_end.x ,pt_3d_end.y) ;
				return ;
			}
		}
		else
		{
			if (!(iRetFind_Start>1&&iRetFind_End>1))
			{
				pEnt->close() ;
				acutPrintf(_T("\n在线起点和终点（%.3f,%.3f）-（%.3f,%.3f），未同时各发现1个连接的盒子！"), pt_3d_start.x, pt_3d_start.y ,pt_3d_end.x ,pt_3d_end.y) ;
				return ;
			}
			if (iLoc_Start!=-1&&iLoc_End==-1)
			{
				nHandleBoxFind = nArrayHandleFindBox_End.GetAt(0) ;
			}
			else if (iLoc_Start==-1&&iLoc_End!=-1)
			{
				nHandleBoxFind = nArrayHandleFindBox_Start.GetAt(0) ;
			}
			else
			{
				pEnt->close() ;
				acutPrintf(_T("\n在线起点和终点（%.3f,%.3f）-（%.3f,%.3f），未发现合格的连接盒子！"), pt_3d_start.x, pt_3d_start.y ,pt_3d_end.x ,pt_3d_end.y) ;
				return ;
			}
		}

		CBoxNodeEnt boxNode ;
		if (GetBoxInfo(nHandleBoxFind, boxNode ))
		{
			boxNode.m_nHandleCable = nHandlePline ;
			long nHandleCableString = 0 ; //电缆（箱盒之间的多段线）对应的文本
			this->GetCableString(nHandlePline, nHandleCableString) ;
			CString strCableString ;
			if (nHandleCableString!=0)
			{
				m_mysys.GetTextString(nHandleCableString, strCableString) ;
			}

			//begin 补充绘制电缆编号
			long nHandleCableSn = 0 ;
			this->GetCableString(nHandlePline, nHandleCableSn, 3) ;
			CString strCableSn = strBranchIndex.Right(strBranchIndex.GetLength()-2) ;
			strCableSn.Replace(_T('-'), _T('.')) ;
			strCableSn.Insert(0, m_strCurNameIntoXhl.Left(3)) ;
			if (nHandleCableSn==0)
			{
				this->SetCableString(nHandlePline, nHandleCableSn, strCableSn,  1) ;
			}
			else //调试过程发现莫名问题，有一nHandleCableSn为空文本，故增加下面判断处理空文本的语句
			{
				CString strText ;
				if (m_mysys.GetTextString(nHandleCableSn, strText)&&strText.IsEmpty())
				{
					m_mysys.SetTextString(nHandleCableSn, strCableSn) ;
				}
			}
			//end 补充绘制电缆编号

			//将电缆信息存储起来，导入excel供审核
			if (m_iCurJob==1)
			{
				m_strArrayCableSn.Add(strCableSn) ;
				m_strArrayCableAll.Add(strCableString) ;
				CString strAppNames[7] = {_T("DIST1"), _T("DIST2"), _T("CROSSGD"),  _T("BOXNUM"), _T("PLUS"), _T("BOXFNUM"), _T("INTOXHL")} ;
				m_vecCableData.resize(7) ;
				for (int i=0; i<7; i++)
				{
					long nData = 0 ;
					if (m_mysys.GetXdata(nHandlePline, strAppNames[i], nData) )
					{
						int iData = (int)nData ;
						m_vecCableData[i].push_back(iData) ;
						if (i<2)
						{
							acutPrintf(_T("\n%s:DIST%d-%d"), strCableSn, i+1,iData) ;
						}
					}
				}	
			}

			//查询和盒子相连的其他电缆
			CLongArray nArrayHandleFindCableTmp ;
			int iFindCable = this->FindCable(nHandleBoxFind, nHandlePline, nArrayHandleFindCableTmp) ;
			CLongArray nArrayHandleFindCable ;
			for (int i=0; i<iFindCable; i++)
			{
				long iIsCable = 0 ;
				if(m_mysys.GetXdata(nArrayHandleFindCableTmp.GetAt(i), _T("IS_CABLE"), iIsCable)&&iIsCable==1)
				{
					nArrayHandleFindCable.Add(nArrayHandleFindCableTmp.GetAt(i)) ;
				}
			}
			int iIsStart = 0 ;
			iFindCable = nArrayHandleFindCable.GetCount() ;
			if(iFindCable==0)
			{
				iIsStart = 1 ;
			}

			CString strDevFor = _T("JY1") ;
			if (boxNode.m_iEntType==1)
			{
				if (m_iDsNumXhj==1)
				{
					strDevFor = _T("JY3") ;
				}
				if (boxNode.m_strDevBlock.Mid(4,2)==_T("DC")) //调车
				{
					if (m_iDcDsNum==1)
					{
						strDevFor = _T("JY2") ;
					}
					else if (m_iDcDsNum==2)
					{
						strDevFor = _T("JY3") ;
					}
					else
					{
						strDevFor = _T("JY1") ;
					}
				}
			}
			if (boxNode.m_iEntType==0)
			{
				if (m_iQkNum==1)
				{
					strDevFor = _T("JY4") ;
				}
			}

			CString strSql ;
			strSql.Format(_T("insert into cablenet_ent(handle_low, devname, devtype, dev_block, dev_for, boxtype, box_block, next_ent_handle_low, cablestring, is_start, belong_xhl_handle_low, distance_to_xhl, branch_index, zzj_type, zzj_index, freq) \
							 values(%d, '%s', '%s', '%s', '%s', '%s', '%s', %d, '%s', %d, %d, %d, '%s', '%s', '%s', '%s')"),\
							 nHandleBoxFind, boxNode.m_strDevName, boxNode.m_strDevType, boxNode.m_strDevBlock, strDevFor, boxNode.m_strBoxType, boxNode.m_strBoxBlock, nHandleNextBox, strCableString, iIsStart, nHandleBelongXhl, boxNode.m_iDistToXhl, strBranchIndex, boxNode.m_strDragType, boxNode.m_strActIndex, boxNode.m_strFreq) ;
			m_AdoDb.Execute(strSql) ;

			for (int i=0; i<iFindCable; i++)
			{
				CString strBranchIndexTmp ;
				strBranchIndexTmp.Format(_T("%s-%d"), strBranchIndex, i+1 ) ;
				this->FindBox(nArrayHandleFindCable.GetAt(i), nHandleBoxFind, nHandleBelongXhl, strBranchIndexTmp) ;
			}
		}

		pEnt->close() ;
	}
}

// for tree 循环查询一条线所连接的盒子(从信号楼往末端查询,需要保证在绘径路图电缆时始终从末端往信号楼方向) 
void CZnSxt::FindBox(long nHandlePline, long nHandleNextBox, sequential_tree<CBoxNodeEnt>* pSeqTree)
{
	AcDbEntity* pEnt = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandlePline, pEnt, AcDb::kForRead))
	{
		AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
		AcGePoint3d pt_3d_start ;
		pPolyLine->getStartPoint(pt_3d_start) ;
		CLongArray nArrayHandleFindBox ;
		CZnUtility::FindConBox(pt_3d_start, nArrayHandleFindBox) ;
		int iNumFind = nArrayHandleFindBox.GetCount() ;

		int iBoxSum = 0 ;
		for (int iFindIndex=0; iFindIndex<iNumFind; iFindIndex++)
		{
			long nHandleBox = nArrayHandleFindBox.GetAt(iFindIndex) ;

			CBoxNodeEnt boxNode ;
			if (GetBoxInfo(nHandleBox, boxNode ))
			{
				if (iBoxSum==0)
				{
					boxNode.m_nHandleCable = nHandlePline ;
					long nHandleCableString = 0 ;
					if (this->GetCableString(nHandlePline, nHandleCableString) ==1)
					{
						m_mysys.GetTextString(nHandleCableString, boxNode.m_strCableString) ;
					}

					sequential_tree<CBoxNodeEnt>::iterator it = pSeqTree->insert(boxNode) ;
					//查询和盒子相连的其他电缆
					CLongArray nArrayHandleFindCable ;
					int iFindCable = this->FindCable(nHandleBox, nHandlePline, nArrayHandleFindCable) ;
					for (int i=0; i<iFindCable; i++)
					{
						this->FindBox(nArrayHandleFindCable.GetAt(i), nHandleBox, it.node()) ;
					}
				}
				else
				{
					acutPrintf(_T("\n注意：在 %.3f, %.3f 处有不止1个Box！"), pt_3d_start.x, pt_3d_start.y) ;
				}

				iBoxSum++ ;
			}
		}

		pEnt->close() ;
	}
}

// 查找盒子的其他连接电缆
int CZnSxt::FindCable(long nHandleBox, long nHandlePrePline, CLongArray& nArrayHandleFind)
{
	int iRet = 0 ;

	AcDbEntity* pEntBox = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandleBox, pEntBox, AcDb::kForRead))
	{
		if (pEntBox->isKindOf(AcDbBlockReference::desc()))
		{
			AcDbBlockReference* pRef = AcDbBlockReference::cast(pEntBox) ;
			CString strBlkName ;
			m_mysys.GetBlockName(pRef, strBlkName) ;

			AcGePoint3d pt_3d_blk ;
			pt_3d_blk = pRef->position() ;

			AcGePoint3d pt_3d_minmax[2]  ;
			double dBoxWidth = 4 ; //默认是送受电盒子的长度
			if (strBlkName.Left(6)==_T("BOX_XB"))
			{
				dBoxWidth = 5 ;
				for (int i=0; i<2; i++)
				{
					pt_3d_minmax[i].x = pt_3d_blk.x+(i==0?-1:1)*dBoxWidth/2 ;
					pt_3d_minmax[i].y = pt_3d_blk.y+(i==0?-1:1)*2 ;
				}
				iRet = m_mysys.GetConnectLine(pt_3d_minmax[0], pt_3d_minmax[1], nArrayHandleFind, 0.05) ;
			}
			else if (strBlkName.Left(7)==_T("BOX_FSD"))
			{
				dBoxWidth = 4 ;
				for (int i=0; i<2; i++)
				{
					pt_3d_minmax[i].x = pt_3d_blk.x+(i==0?-1:1)*dBoxWidth/2 ;
					pt_3d_minmax[i].y = pt_3d_blk.y+(i==0?-1:1)*1.5 ;
				}
				iRet = m_mysys.GetConnectLine(pt_3d_minmax[0], pt_3d_minmax[1], nArrayHandleFind, 0.05) ;
			}
			else if (strBlkName.Left(6)==_T("BOX_HF"))
			{						
				dBoxWidth = 6 ;
				iRet = m_mysys.GetConnectLine(pt_3d_blk, 3, nArrayHandleFind, 0.05) ;
			}
			else if (strBlkName.Left(6)==_T("BOX_HZ"))
			{						
				dBoxWidth = 3 ;
				iRet = m_mysys.GetConnectLine(pt_3d_blk, 1.5, nArrayHandleFind, 0.05) ;
			}

			for (int i=0; i<iRet; i++)
			{						
				long nHandleFind = nArrayHandleFind.GetAt(i) ;
				if (nHandleFind==nHandlePrePline)
				{
					nArrayHandleFind.RemoveAt(i) ;
					iRet-- ;
					break;
				}
			}
		}
		pEntBox->close() ;
	}

	return iRet ;
}

// 绘制电缆网络图
void CZnSxt::DrawCableNet(void)
{
	double dOffSetX = 20 ;
	double dOffSetY = 20 ;
	double dBaseX = 0 ;

	CADORecordset cSet(&m_AdoDb) ;
	CString strSql ;

	strSql.Format(_T("update cablenet_ent  set pt_x=12345, pt_y=12345")) ;
	m_AdoDb.Execute(strSql) ;

	strSql.Format(_T("select * from cablenet_ent where boxtype='XHL'")) ;
	CLongArray nArrayHandleXhl ;
	int iNumXhl = m_RecordSet.GetRecordValue(strSql, _T("handle_low"), nArrayHandleXhl) ;
	double dYTotal = 0 ;
	for (int i=0; i<iNumXhl; i++)
	{
		long nHandleXhl = nArrayHandleXhl.GetAt(i) ;
		if (nHandleXhl==79470)
		{
			int iiii = 0 ;
		}
		strSql.Format(_T("select * from cablenet_ent where is_start=1 and belong_xhl_handle_low=%d order by branch_index"), nHandleXhl) ;
		if (cSet.Open(strSql))
		{
			int iRsCount = cSet.GetRecordCount() ;

			int iIndex = 0 ;
			while(!cSet.IsEOF())
			{
				CString strName ;
				cSet.GetFieldValue(_T("devname"), strName) ;
				int iLeftOrRight = 0 ;
				cSet.GetFieldValue(_T("left_or_right"), iLeftOrRight) ;
				CString strBranchIndex ;
				cSet.GetFieldValue(_T("branch_index"), strBranchIndex) ; 
				int iNumMark = strBranchIndex.Replace(_T('-'), _T('_')) ;

				double x = dBaseX+(iLeftOrRight==0?-1:1)*iNumMark*dOffSetX ;
				double y =dYTotal- iIndex*dOffSetY ;
				cSet.Edit() ;
				cSet.SetFieldValue(_T("pt_x"), x) ;
				cSet.SetFieldValue(_T("pt_y"), y) ;
				cSet.Update() ;

				cSet.MoveNext() ;

				iIndex++ ;
			}
			dYTotal-=(iRsCount*dOffSetY) ;
			cSet.Close() ;
		}

		do 
		{
			strSql.Format(_T("select * from cablenet_ent where pt_x=12345 and pt_y=12345 and belong_xhl_handle_low=%d"), nHandleXhl) ;
			if (cSet.Open(strSql))
			{
				int iRsCount = cSet.GetRecordCount() ;
				if (iRsCount==0)
				{
					cSet.Close() ;
					break;
				}

				while(!cSet.IsEOF())
				{
					long nHandle = 0 ;
					cSet.GetFieldValue(_T("handle_low"), nHandle) ;
					int iLeftOrRight = 0 ;
					cSet.GetFieldValue(_T("left_or_right"), iLeftOrRight) ;
					strSql.Format(_T("select * from cablenet_ent where next_ent_handle_low=%d"), nHandle) ;
					int iRsCount1 = m_RecordSet.GetRecordCount(strSql) ;
					strSql.Format(_T("select * from cablenet_ent where next_ent_handle_low=%d and pt_x<>12345 and pt_y<>12345"), nHandle) ;
					int iRsCount2 = m_RecordSet.GetRecordCount(strSql) ;
					if (iRsCount1==iRsCount2)
					{
						strSql.Format(_T("select min(pt_y)+(max(pt_y)-min(pt_y))/2 as cur_y from cablenet_ent where next_ent_handle_low=%d"), nHandle) ;
						double dCurY = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("cur_y"), dCurY) ;
						strSql.Format(_T("select * from cablenet_ent where next_ent_handle_low=%d"), nHandle) ;
						double dCurX = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("pt_x"), dCurX) ;
						dCurX+=(iLeftOrRight==0?1:-1)*dOffSetX ;
						cSet.Edit() ;
						cSet.SetFieldValue(_T("pt_y"), dCurY) ;
						cSet.SetFieldValue(_T("pt_x"), dCurX) ;
						cSet.Update() ;
					}

					cSet.MoveNext() ;
				}
				cSet.Close() ;
			}

		} while (TRUE);

		dYTotal-=dOffSetY ;	
	}

	//绘制网络图
	AcDbDatabase* pDbNew = new AcDbDatabase() ;
	CUserSystem mysys ;
	mysys.m_pDb = pDbNew ;

	strSql.Format(_T("select * from cablenet_ent")) ;
	if (cSet.Open(strSql))
	{
		while(!cSet.IsEOF())
		{
			long nHandle = 0 ;
			cSet.GetFieldValue(_T("handle_low"), nHandle) ;
			CString strDevName ;
			cSet.GetFieldValue(_T("devname"), strDevName) ;
			CString strDevBlk ;
			cSet.GetFieldValue(_T("dev_block"), strDevBlk) ;
			CString strBoxType ;
			cSet.GetFieldValue(_T("boxtype"), strBoxType) ;
			CString strBoxBlock ;
			cSet.GetFieldValue(_T("box_block"), strBoxBlock) ;
			int iLeftOrRight = 0 ;
			cSet.GetFieldValue(_T("left_or_right"), iLeftOrRight) ;
			int iDistToXhl = 0 ;
			cSet.GetFieldValue(_T("distance_to_xhl"), iDistToXhl) ;
			long nHandleNext = 0 ;
			cSet.GetFieldValue(_T("next_ent_handle_low"), nHandleNext) ;
			CString strBranchIndex ;
			cSet.GetFieldValue(_T("branch_index"), strBranchIndex) ;
			CString strCableString ;
			cSet.GetFieldValue(_T("cablestring"), strCableString) ;
			CString strFreq ;
			cSet.GetFieldValue(_T("freq"), strFreq) ;

			double x = 0 ;
			double y =0 ;
			cSet.GetFieldValue(_T("pt_x"), x) ;
			cSet.GetFieldValue(_T("pt_y"), y) ;
			CString strName ;
			cSet.GetFieldValue(_T("devname"), strName) ;
			AcGePoint3d pt_3d_box(x,y,0) ;

			CStringArray strArrayVal ;
			AcDbBlockReference* pRef = NULL ;
			double dBoxWidth = 0 ;
			CStringArray strArrayBoxBlock ;
			CBlkUtility::DivideString(strBoxBlock, _T("_"), strArrayBoxBlock) ;
			CString strBoxBlockPart1  ;
			if (strArrayBoxBlock.GetCount()>1)
			{
				strBoxBlockPart1 = strArrayBoxBlock.GetAt(1) ;
			}
			if (strBoxBlockPart1==_T("XHL"))
			{
				strArrayVal.Add(strDevName) ;
				if (mysys.InsertBlock(pRef, strBoxBlock, pt_3d_box, &strArrayVal, FALSE))
				{
					if (iLeftOrRight==0)
					{
						mysys.RotationEnt(pRef, PI, pt_3d_box) ;
					}
					pRef->close() ;
				}
			}
			else if (strBoxBlockPart1==_T("HF"))
			{
				dBoxWidth = 6 ;

				strArrayVal.Add(strDevName) ;
				CString strDistToXhl ;
				m_mysys.GetAttValue(nHandle, _T("DIST"), strDistToXhl) ;
				strArrayVal.Add(strDistToXhl) ;
				m_mysys.GetAttValue(nHandle, _T("HFNUM"), strDevName) ;
				CString strHf ;
				m_mysys.GetAttValue(nHandle, _T("HF"), strHf) ;
				strArrayVal.Add(strHf) ;
				if (mysys.InsertBlock(pRef, strBoxBlock, pt_3d_box, &strArrayVal, FALSE))
				{
					if (iLeftOrRight==0)
					{
						AcGePoint3d pt_3d_boxtmp(pt_3d_box.x, pt_3d_box.y+1, 0) ;
						mysys.MirrEnt(pRef, pt_3d_box, pt_3d_boxtmp) ;
					}
					pRef->close() ;
				}
			}
			else if (strBoxBlockPart1==_T("HZ"))
			{
				CString strZzjType ;
				cSet.GetFieldValue(_T("zzj_type"), strZzjType) ;
				if (strDevBlk.IsEmpty())
				{
					dBoxWidth = 3 ;

					CString strHz ;
					m_mysys.GetAttValue(nHandle, _T("HZ"), strHz) ;
					strArrayVal.Add(strHz) ;
					if (mysys.InsertBlock(pRef, strBoxBlock, pt_3d_box, &strArrayVal, FALSE))
					{
						pRef->close() ;
					}
				}
				else if (strDevBlk.Left(3)==_T("XHJ")) //信号机（调车等）
				{
					dBoxWidth = 3 ;

					CString strHz ;
					m_mysys.GetAttValue(nHandle, _T("HZ"), strHz) ;
					strArrayVal.Add(strHz) ;
					if (mysys.InsertBlock(pRef, strBoxBlock, pt_3d_box, &strArrayVal, FALSE))
					{
						pRef->close() ;
					}

					long nHandleBelongXhj = 0 ;
					m_mysys.GetXdata(nHandle, _T("BELONG_ENT"), nHandleBelongXhj) ;
					if (nHandleBelongXhj>0)
					{
						strArrayVal.RemoveAll() ;

						CString strXhjBlkName ;
						AcDbEntity* pEntXhj = NULL ;
						if (m_mysys.OpenAcDbEntity(nHandleBelongXhj, pEntXhj, AcDb::kForRead))
						{
							AcDbBlockReference* pRefXhj = AcDbBlockReference::cast(pEntXhj) ;
							m_mysys.GetBlockName(pRefXhj, strXhjBlkName) ;
							CString strXhjName ;
							m_mysys.GetAttValue(pRefXhj, _T("XHJNAME"), strXhjName) ;
							strArrayVal.Add(strXhjName) ;
							double dAngleXhj = pRefXhj->rotation() ;
							AcGePoint3d pt_3d_xhj = pt_3d_box ;
							pt_3d_xhj.y=pt_3d_box.y+1.5 ;
							double dAngleXhjNet = 0 ;
							if (dAngleXhj>PI/2&&dAngleXhj<PI*3/2)
							{
								dAngleXhjNet = PI ;
								pt_3d_xhj.y = pt_3d_box.y-1.5 ;
							}

							if (mysys.InsertBlock(pRef, strXhjBlkName, pt_3d_xhj, &strArrayVal, FALSE))
							{
								if (dAngleXhjNet>0)
								{
									mysys.RotationEnt(pRef, PI, pt_3d_xhj) ;
								}
								pRef->close() ;
							}						

							pEntXhj->close() ;
						}
					}
				}
				else if (!strZzjType.IsEmpty()) //转辙机
				{
					dBoxWidth = 6 ;
					CString strBoxBlockTmp = _T("BOX_HZ_ZZJ_0") ;
					strArrayVal.Add(strDevName) ;
					strArrayVal.Add(_T("0")) ;
					CString strZzjIndex ;
					cSet.GetFieldValue(_T("zzj_index"), strZzjIndex) ;
					strArrayVal.Add(strZzjIndex) ;
					strArrayVal.Add(strBoxType) ;
					strArrayVal.Add(strZzjType) ;
					if (mysys.InsertBlock(pRef, strBoxBlockTmp, pt_3d_box, &strArrayVal, FALSE))
					{
						pRef->close() ;
					}		
				}

			}
			else if (strBoxBlockPart1==_T("FSD"))
			{
				dBoxWidth = 4 ;
				CString strBoxBlockPart3 = strArrayBoxBlock.GetAt(3) ;


// 				long nHandleBelong= 0, nHandleBelong2= 0 ;
// 				m_mysys.GetXdata(nHandle, _T("BELONG_ENT"), nHandleBelong) ;
// 				m_mysys.GetXdata(nHandle, _T("BELONG_GD2"), nHandleBelong2) ;
// 				if (nHandleBelong>0)
// 				{
// 					strArrayVal.RemoveAll() ;
// 
// 					CString strGuiDaoName ;
// 					m_mysys.GetXdata(nHandleBelong, _T("GUIDAONAME"), strGuiDaoName) ;
// 					if (nHandleBelong2>0)
// 					{
// 						CString strGuiDaoName2 ;
// 						m_mysys.GetXdata(nHandleBelong2, _T("GUIDAONAME"), strGuiDaoName2) ;
// 						strGuiDaoName.AppendFormat(_T(" %s"), strGuiDaoName2) ;
// 					}
					strArrayVal.Add(strDevName) ;
					if (strBoxBlockPart3==_T("1")) //电码化
					{
						strArrayVal.Add(strFreq) ;
					}					

					if (mysys.InsertBlock(pRef, strBoxBlock, pt_3d_box, &strArrayVal, FALSE))
					{
						pRef->close() ;
					}
// 				}
			}
			else if (strBoxBlockPart1==_T("XB"))
			{
				dBoxWidth = 5 ;

				long iNumXhj = 1 ;
				m_mysys.GetXdata(nHandle, _T("BOX_SUM"), iNumXhj) ;
				long iIndexXhj = 1 ;
				m_mysys.GetXdata(nHandle, _T("BOX_INDEX"), iIndexXhj) ;
				CString strXb ;
				m_mysys.GetAttValue(nHandle, _T("XB"), strXb) ;
				strArrayVal.Add(strXb) ;
				if (mysys.InsertBlock(pRef, strBoxBlock, pt_3d_box, &strArrayVal, FALSE))
				{
					pRef->close() ;
				}

				if (iNumXhj==1||(iNumXhj==2&&iIndexXhj==1)) //多个XB箱，只在第一个XB箱上绘制信号机
				{
					long nHandleBelongXhj = 0 ;
					m_mysys.GetXdata(nHandle, _T("BELONG_ENT"), nHandleBelongXhj) ;
					if (nHandleBelongXhj>0)
					{
						strArrayVal.RemoveAll() ;

						CString strXhjBlkName ;
						AcDbEntity* pEntXhj = NULL ;
						if (m_mysys.OpenAcDbEntity(nHandleBelongXhj, pEntXhj, AcDb::kForRead))
						{
							AcDbBlockReference* pRefXhj = AcDbBlockReference::cast(pEntXhj) ;
							m_mysys.GetBlockName(pRefXhj, strXhjBlkName) ;
							CString strXhjName ;
							m_mysys.GetAttValue(pRefXhj, _T("XHJNAME"), strXhjName) ;
							strArrayVal.Add(strXhjName) ;
							double dAngleXhj = pRefXhj->rotation() ;
							AcGePoint3d pt_3d_xhj = pt_3d_box ;
							pt_3d_xhj.y=pt_3d_box.y+2 ;
							double dAngleXhjNet = 0 ;
							int iFindMark = strXhjBlkName.Find(_T("_Y_")) ; //iFindkMark不为-1说明是逆向信号机
							if (iFindMark!=-1)
							{
								pt_3d_xhj.y = pt_3d_box.y-2 ;
								dAngleXhjNet = 0 ;
								if (dAngleXhj>PI/2&&dAngleXhj<PI*3/2)
								{
									dAngleXhjNet = PI ;
									pt_3d_xhj.y = pt_3d_box.y+2 ;
								}
							}
							else
							{
								if (dAngleXhj>PI/2&&dAngleXhj<PI*3/2)
								{
									dAngleXhjNet = PI ;
									pt_3d_xhj.y = pt_3d_box.y-2 ;
								}
							}

							if (mysys.InsertBlock(pRef, strXhjBlkName, pt_3d_xhj, &strArrayVal, FALSE))
							{
								if (dAngleXhjNet>0)
								{
									mysys.RotationEnt(pRef, PI, pt_3d_xhj) ;
								}
								pRef->close() ;
							}						

							pEntXhj->close() ;
						}
					}
				}
			}

			//箱盒连线
			if (strBoxBlockPart1!=_T("XHL"))
			{				
				AcGePoint3dArray ptArray ;
				AcGePoint3d pt_3d_conline1, pt_3d_conline2, pt_3d_conline3 ; //从当前绘制盒子往信号楼方向绘制连接线
				strSql.Format(_T("select * from cablenet_ent where next_ent_handle_low=%d"), nHandleNext) ;
				int iNextBranchNum = m_RecordSet.GetRecordCount(strSql) ; //下个箱盒的分支总数
				strSql.Format(_T("select * from cablenet_ent where handle_low=%d"), nHandleNext) ;
				double dNextX = 0, dNextY = 0 ;
				m_RecordSet.GetRecordValue(strSql, _T("pt_x"), dNextX) ;
				m_RecordSet.GetRecordValue(strSql, _T("pt_y"), dNextY) ;
// 				CString strBranchIndexNext ; 
// 				m_RecordSet.GetRecordValue(strSql, _T("branch_index"), strBranchIndexNext) ;
				CString strBoxBlockNext, strBoxTypeNext, strZzjTypeNext ;
				m_RecordSet.GetRecordValue(strSql, _T("box_block"), strBoxBlockNext) ;
				m_RecordSet.GetRecordValue(strSql, _T("zzj_type"), strZzjTypeNext) ;
				CStringArray strArrayBlockNext ;
				CBlkUtility::DivideString(strBoxBlockNext, _T("_"),  strArrayBlockNext	) ;
				if (strArrayBlockNext.GetCount()>1)
				{
					strBoxTypeNext = strArrayBlockNext.GetAt(1) ;
				}
				double dBoxWidthNext = GetBoxWidth(strZzjTypeNext.IsEmpty()?strBoxTypeNext:_T("ZZJ")) ;
				double dBoxHeightNext = GetBoxHeight(strZzjTypeNext.IsEmpty()?strBoxTypeNext:_T("ZZJ")) ;
				int iCurBranchIndex = _ttoi(strBranchIndex.Right(1)) ; //当前箱盒所处的分支序号,此处默认分支数不会是2位数
				pt_3d_conline1.x = pt_3d_box.x+(iLeftOrRight==0?1:-1)*dBoxWidth/2 ; 
				pt_3d_conline1.y = pt_3d_box.y ;
				ptArray.append(pt_3d_conline1) ;//起点	
				//对于第2点，如果本box是next（离信号楼近）盒子伸出的第一个或最后一个box，则x和next盒子的基点对齐，即x值不用加减盒子的半长
				int  iXOffset = 1 ; //第2点的x坐标偏移否
				if (iNextBranchNum>1&&(iCurBranchIndex==1||iCurBranchIndex==iNextBranchNum))
				{
					iXOffset = 0 ;
				}
				pt_3d_conline2.x = dNextX+iXOffset*(iLeftOrRight==0?-1:1)*dBoxWidthNext/2 ;
				pt_3d_conline2.y = pt_3d_box.y ;
				ptArray.append(pt_3d_conline2) ; //第2点			
				if (pt_3d_box.y!=dNextY) 
				{
					pt_3d_conline3.x = dNextX ;
					pt_3d_conline3.y = dNextY+(pt_3d_box.y>dNextY?1:-1)*dBoxHeightNext/2 ;
					ptArray.append(pt_3d_conline3) ; //第3点
				}
				mysys.AddAcDbPolyLine(ptArray, 0) ;
				AcGePoint3d pt_3d_mid = mysys.GetMidPoint(pt_3d_conline1, pt_3d_conline2) ;
				pt_3d_mid.y+=1.5 ;
				AcDbObjectId objIdText ;
				mysys.AddText(objIdText, strCableString, pt_3d_mid, pt_3d_mid, AcDb::kTextMid, AcDb::kTextBase, 2, 0.7) ;
			}

			cSet.MoveNext() ;

		}
		cSet.Close() ;
	}
	//acdbHostApplicationServices()->setWorkingDatabase(pDbNew) ; 
	pDbNew->saveAs(_T("d:\\1.dwg")) ;
	delete pDbNew ;
	pDbNew = NULL ;
	//acdbHostApplicationServices()->setWorkingDatabase(this->m_pDb) ; 
}

double CZnSxt::GetBoxWidth(const CString& strBoxType)
{
	double dWidht = 0 ;
	if (strBoxType.Find(_T("XB"))!=-1)
	{
		dWidht = 5 ;
	}
	else if (strBoxType.Find(_T("HZ"))!=-1)
	{
		dWidht = 3 ;
	}
	else if (strBoxType.Find(_T("HF"))!=-1)
	{
		dWidht = 6 ;
	}
	else if (strBoxType.Find(_T("FSD"))!=-1)
	{
		dWidht = 4 ;
	}
	else if (strBoxType.Find(_T("ZZJ"))!=-1)
	{
		dWidht = 6 ;
	}

	return dWidht ;
}

double CZnSxt::GetBoxHeight(const CString& strBoxType)
{
	double dHeight = 0 ;
	if (strBoxType.Find(_T("XB"))!=-1)
	{
		dHeight = 4 ;
	}
	else if (strBoxType.Find(_T("HZ"))!=-1)
	{
		dHeight = 3 ;
	}
	else if (strBoxType.Find(_T("HF"))!=-1)
	{
		dHeight = 6 ;
	}
	else if (strBoxType.Find(_T("FSD"))!=-1)
	{
		dHeight = 3 ;
	}
	else if (strBoxType.Find(_T("ZZJ"))!=-1)
	{
		dHeight = 6 ;
	}

	return dHeight ;
}

// 编辑实体（信号机、道岔、轨道电路）数据
void CZnSxt::ModEntData(void)
{
	CAcModuleResourceOverride myResources ;	

	ads_name en ;
	ads_point pt ;
	BOOL bReturn = false ;
	while (bReturn == false) 
	{
		int iReturn = acedEntSel(_T("\n选择对象（信号机、道岔等）"), en, pt) ;
		if(iReturn == RTNORM)
		{			
			AcDbEntity * pEnt = NULL ;
			if(m_mysys.OpenAcDbEntity(en, pEnt, AcDb::kForRead))
			{
				pEnt->highlight() ;				
				acedUpdateDisplay();

				if(pEnt->isKindOf(AcDbBlockReference::desc()))
				{
					AcDbBlockReference * pRef = AcDbBlockReference::cast(pEnt) ;
					CString strBlkName ;
					m_mysys.GetBlockName(pRef, strBlkName) ;
					if (strBlkName.Left(3)==_T("XHJ"))
					{
						CEntPropertyDlg dlg ;
						CXhjDATA *pDATA = new CXhjDATA(strBlkName) ;
						this->GetEntData(pEnt,*pDATA) ;

						dlg.m_grid.m_pEntDATA = pDATA ;
						if (dlg.DoModal()==IDOK)
						{
							pRef->upgradeOpen() ;
							this->SetEntData(pEnt, pDATA) ;
							pRef->downgradeOpen() ;

							long nHandleXhj = m_mysys.GetHandle(pEnt) ;
							pEnt->close() ;

							//更新箱盒
							this->DrawBoxXhj(nHandleXhj) ;
						}

						bReturn = true ;
					}
					else if (strBlkName.Left(2)==_T("DC"))
					{
						CEntPropertyDlg dlg ;
						CDcDATA *pDATA = new CDcDATA ;
						this->GetEntData(pEnt, *pDATA) ;

						dlg.m_grid.m_pEntDATA = pDATA ;
						if (dlg.DoModal()==IDOK)
						{
							pRef->upgradeOpen() ;
							this->SetEntData(pEnt, pDATA) ;
							pRef->downgradeOpen() ;							
														
							long nHandleDc = m_mysys.GetHandle(pEnt) ;		
							pEnt->close() ;

							//更新直弯切割绝缘节
							this->AddCutJYJ(nHandleDc) ;
							this->DrawZzj(nHandleDc) ;
						}

						bReturn = true ;
					}
					else
					{
						AfxMessageBox(_T("选择的不是信号机、道岔等能编辑的块！")) ;
						bReturn = false ;
					}
				}
				else if (pEnt->isKindOf(AcDbPolyline::desc()))
				{
					AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;

					int iXdata = 0 ;					
					if (m_mysys.GetXdata(pEnt, _T("ISGUIDAO"), iXdata)&&iXdata==1)
					{
						CEntPropertyDlg dlg ;
						CGdDATA *pDATA = new CGdDATA ;
						this->GetEntData(pEnt, *pDATA) ;

						dlg.m_grid.m_pEntDATA = pDATA ;
						if (dlg.DoModal()==IDOK)
						{
							pEnt->upgradeOpen() ;
							this->SetEntData(pEnt, pDATA) ;
							pEnt->downgradeOpen() ;

							//同步更新相关信息
							int iShowOrHide = 0 ;
							//if (m_mysys.ReadFromRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_GUIDAONAME"), iShowOrHide) &&iShowOrHide==0)
							CLongArray nArrayShowGdName ;
							if (FindShowGdName(pEnt, nArrayShowGdName)>0)
							{
								this->ShowGdName(pEnt) ; //更新轨道名称（辅助信息）
							}
							if (m_mysys.ReadFromRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_FSD"), iShowOrHide) &&iShowOrHide==0)
							{
								this->ShowGdFS(pEnt) ; //更新送受电（辅助信息）
							}
							this->UpdateFsBox(pEnt) ; //更新送受电盒子（在双线中）
							this->UpdateDmhBox(pEnt) ; //更新电码化盒子（在双线中）
							this->UpdateSxtGdName(pEnt, pDATA->m_strName) ; //更新在双线中轨道名称
						}

						bReturn = true ;
					}
					else if (m_mysys.GetXdata(pEnt, _T("IS_XHLCABLE"), iXdata)&&iXdata==1)
					{
						CXhlCableInfoDlg dlg ;
						dlg.m_pEnt = pEnt ;
						dlg.DoModal() ;

						bReturn = TRUE ;
					}
					else if (m_mysys.GetXdata(pEnt, _T("IS_CABLE"), iXdata)&&iXdata==1)
					{
						AcGePoint3d pt_3d_start, pt_3d_end, pt_3d_mid ;
						pPolyLine->getStartPoint(pt_3d_start) ;
						pPolyLine->getEndPoint(pt_3d_end) ;

						//起始端连接的盒子
						int iFindStartBoxNum = 0 ;
						CLongArray nArrayHandleStart ;
						CZnUtility::FindConBox(pt_3d_start, nArrayHandleStart) ;
						iFindStartBoxNum =nArrayHandleStart.GetCount() ;

						//末端连接的盒子
						int iFindEndBoxNum = 0 ;
						CLongArray nArrayHandleEnd ;
						CZnUtility::FindConBox(pt_3d_end, nArrayHandleEnd) ;
						iFindEndBoxNum = nArrayHandleEnd.GetCount() ;

						if (iFindStartBoxNum>0&&iFindEndBoxNum>0)
						{
							if (iFindEndBoxNum!=1||iFindStartBoxNum!=1)
							{
								acutPrintf(_T("\n注意：所选电缆两端连接箱盒不唯一,但仍以其中一个进行计算！")) ;								
							}
							long nHandleCable = 0 ;
							nHandleCable = m_mysys.GetHandle(pEnt) ;							
							long iIsXhlCable = 0 ;
							m_mysys.GetXdata(nArrayHandleEnd.GetAt(0), _T("IS_XHLCABLE"), iIsXhlCable) ;
							pEnt->unhighlight() ;
							pEnt->close() ; //此处先关闭是因为computecableinfo函数传递的参数nHandleCable会稍后打开读写实体，造成多次打开错误
							this->ComputeCableInfo(nArrayHandleStart.GetAt(0), nArrayHandleEnd.GetAt(0), nHandleCable, (iIsXhlCable>0?2:0)) ;
														
							bReturn = true ;
						}
						else
						{
							acutPrintf(_T("\n所选电缆不是两端都连接箱盒或信号楼或主电缆！")) ;
						}
					}
					else
					{
						AfxMessageBox(_T("选择的多段线不是轨道、电缆等可编辑对象！")) ;
						bReturn = false ;
					}
				}
				else
				{
					AfxMessageBox(_T("选择的不是本工具支持的实体！")) ;
					bReturn = false ;
				}
				if(pEnt!=NULL)
				{
					pEnt->unhighlight() ;
				}
				acedUpdateDisplay();
			}
			pEnt->close() ;	
		}
		else if (iReturn == RTERROR) 
		{
			bReturn = false ;
		}	
		else if (iReturn == RTCAN) {
			bReturn = true ;
		}
	}
}

// 查找pt_3d_base所在位置的实体
int CZnSxt::FindEnt(const AcGePoint3d& pt_3d_pick, const void* strDxfCode, const void* strAppName, CLongArray& nArrayHandle)
{
	//保存当前视图反位，本函数执行完后恢复
	CViewExtents viewExt ;
	m_mysys.GetViewExtents(viewExt) ;
	m_mysys.ZoomView() ;

	struct resbuf *pRb ;
	if (strDxfCode!=NULL&&strAppName!=NULL)
	{
		pRb = acutBuildList(RTDXF0, strDxfCode, kDxfRegAppName, strAppName, 0) ;
	}
	else if (strDxfCode!=NULL)
	{
		pRb = acutBuildList(RTDXF0, strDxfCode, 0) ;
	}
	else if (strAppName!=NULL)
	{
		pRb = acutBuildList(kDxfRegAppName, strAppName, 0) ;
	}
	else 
	{
		pRb = NULL ;
	}
	long iLen = 0 ;
	ads_point pt_min = {pt_3d_pick.x-0.1, pt_3d_pick.y-0.1, 0}, pt_max = {pt_3d_pick.x+0.1, pt_3d_pick.y+0.1, 0};
	iLen = m_mysys.GetSSEntHandle(_T("C"), pt_min, pt_max, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	m_mysys.SetViewExtents(viewExt) ;
	return iLen ;
}
// 计算指定盒子引入电缆总芯数
int CZnSxt::GetCableCoreNum(sequential_tree<CBoxNodeEnt>& cableBoxTree, CString& strCableTypeName, int& iBackup, int iDist)
{
	int iRet = 0 ;

	sequential_tree<CBoxNodeEnt>::post_order_iterator pit = cableBoxTree.post_order_begin();	//先遍历子节点	
	sequential_tree<CBoxNodeEnt>::post_order_iterator pit_end = cableBoxTree.post_order_end();	
	int iNumOfNodeVarFreq[3] = {0, 0, 0} ; //记录不同频率的节点个数，依次记录偶数频率、奇数频率、无频率（只对电码化有用）
	for (; pit != pit_end; ++pit)
	{
		//acutPrintf(_T("\n:%s, %s, %s"), pit->m_strBoxType, pit->m_strDevName, pit->m_strDevType) ;
		//begin 仅针对电码化
		if (m_iCurDljlType==3)
		{
			CBoxNodeEnt* pBoxNodeTmp = pit.node()->get() ;				

			//const CString strFreqCurNode = pBoxNodeTmp->m_strFreq ;
			if (! pBoxNodeTmp->m_strFreq.IsEmpty())
			{
				int iTmp = _ttoi(pBoxNodeTmp->m_strFreq.Left(2)) ;
				iNumOfNodeVarFreq[iTmp%2]++ ;
			}
			else
			{
				iNumOfNodeVarFreq[2]++ ;
			}
		}
		//end 仅针对电码化
		//本身的芯线（分向盒之类没有）
		if (!pit->m_strDevType.IsEmpty())
		{
			long iLenForPlus = 0 ;
            m_mysys.GetXdata(pit->m_nHandleCable, _T("LENFORPLUS"), iLenForPlus) ;
			this->GetDevCore(*(pit.node()->get()), iLenForPlus>0?iLenForPlus:iDist) ;				
		}
		//从子节点引入的芯线
		sequential_tree<CBoxNodeEnt>::iterator it = pit.node()->begin();
		for (; it != pit.node()->end(); ++it) //遍历各子节点
		{
			vector<CCableCore>::iterator it_core = it->m_vecCableCore.begin() ;
			for (;it_core!=it->m_vecCableCore.end(); ++it_core) //遍历当前子节点的芯线
			{
				if(pit->FindCableCore(*it_core)==false)//查找父节点本身新出芯是否已有，有则舍弃此条
				{
					if (it_core->IsInside()!=1)
					{
						pit->m_vecCableCore.push_back(*it_core) ;
					}
				}
			}
		}
	}

	int iNumNeed4PGroup = 0 ;
	//int iBackupNum = 0 ;
	//CString strCableTypeName ;
	iRet = cableBoxTree.get()->m_vecCableCore.size() ; //实际使用芯数
	int iCableType = 0 ;//普通电缆，1是屏蔽电缆

	if (m_iCurDljlType==3)
	{
		iCableType = 1 ;
		iNumNeed4PGroup = min(iNumOfNodeVarFreq[0], iNumOfNodeVarFreq[1])+abs(iNumOfNodeVarFreq[0]-iNumOfNodeVarFreq[1]) ;//需要用到的内屏蔽4芯组个数	
	}

	this->GetUseCableType(iRet, iNumNeed4PGroup, iBackup, strCableTypeName, m_iCurDljlType, iCableType ) ;
	//strCableTypeAndBackup.Format(_T("%s(%d)"), strCableTypeName, iBackupNum) ;

	return iRet ;
}

BOOL CZnSxt::GetBoxInfo(long nHandleBox, CBoxNodeEnt& boxNode)
{
	BOOL bRet = FALSE ;

	AcDbEntity* pEntFind = NULL ;
	if (m_mysys.OpenAcDbEntity(nHandleBox, pEntFind, AcDb::kForRead))
	{
		if (pEntFind->isKindOf(AcDbBlockReference::desc()))
		{
			AcDbBlockReference* pRef = AcDbBlockReference::cast(pEntFind) ;
			m_mysys.GetBlockName(pRef, boxNode.m_strBoxBlock) ;
			CStringArray strArrayBlkNameBox ;
			CBlkUtility::DivideString(boxNode.m_strBoxBlock, _T("_"), strArrayBlkNameBox) ;
			int iNum = strArrayBlkNameBox.GetCount() ;
			if (iNum<3)
			{
				pEntFind->close() ;
				return FALSE ;
			}
			CString strBlkNameBoxPart0 = strArrayBlkNameBox.GetAt(0) ;
			CString strBlkNameBoxPart1 = strArrayBlkNameBox.GetAt(1) ;
			if (strBlkNameBoxPart0==_T("BOX"))
			{
				if (strBlkNameBoxPart1==_T("HF"))
				{
					m_mysys.GetAttValue(pRef, _T("HFNUM"), boxNode.m_strDevName) ;							
					int iHfNum = 0 ;
					m_mysys.GetAttValue(pRef, _T("HF"), iHfNum) ;
					boxNode.m_strBoxType.Format(_T("HF%d"), iHfNum) ;
					CString strDistToXhl ;
					m_mysys.GetAttValue(pRef, _T("DIST"), strDistToXhl) ;
					strDistToXhl.TrimLeft(_T('(')) ;
					strDistToXhl.TrimRight(_T(')')) ;
					boxNode.m_iDistToXhl = _tstoi(strDistToXhl) ;	
					boxNode.m_iEntType = -1 ;
					//m_iCurDljlType = -1 ;
					//pBoxNode = new CBoxNodeBase(strBoxType, strDevName, _T(""), nHandleBox,  0,  strBlkNameBox, _T(""), _T(""), iDistToXhl) ; 
				}
				else if (strBlkNameBoxPart1==_T("XB"))
				{
					m_mysys.GetAttValue(pRef, _T("XB"), boxNode.m_strBoxType) ;
					//long nHandleBoxBelong = 0 ;
					if(m_mysys.GetXdata(pEntFind, _T("BELONG_ENT"), boxNode.m_nHandleDev))
					{
						m_iCurDljlType = 1 ; //信号机
						//int iBoxSumCurXhj = 1,  iBoxIndexCurXhj = 1 ;
						if(this->GetBoxInfo_XHJ(pEntFind, boxNode.m_nHandleDev, boxNode.m_iBoxSum, boxNode.m_iBoxIndex, boxNode.m_strDevName, boxNode.m_strDevBlock, boxNode.m_strDevType))
						{
							if (boxNode.m_iBoxSum>1)
							{
								boxNode.m_strDevType.Insert(3, boxNode.m_iBoxIndex==1?_T('B'):_T('A')) ;
								boxNode.m_strDevType.AppendFormat(_T("_%s-%s"), boxNode.m_strBoxType, boxNode.m_strBoxType) ;
							}
							boxNode.m_iEntType = 1 ;
							//pBoxNode = new CBoxNodeXhj(strBoxType, strDevName, strDevType, iBoxSumCurXhj, iBoxIndexCurXhj, nHandleBox,  nHandleBoxBelong, strBlkNameBox, strBlkNameDev, _T(""), 0) ;
						}
					}
				}
				else if (strBlkNameBoxPart1==_T("HZ"))
				{
					int iHzNum = 0 ;
					m_mysys.GetAttValue(pRef, _T("HZ"), iHzNum) ;
					strBoxType.Format(_T("HZ%d"), iHzNum) ;

					long nHandleBoxBelong = 0 ;
					if(m_mysys.GetXdata(pEntFind, _T("BELONG_ENT"), nHandleBoxBelong)) 
					{
						CString strBlkNameBoxBelong ;
						if (m_mysys.GetBlockName(nHandleBoxBelong, strBlkNameBoxBelong) )
						{
							CString strTypeBoxBelong = strBlkNameBoxBelong.Left(3) ;
							if (strTypeBoxBelong==_T("XHJ"))//信号机
							{
								m_iCurDljlType = 1 ; //信号机
								boxNode.m_nHandleDev = nHandleBoxBelong ;
								//int iBoxSumCurXhj = 1,  iBoxIndexCurXhj = 1 ;
								if(this->GetBoxInfo_XHJ(pEntFind, boxNode.m_nHandleDev, boxNode.m_iBoxSum, boxNode.m_iBoxIndex, boxNode.m_strDevName, boxNode.m_strDevBlock, boxNode.m_strDevType))
								{
									if (boxNode.m_iBoxSum>1)
									{
										boxNode.m_strDevType.Insert(3, boxNode.m_iBoxIndex==1?_T('B'):_T('A')) ;
										boxNode.m_strDevType.AppendFormat(_T("_%s-%s"), boxNode.m_strBoxType, boxNode.m_strBoxType) ;
									}
									boxNode.m_iEntType = 1 ;
									//pBoxNode = new CBoxNodeXhj(strBoxType, strDevName, strDevType, iBoxSumCurXhj, iBoxIndexCurXhj, nHandleBox,  nHandleBoxBelong, strBlkNameBox, strBlkNameDev, _T(""), 0) ;									
								}
							}
							else if (strTypeBoxBelong==_T("ZZJ"))//转辙机
							{
								m_iCurDljlType = 0 ; //道岔
								long iIsJxg = 1 ; //默认尖轨，=2是芯轨
								m_mysys.GetXdata(nHandleBoxBelong, _T("IS_JXG"), iIsJxg) ;
								boxNode.m_iJxg = iIsJxg ;
								//CString strDragType ;
								m_mysys.GetAttValue(nHandleBoxBelong, _T("TYPE"), boxNode.m_strDragType) ;
								m_mysys.GetAttValue(nHandleBoxBelong, _T("ACTINDEX"), boxNode.m_strActIndex) ;

								long nHandleDc = 0 ;								
								if(m_mysys.GetXdata(nHandleBoxBelong, _T("BELONG_ENT"), nHandleDc)) 
								{
									m_mysys.GetAttValue(nHandleDc, _T("BIANHAO"), boxNode.m_strDevName) ;

									CDcDATA dataDc ;
									this->GetEntData(nHandleDc, dataDc) ;
									CString strQyType = (boxNode.m_iJxg==1?dataDc.m_strJG_QyType:dataDc.m_strXG_QyType) ;
									this->GetZzjDevType(nHandleBox, boxNode.m_strDevType) ;
									//int iDragIndex = 1 ;
									if (boxNode.m_strDevType.GetLength()>0)
									{
										boxNode.m_iDragIndex = int(boxNode.m_strDevType.GetAt(boxNode.m_strDevType.GetLength()-1)-_T('A'))+1 ;
									}
									boxNode.m_iEntType = 0 ;
									//pBoxNode = new CBoxNodeZzj(strBoxType, strDevName, strDevType, strDragType, iDragIndex, strQyType, strActIndex, 0, nHandleBox, nHandleDc, strBlkNameBox) ;
								}
							}
						}
					}
				}
				else if (strBlkNameBoxPart1==_T("FSD"))
				{
					m_iCurDljlType = 2 ; //轨道电路
					long nHandleBoxBelong = 0 ;
					if(m_mysys.GetXdata(pEntFind, _T("BELONG_ENT"), nHandleBoxBelong)) //送受电
					{
						long nLeftOrRight = 0 ;
						m_mysys.GetXdata(pEntFind, _T("LEFT_RIGHT"), nLeftOrRight) ;	

						//m_mysys.GetBlockName(nHandleBoxBelong, boxNode.m_strDevBlock) ;						
						m_mysys.GetAttValue(nHandleBox, _T("GDNAME"), boxNode.m_strDevName) ;
						if (boxNode.m_strDevName.IsEmpty()) //以盒子属性设置的轨道名为准，但如果没有读到值，再次从轨道扩展数据读取
						{
							m_mysys.GetXdata(nHandleBoxBelong, _T("GUIDAONAME"), boxNode.m_strDevName) ;
							CString strForSTmp = _T("F") ;
							if (nLeftOrRight==1) //左
							{
								m_mysys.GetXdata(nHandleBoxBelong, _T("LEFT_FORS"), strForSTmp) ;	
							}
							else if (nLeftOrRight==0)//右
							{
								m_mysys.GetXdata(nHandleBoxBelong, _T("RIGHT_FORS"), strForSTmp) ;
							}
							if (strForSTmp==_T("S"))
							{
								boxNode.m_strDevName.Append(_T("J")) ;
							}
						}
						boxNode.m_strBoxType = _T("XB1") ;						
						CString strBlkNameBoxPart2 = strArrayBlkNameBox.GetAt(2) ;
						CString strBlkNameBoxPart3 = strArrayBlkNameBox.GetAt(3) ;
						//strDevType = _T("FSD_GD_0") ;
						boxNode.m_strDevType.Format(_T("FSD_GD_%s"), strBlkNameBoxPart2 ) ;
						if (strBlkNameBoxPart3==_T("1")) //电码化
						{
							m_iCurDljlType = 3 ; //电码化
							//strDevType = _T("FSD_DM_0") ;
							boxNode.m_strDevType.Format(_T("FSD_DM_%s"), strBlkNameBoxPart2 ) ;
							m_mysys.GetAttValue(nHandleBox, _T("FREQ"), boxNode.m_strFreq) ;
							if (boxNode.m_strFreq.IsEmpty()) //同理（读轨道名称）
							{
								if (nLeftOrRight==0) //左
								{
									m_mysys.GetXdata(nHandleBoxBelong, _T("FREQ_LEFT"), boxNode.m_strFreq) ;
								}
								else if (nLeftOrRight==1)//右
								{
									m_mysys.GetXdata(nHandleBoxBelong, _T("FREQ_RIGHT"), boxNode.m_strFreq) ;
								}
							}
							boxNode.m_iEntType = 3 ;
							//pBoxNode = new CBoxNodeDmh(strBoxType, strDevName, strDevType, strFreq, nHandleBox, 0, strBlkNameBox) ;
						}
						else  //轨道
						{
							boxNode.m_iEntType = 2 ;
							//pBoxNode = new CBoxNodeGd(strBoxType, strDevName, strDevType, nHandleBox, 0, strBlkNameBox) ;
						}
						if (strBlkNameBoxPart2.Find(_T("-"))!=-1)
						{
							strBoxType = _T("XB2") ;
							long nHandleBoxBelong2 = 0 ;
							if(m_mysys.GetXdata(pEntFind, _T("BELONG_GD2"), nHandleBoxBelong2)) 
							{
								if (nHandleBoxBelong2>0)
								{
									CString strGuiDaoName2 ;
									m_mysys.GetXdata(nHandleBoxBelong2, _T("GUIDAONAME"), strGuiDaoName2) ;
									strDevName.AppendFormat(_T(" %s"), strGuiDaoName2) ;
								}
							}
						}
					}
				}
				bRet = TRUE ;
			}
		}

		pEntFind->close() ;
	}

	return bRet ;
}

BOOL CZnSxt::GetBoxInfo_XHJ(AcDbEntity* pEnt, long nHandleBoxBelong, int &iBoxSumCurXhj, int &iBoxIndexCurXhj, CString & strDevName, CString & strBlkNameDev, CString & strDevType)
{
	BOOL bRet = FALSE ;

	m_mysys.GetXdata(pEnt, _T("BOX_SUM"), iBoxSumCurXhj) ;
	m_mysys.GetXdata(pEnt, _T("BOX_INDEX"), iBoxIndexCurXhj) ;
	m_mysys.GetAttValue(nHandleBoxBelong, _T("XHJNAME"), strDevName) ;

	m_mysys.GetBlockName(nHandleBoxBelong, strBlkNameDev) ;
	CStringArray strArrayDevName ;
	CBlkUtility::DivideString(strBlkNameDev, _T("_"), strArrayDevName) ;
	if (strArrayDevName.GetCount()>7)
	{
		strDevType.Format(_T("XHJ_%s_%s"), strArrayDevName.GetAt(2), strArrayDevName.GetAt(4)) ;
		bRet = TRUE ;
	}
	else
	{
		acutPrintf(_T("\n信号机 %s 块名 %s 不能分解成7块以上，请检查是否是标准块!"), strDevName, strBlkNameDev) ;
	}

	return bRet ;
}

// 取得一个设备的芯线
int CZnSxt::GetDevCore(CBoxNodeEnt &boxNode/*const CString& strDevType, const CString& strDevName, const CString& strFreq, vector<CCableCore>* pVec*/, int iDist)
{
	int iRet = 0 ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;

		//先取得加芯数据（主要是转辙机）
		CMapStringToString mapZzjPlusCore ;
		strSql.Format(_T("select top 1 * from define_zzj_plus where dev_for='%s' and cable_len>%d"), boxNode.m_strDevType, iDist) ;
		long nId = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("id"), nId) ;
		if (nId==0) //未找到 ，则去字典查找 strDevType匹配的
		{
			CString strSqlTmp ;
			strSqlTmp.Format(_T("select  * from define_dict where dict_for='ZZJ_PLUS' and source='%s'"), boxNode.m_strDevType) ;
			CString strDestination ;
			m_RecordSet.GetRecordValue(strSqlTmp, _T("destination"), strDestination) ;
			if (!strDestination.IsEmpty())
			{
				strSql.Format(_T("select top 1 * from define_zzj_plus where dev_for='%s' and cable_len>%d"), strDestination, iDist) ;
			}
		}
		CString strCoreList ;
		if (m_RecordSet.GetRecordValue(strSql, _T("core_list"), strCoreList) >0)
		{
			CStringArray strArrayCoreList ;
			CBlkUtility::DivideString(strCoreList, _T("_"), strArrayCoreList) ;
			for (int iIndexCoreList=0; iIndexCoreList<strArrayCoreList.GetCount(); iIndexCoreList++)
			{
				CString strCoreTmp = strArrayCoreList.GetAt(iIndexCoreList) ;
				int iFindLoc = strCoreTmp.Find(_T('-')) ;
				if (iFindLoc!=-1)
				{
					mapZzjPlusCore.SetAt(strCoreTmp.Left(iFindLoc), strCoreTmp.Right(strCoreTmp.GetLength()-iFindLoc-1)) ;
				}												
			}
		}

		CString strDevFor = _T("JY1") ;
		if (boxNode.m_iEntType==1)
		{
			if (m_iDsNumXhj==1)
			{
				strDevFor = _T("JY3") ;
			}
			if (boxNode.m_strDevBlock.Mid(4,2)==_T("DC")) //调车
			{
				if (m_iDcDsNum==1)
				{
					strDevFor = _T("JY2") ;
				}
				else if (m_iDcDsNum==2)
				{
					strDevFor = _T("JY3") ;
				}
				else
				{
					strDevFor = _T("JY1") ;
				}
			}
		}
		if (boxNode.m_iEntType==0)
		{
			if (m_iQkNum==1)
			{
				strDevFor = _T("JY4") ;
			}
		}

		//直接找不到dev，再通过字典找一遍
		strSql.Format(_T("select * from define_dev_use_cablecore where dev_id in(select id from define_dev where dev_type='%s' and dev_for='%s' ) order by id"), boxNode.m_strDevType, strDevFor) ;
		nId = 0 ;
		if (m_RecordSet.GetRecordValue(strSql, _T("id"), nId) == 0)
		{
			CString strSqlTmp ;
			strSqlTmp.Format(_T("select  * from define_dict where dict_for='ZZJ_CORE' and source='%s'"), boxNode.m_strDevType) ;
			CString strDestination ;
			if (m_RecordSet.GetRecordValue(strSqlTmp, _T("destination"), strDestination) ==1)
			{
				strSql.Format(_T("select * from define_dev_use_cablecore where dev_id in(select id from define_dev where dev_type='%s' and dev_for='%s' ) order by id"), strDestination, strDevFor) ;
			}
		}

		if (cSet.Open(strSql))
		{
			iRet = cSet.GetRecordCount() ;
			while (!cSet.IsEOF())
			{
				CString strCoreName, strCoreNameShow;
				int iIsInside = 0, iIsShare = 0, iIsAdd = 0 ;	
				cSet.GetFieldValue(_T("core_name"), strCoreName) ;
				cSet.GetFieldValue(_T("core_name_show"), strCoreNameShow) ;
				cSet.GetFieldValue(_T("is_inside"), iIsInside) ;
				cSet.GetFieldValue(_T("is_share"), iIsShare) ;
				cSet.GetFieldValue(_T("is_add"), iIsAdd) ;
				CCableCore cablecore(iIsShare==0?boxNode.m_strDevName:_T(""), strCoreName, strCoreNameShow, boxNode.m_strFreq, iIsInside, iIsShare, iIsAdd) ;
				boxNode.m_vecCableCore.push_back(cablecore) ;

				//begin 加芯
				CString strCoreNum ;
				if (mapZzjPlusCore.Lookup(strCoreName, strCoreNum) )
				{
					int iCoreNum = _tstoi(strCoreNum) ;
					if (iCoreNum>1)
					{
						for (int iPlusIndex=0; iPlusIndex<(iCoreNum-1); iPlusIndex++)
						{
							CString strCoreNamePlus = strCoreName ;
							CString strCoreNameShowPlus = strCoreNameShow ;

							strCoreNamePlus.AppendFormat(_T("+%d"), iPlusIndex+1) ;
							strCoreNameShowPlus.AppendFormat(_T("+%d"), iPlusIndex+1) ;
							//iIsNew = 1 ;
							//iIsInside = 0 ;
							iIsShare = 0 ;
							iIsAdd = 1 ;
							CCableCore cablecorePlus(iIsShare==0?boxNode.m_strDevName:_T(""), strCoreNamePlus, strCoreNameShowPlus, boxNode.m_strFreq, iIsInside, iIsShare, iIsAdd) ;
							boxNode.m_vecCableCore.push_back(cablecorePlus) ;
						}
					}
				}
				//end 加芯

				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetDevCore"));
	}
	return iRet;
}

 // 查找满足条件的电缆型号, iDevType=-1：通用（混合），0：道岔，1，信号机，2：轨道电路；3：电码化，iCableType=0,普通综合扭绞（数字）电缆，1，内屏蔽数字电缆
BOOL CZnSxt::GetUseCableType(int iUseCoreNum, int iNumNeed4PGroup, int& iBackupNum, CString& strCableTypeName, int iDevType, int iCableType)
{
	BOOL bRet = FALSE ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		if(m_iCurDljlType==3)//电码化
		{
			if (iUseCoreNum==2&&iNumNeed4PGroup==1)
			{
				strCableTypeName = _T("4") ;
				iBackupNum = 2 ;
			}
			else if (iUseCoreNum==4)
			{
				strCableTypeName = _T("8B") ;
				iBackupNum = 4 ;
			}
			else
			{
				strSql.Format(_T("SELECT cable_type_id, count(core_group_type) as num4p  from define_core_detail where core_group_type='4P' and backup=0 and (cable_type_id in(select id from define_cable_type where right(cable_name,1)='B'))  group by cable_type_id")) ;
				if (cSet.Open(strSql))
				{
					while(!cSet.IsEOF())
					{
						int iNum4p = 0 ;	
						cSet.GetFieldValue(_T("num4p"), iNum4p) ;
						if (iNum4p>=iNumNeed4PGroup*4)
						{
							int iCableTypId = 0 ;
							cSet.GetFieldValue(_T("cable_type_id"), iCableTypId) ;
							strSql.Format(_T("select * from define_cable_type where id=%d"), iCableTypId) ;
							m_RecordSet.GetRecordValue(strSql, _T("cable_name"), strCableTypeName) ;
							long iNumCore = 0 ;
							m_RecordSet.GetRecordValue(strSql, _T("core_num"), iNumCore) ;
							iBackupNum = iNumCore-iUseCoreNum ;

							bRet = TRUE ;
							break;
						}	
						cSet.MoveNext() ;
					}
					cSet.Close() ;
				}
			}
		}
		else
		{
			//strSql.Format(_T("select top 1 * from define_cable_type where cable_type=%d and fact_use_num>=%d %s order by id asc"), iCableType, iUseCoreNum, m_iCurDljlType==1?_T("and cable_name not in('14','14A','14B')"):_T("")) ;
			strSql.Format(_T("select top 1 * from define_cable_type where cable_type=%d and fact_use_num>=%d and right(cable_name,1)<>'A' order by id asc"), iCableType, iUseCoreNum) ;
			if (cSet.Open(strSql))
			{
				if (cSet.GetRecordCount()==1)
				{
					int iCoreNum = 0 ;	
					cSet.GetFieldValue(_T("cable_name"), strCableTypeName) ;
					cSet.GetFieldValue(_T("core_num"), iCoreNum) ;
					iBackupNum = iCoreNum-iUseCoreNum ;

					bRet = TRUE ;
				}
				cSet.Close() ;
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetUseCableType"));
	}
	return bRet;
}

// 检查并顺正、合并轨道线（两头无任何连接的标示出来）
void CZnSxt::CheckGdLine(void)
{
	BOOL bHasErro = FALSE ;

	CString strMsg ;

	double dTolCheckGd = 0.001 ;
	CBlkUtility::QueryValueReg(_T("ZnOption"), _T("TolCheckGd"), dTolCheckGd) ;
	acutPrintf(_T("\n框选所有的轨道线。")) ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(-4,_T("<OR"),RTDXF0,_T("LINE"),RTDXF0,_T("LWPOLYLINE"), -4,_T("OR>"), 0) ;
	nLen = m_mysys.GetSSEntHandle(NULL, NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	int iRet = 0 ;
	//线顺正
	for (int i=0; i<nLen; i++)
	{
		AcDbEntity* pEnt = NULL ;
		long nHandle = nArrayHandle.GetAt(i) ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{			
			if (m_mysys.ReverseLinePoint(pEnt, 0, -1) >0)
			{
				iRet++ ;
			}
			pEnt->close() ;
		}
	}
	acutPrintf(_T("\n顺正线%d条"), iRet) ;

	//单线转多段线
	iRet = 0 ;
	CLongArray nArrayHandleNew/*, nArrayHandleToDel*/ ;
	for (int i=0; i<nLen; i++)
	{
		AcDbEntity* pEnt = NULL ;
		long nHandle = nArrayHandle.GetAt(i) ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbLine::desc()))
			{
				AcGePoint3d pt_3d_se[2] ;
				AcDbLine* pLine = AcDbLine::cast(pEnt) ;
				pLine->getStartPoint(pt_3d_se[0]) ;
				pLine->getEndPoint(pt_3d_se[1]) ;
				AcDbObjectId ojbId = m_mysys.AddAcDbPolyLine(pt_3d_se[0], pt_3d_se[1]) ;
				long nHandleNew = m_mysys.GetHandle(ojbId) ;
				nArrayHandleNew.Add(nHandleNew) ;
				pEnt->upgradeOpen() ;
				pEnt->erase() ; //删除单线
				iRet++ ;
			}
			else if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				nArrayHandleNew.Add(nHandle) ;
			}
			pEnt->close() ;
		}
	}
	acutPrintf(_T("\n转换直线到多段线%d条"), iRet) ;

	nArrayHandle.RemoveAll() ;
	nArrayHandle.Copy(nArrayHandleNew) ;

	//检查多个起点重合或多个终点重合的线
	for (int i=0; i<nLen; i++)
	{
		AcGePoint3d pt_3d_se[2] ;

		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nArrayHandle.GetAt(i), pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbLine::desc()))
			{
				AcDbLine* pLine = AcDbLine::cast(pEnt) ;
				pLine->getStartPoint(pt_3d_se[0]) ;
				pLine->getEndPoint(pt_3d_se[1]) ;
			}
			else if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
				pPolyLine->getStartPoint(pt_3d_se[0]) ;
				pPolyLine->getEndPoint(pt_3d_se[1]) ;
			}
			pEnt->close() ;
		}
		for (int m=0; m<2; m++) //m=0：起点;m=1：终点
		{
			CLongArray nArrayHandleLine[2] ;
			m_mysys.GetLineOfStartOrEndInPt(pt_3d_se[m], nArrayHandle, nArrayHandleLine, dTolCheckGd) ; 
			for (int n=0; n<2; n++)
			{
				int iNum=nArrayHandleLine[n].GetCount() ;
				if (iNum>1) //多于1个起/终点位于pt_3d_start
				{
					bHasErro = TRUE ;

					CString strHandle ;
					for (int j=0; j<iNum; j++)
					{
						strHandle.AppendFormat(_T("%d,"), nArrayHandleLine[n].GetAt(j)) ;
						m_mysys.SetEntColorIndex(nArrayHandleLine[n].GetAt(j), 3) ;
					}
					strHandle.TrimRight(_T(",")) ;
					acutPrintf(_T("\n在点%.3f-%.3f处找到多于1个以此为%s点的线(%s)，已标示，请先处理后再运行此命令。"), pt_3d_se[m].x, pt_3d_se[m].y, n==0?_T("起"):_T("终"), strHandle) ;
				}
			}
		}
	}
	
	if (bHasErro==TRUE)
	{
		strMsg.Format(_T("发现多个起点/终点位于同一点的情况，已标示，请先处理后再运行此命令。")) ;
		AfxMessageBox(strMsg) ;
		return ;
	}

	CString strHasFinishPt ;  //记录形如1111-0/1111-1（线的handle-起点0/终点1）
	CLongArray nArrayHandleToJoin[2] ;
	//查找需要首尾相连的线
	for (int i=0; i<nLen; i++)
	{
		AcGePoint3d pt_3d_se[2] ;

		long nHandleCur = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandleCur, pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbLine::desc()))
			{
				AcDbLine* pLine = AcDbLine::cast(pEnt) ;
				pLine->getStartPoint(pt_3d_se[0]) ;
				pLine->getEndPoint(pt_3d_se[1]) ;
			}
			else if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
				pPolyLine->getStartPoint(pt_3d_se[0]) ;
				pPolyLine->getEndPoint(pt_3d_se[1]) ;
			}
			pEnt->close() ;
		}
		for (int m=0; m<2; m++) //m=0：起点m=1：终点
		{
			CString strCurPt ; 
			strCurPt.Format(_T("%d-%d"), nHandleCur, m) ;
			if (strHasFinishPt.Find(strCurPt)!=-1)
			{
				continue; 
			}
			CLongArray nArrayHandleLine[2] ;
			m_mysys.GetLineOfStartOrEndInPt(pt_3d_se[m], nArrayHandle, nArrayHandleLine, dTolCheckGd) ; 
			if (m==0&&nArrayHandleLine[1].GetCount()==1) //在起点找到1个以此为终点的线
			{
				nArrayHandleToJoin[0].Add(nArrayHandleLine[1].GetAt(0)) ;
				nArrayHandleToJoin[1].Add(nHandleCur) ;
				strHasFinishPt.AppendFormat(_T("%s,"), strCurPt) ;
				strCurPt.Format(_T("%d-%d"), nArrayHandleLine[1].GetAt(0), 1) ;
				strHasFinishPt.AppendFormat(_T("%s,"), strCurPt) ;
			}
			else if (m==1&&nArrayHandleLine[0].GetCount()==1) //在起点找到1个以此为起点的线
			{
				nArrayHandleToJoin[0].Add(nHandleCur) ;
				nArrayHandleToJoin[1].Add(nArrayHandleLine[0].GetAt(0)) ;				
				strHasFinishPt.AppendFormat(_T("%s,"), strCurPt) ;
				strCurPt.Format(_T("%d-%d"), nArrayHandleLine[0].GetAt(0), 0) ;
				strHasFinishPt.AppendFormat(_T("%s,"), strCurPt) ;
			}
		}
	}
	//合并首尾相连的线
	int iNumJoin = nArrayHandleToJoin[0].GetCount() ;
	int iNumJoinInfact = 0 ;
	for (int i=0; i<iNumJoin; i++)
	{
		long nHandleLeft = nArrayHandleToJoin[0].GetAt(i) ;
		long nHandleRight = nArrayHandleToJoin[1].GetAt(i) ;
		acutPrintf(_T("\n准备合并多段线  %d 和 %d "), nHandleLeft, nHandleRight) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandleLeft, pEnt))
		{
			AcDbPolyline* pPolyLineLeft = AcDbPolyline::cast(pEnt) ;
			int iNumVert1 = pPolyLineLeft->numVerts() ;

			AcDbEntity* pEnt2 = NULL ;
			if (m_mysys.OpenAcDbEntity(nHandleRight, pEnt2, AcDb::kForRead))
			{
				AcDbPolyline* pPolyLineRight = AcDbPolyline::cast(pEnt2) ;

				AcGePoint3d pt_3d_start_left, pt_3d_start_right ;
				pPolyLineLeft->getStartPoint(pt_3d_start_left) ;
				pPolyLineRight->getStartPoint(pt_3d_start_right) ;
				acutPrintf(_T("\n%d:准备合并起点为(%.3f, %.3f),和起点为(%.3f, %.3f)的线"), i, pt_3d_start_left.x, pt_3d_start_left.y, pt_3d_start_right.x, pt_3d_start_right.y) ;

				int iNumVert2 = pPolyLineRight->numVerts() ;
				for (int j=0; j<iNumVert2-1; j++)
				{
					AcGePoint2d pt_2d_add ;
					pPolyLineRight->getPointAt(j+1, pt_2d_add) ;
					double dWidthStart = 0, dWidthEnd = 0 ;
					pPolyLineRight->getWidthsAt(j, dWidthStart, dWidthEnd) ;
					pPolyLineLeft->addVertexAt(iNumVert1+j, pt_2d_add) ;
					pPolyLineLeft->setWidthsAt(iNumVert1+j-1, dWidthStart, dWidthEnd) ;
				}

				pEnt2->upgradeOpen() ;
				pEnt2->erase() ;
				pEnt2->close() ;

				pPolyLineLeft->setColorIndex(3) ;

				bHasErro = TRUE ;
				iNumJoinInfact++ ;
			}				

			pEnt->close() ;
		}
	}   

	if (bHasErro==TRUE)
	{
		strMsg.Format(_T("合并%d处多段线,已标示，请先确认后再运行此命令。"), iNumJoinInfact) ;
		AfxMessageBox(strMsg) ;
		return ;
	}

	//检查多个顶点位于同一坐标的多段线
	for (int i=0; i<nLen; i++)
	{
		AcDbEntity* pEnt = NULL ;
		long nHandle = nArrayHandle.GetAt(i) ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
				int iNumVert = pPolyLine->numVerts() ;
				for (int j=0; j<iNumVert-1; j++)
				{
					AcGePoint2d pt_2d_cur, pt_2d_next ;
					pPolyLine->getPointAt(j, pt_2d_cur) ;
					pPolyLine->getPointAt(j+1, pt_2d_next) ;
					AcGeTol tol ;
					tol.setEqualPoint(dTolCheckGd) ;
					if (pt_2d_cur.isEqualTo(pt_2d_next, tol))
					{
						bHasErro = TRUE ;
						acutPrintf(_T("\n在点(%.3f,%.3f)处有重合点！"), pt_2d_cur.x, pt_2d_cur.y) ;
						pPolyLine->upgradeOpen() ;
						pPolyLine->setColorIndex(3) ;
						pPolyLine->downgradeOpen() ;
						break ;
					}
				}
			}

			pEnt->close() ;
		}
	}	
	if (bHasErro==TRUE)
	{
		strMsg.Format(_T("发现有重合顶点的多段线,已标示，请先确认后再运行此命令。")) ;
		AfxMessageBox(strMsg) ;
		return ;
	}

	//将多段线不必要的顶点删除（前后两段线方向一致）
	for (int i=0; i<nLen; i++)
	{
		AcDbEntity* pEnt = NULL ;
		long nHandle = nArrayHandle.GetAt(i) ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
				int iNumVert = pPolyLine->numVerts() ;
				for (int j=0; j<iNumVert-2; j++)
				{
					AcGeLineSeg2d lineCur, lineNext ;
					pPolyLine->getLineSegAt(j, lineCur) ;
					pPolyLine->getLineSegAt(j+1, lineNext) ;
					AcGeTol tol ;
					tol.setEqualVector(dTolCheckGd) ;
					if (lineCur.isParallelTo(lineNext, tol))
					{
						bHasErro = TRUE ;
						acutPrintf(_T("\n多段线在点(%.3f,%.3f)处有多余顶点，已删除！"), lineCur.endPoint().x, lineCur.endPoint().y) ;
						pPolyLine->upgradeOpen() ;
						pPolyLine->removeVertexAt(j+1) ;
						pPolyLine->setColorIndex(3) ;
						pPolyLine->downgradeOpen() ;
						break ;
					}
				}
			}

			pEnt->close() ;
		}
	}	
	if (bHasErro==TRUE)
	{
		strMsg.Format(_T("发现有多余顶点的多段线,已标示，请先确认后再运行此命令。")) ;
		AfxMessageBox(strMsg) ;
		return ;
	}

	//首或尾不在道岔反位的线全部标示出来	
	strHasFinishPt = _T("") ;
	CLongArray nArrayHandleAllDc ;
	int iNumAllDc = this->GetAllDc(nArrayHandleAllDc) ;

	for (int i=0; i<iNumAllDc; i++)
	{
		long nHandleCurDc = nArrayHandleAllDc.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandleCurDc, pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;

				CLongArray nArrayHandleIntersectLine, nArrayIndexOfVertex ;
				AcGePoint3dArray pt3dArrayIntersect ;
				int iDwIntersectMoveToVertex = 0 ;

				this->GetDcConLineDFW(pRef, nArrayHandleIntersectLine, nArrayIndexOfVertex, pt3dArrayIntersect, iDwIntersectMoveToVertex) ;
				if(nArrayHandleIntersectLine.GetCount()>1&&nArrayIndexOfVertex.GetCount()>1)
				{
					long nHandleFw = nArrayHandleIntersectLine.GetAt(1) ;
					long nVertex = nArrayIndexOfVertex.GetAt(1) ;
					CString strCurPt ;
					strCurPt.Format(_T("%d-%d"), nHandleFw, nVertex==0?0:1) ;
					strHasFinishPt.AppendFormat(_T("%s,"), strCurPt) ;
				}
			}
			pEnt->close() ;
		}
	}
	int iNumNotConFw = 0 ;
	for (int i=0; i<nLen; i++)
	{
		long nHandleLine = nArrayHandle.GetAt(i) ;
		CString strCurPt ;
		for (int j=0; j<2; j++)
		{
			strCurPt.Format(_T("%d-%d"), nHandleLine, j) ;
			if (strHasFinishPt.Find(strCurPt)==-1)
			{
				m_mysys.SetEntColorIndex(nHandleLine, 3) ;
				iNumNotConFw++ ;
				break;
			}
		}
	}
	strMsg.Format(_T("发现%d条线，其起点或终点不在道岔反位，已标示，请注意检查。"), iNumNotConFw) ;
	acutPrintf(_T("\n%s"),strMsg) ;
	AfxMessageBox(strMsg) ;
}

// 当前图纸所有道岔
int CZnSxt::GetAllDc(CLongArray& nArrayHandleDc)
{
	int iRet = 0 ;

	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);
	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	CString strSql ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;

				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;				
				if (strBlkName.Left(2)==_T("DC"))
				{
					UINT nHandle = m_mysys.GetHandle(pEnt) ;
					nArrayHandleDc.Add(nHandle) ;
					iRet++ ;
				}
			}

			pEnt->close() ;
		}	
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return iRet ;
}

// 在相应的线段上绘制电缆信息字符串（从SetCableString分离出来，为复用）
int CZnSxt::DrawCableString(long nHandleCableLine, const CString& strCableString, int iStringType)
{
	AcDbEntity* pEnt = NULL ;
	if(m_mysys.OpenAcDbEntity(nHandleCableLine, pEnt, AcDb::kForRead))
	{
		AcDbPolyline* pPolyLine = AcDbPolyline::cast(pEnt) ;
		AcGeLineSeg3d lineSeg ;
		int iIndexVertMax = 0 ;
		double dLenMax = 0 ;
		for (int i=0; i<pPolyLine->numVerts()-1; i++)
		{
			pPolyLine->getLineSegAt(i, lineSeg) ;
			double dLen = lineSeg.length() ;
			if (dLen>dLenMax)
			{
				dLenMax = dLen ;
				iIndexVertMax = i ;
			}
		}

		double dHeight = 2, dWidthFactor = 0.7, dDistToLine = 1.5 ;
		AcDb::TextHorzMode txthorzmod = AcDb::kTextMid ;
		AcDb::TextVertMode txtvertmod = AcDb::kTextBase ;

		pPolyLine->getLineSegAt(iIndexVertMax, lineSeg) ;
		AcGeVector3d vec = lineSeg.direction() ;
		AcGePoint3d pt_3d_mid = lineSeg.midPoint() ;
		AcGePoint3d pt_3d_midtmp = pt_3d_mid ;
		double dAngleTextToLine = vec.angleOnPlane(AcGePlane::kXYPlane)+PI/2 ;

		//连接线小于文本长度的（比如转辙机箱盒之间），需要特殊处理
		double dTextLen = m_mysys.GetTextLen(strCableString, 2, 0.7) ;
		if (dTextLen>dLenMax&&iStringType==0) 
		{
			//begin 本段代码一般对转辙机有用
			double dAngleJxg = 0.00012345 ;

			if (m_iCurDljlType==0)
			{
				long nHandleJXG = 0 ;
				AcGePoint3d pt_3d_start ;
				pPolyLine->getStartPoint(pt_3d_start) ;
				CLongArray nArrayHandleFindBox ;
				CZnUtility::FindConBox(pt_3d_start, nArrayHandleFindBox) ;
				int iNumFind = nArrayHandleFindBox.GetCount() ;
				if (iNumFind==1)
				{
					if (m_mysys.GetXdata(nArrayHandleFindBox.GetAt(0), _T("BELONG_ENT"), nHandleJXG))
					{
						dAngleJxg = m_mysys.GetAngle(nHandleJXG) ;
					}
				}
			}

			//end 本段代码一般对转辙机有用

			dHeight = 1 ;
			dWidthFactor = 0.5 ;
			dDistToLine = 2.5 ;
			pPolyLine->getStartPoint(pt_3d_midtmp) ;
			if (dAngleTextToLine>=PI/2&&dAngleTextToLine<=PI||dAngleTextToLine>=2*PI&&dAngleTextToLine<=5*PI/2)
			{
				txthorzmod = AcDb::kTextRight ;
				if (dAngleJxg>PI/2&&dAngleJxg<=3*PI/2)
				{
					txtvertmod = AcDb::kTextTop ;
				}
			}
			else
			{
				dAngleTextToLine-= PI ;
				txthorzmod = AcDb::kTextLeft ;
				if (dAngleJxg>PI/2&&dAngleJxg<=3*PI/2)
				{
					txtvertmod = AcDb::kTextTop ;
				}
			}
			if (dAngleJxg!=0.00012345)
			{
				if (dAngleJxg>PI/2&&dAngleJxg<=3*PI/2)
				{
					dDistToLine*=-1 ;
				}
			}

			//连接线小于文本长度的（比如转辙机箱盒之间），需要绘制标注线

			AcGePoint3d pt_3d_dim[4] ;				
			m_mysys.GetPoint(pt_3d_midtmp, dDistToLine>0?dDistToLine-0.2:dDistToLine+0.2, dAngleTextToLine, pt_3d_dim[1]) ;
			m_mysys.GetPoint(pt_3d_dim[1], 3, vec.angleOnPlane(AcGePlane::kXYPlane)+PI, pt_3d_dim[0]) ;
			pt_3d_dim[3] = pt_3d_mid ;
			pt_3d_dim[2] = m_mysys.GetMidPoint(pt_3d_dim[1], pt_3d_dim[3]) ;
			AcGePoint3dArray pt3dArrayDim ;
			for (int i=0; i<4; i++)
			{
				pt3dArrayDim.append(pt_3d_dim[i]) ;
			}
			//if (iStringType==0)
			//{
				AcDbObjectId objIdDim = m_mysys.AddAcDbPolyLine(pt3dArrayDim, 0, m_iColorIndexCur) ;
				this->SetLayer(objIdDim, m_iCurDljlType) ;
				AcDbEntity* pEntDim = NULL ;
				if (m_mysys.OpenAcDbEntity(objIdDim, pEntDim))
				{
					AcDbPolyline* pPolyLineDim = AcDbPolyline::cast(pEntDim) ;
					pPolyLineDim->setWidthsAt(2, 0.2, 0) ;
					m_mysys.SetXdata(pEntDim, _T("IS_CABLESTRING_DIM"), 1) ;
					m_mysys.SetXdata(pEntDim, _T("BELONG_ENT"), nHandleCableLine) ;
					pEntDim->close() ;
				}
			//}
		}

		AcGePoint3d pt_3d_text ;
		m_mysys.GetPoint(pt_3d_midtmp, dDistToLine, dAngleTextToLine, pt_3d_text) ;
		if (iStringType==0)
		{
			AcDbObjectId objId ;
			m_mysys.AddText(objId, strCableString, pt_3d_text, pt_3d_text, txthorzmod, txtvertmod, dHeight, dWidthFactor, vec.angleOnPlane(AcGePlane::kXYPlane), m_iColorIndexCur) ;
			this->SetLayer(objId, m_iCurDljlType) ;
			m_mysys.SetXdata(objId, _T("IS_CABLEINFO"), 1) ;
			m_mysys.SetXdata(objId, _T("BELONG_ENT"), nHandleCableLine) ;
		}
		else if (iStringType==1)
		{
			AcGeVector3d vec2 = pt_3d_midtmp - pt_3d_text ;
			vec2*=2 ;
			AcGePoint3d pt_3d_text2 ;
			m_mysys.GetPoint(pt_3d_text, vec2.length(), vec2.angleOnPlane(AcGePlane::kXYPlane), pt_3d_text2) ;
			AcDbObjectId objId2 ;
			m_mysys.AddText(objId2, strCableString, pt_3d_text2, pt_3d_text2, txthorzmod, txtvertmod, 1.5, dWidthFactor, vec.angleOnPlane(AcGePlane::kXYPlane), m_iColorIndexCur) ;
			this->SetLayer(objId2, m_iCurDljlType) ;
			m_mysys.SetXdata(objId2, _T("IS_CABLESN"), 1) ;
			m_mysys.SetXdata(objId2, _T("BELONG_ENT"), nHandleCableLine) ;
		}

		pEnt->close() ;
	}

	return 0;
}

// 找出属于指定handle的实体，并递归属于他的所有实体, iType=0不递归，只找一层
void CZnSxt::FindEntBelong(long nHandleSrc, CLongArray& nArrayHandleBelong, int iType)
{
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			long nHandleTmp = 0 ;
			m_mysys.GetXdata(pEnt, _T("BELONG_ENT"), nHandleTmp) ;
			if (nHandleTmp==nHandleSrc)
			{
				long nHandleCur = m_mysys.GetHandle(pEnt) ;
				nArrayHandleBelong.Add(nHandleCur) ;
				if (iType>0)
				{
					FindEntBelong(nHandleCur, nArrayHandleBelong, iType) ;
				}
			}
			pEnt->close() ;
		}
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;
}

 // 取得信号机/道岔/轨道属性数据
void CZnSxt::GetEntData(AcDbEntity* pEnt, CEntDATA& entData)
{
	CString strClassName = entData.GetClassType() ;
	CString strXdata ;
	long iXdata = 0 ;
	if (strClassName==_T("CXhjDATA"))
	{
		CXhjDATA *pDATA = dynamic_cast<CXhjDATA*>(&entData) ;
		AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
		m_mysys.GetAttValue(pRef, _T("XHJNAME"), pDATA->m_strName) ;
		if(m_mysys.GetXdata(pEnt, _T("LOC"), iXdata))
		{
			pDATA->m_nLoc = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISTRAIN"), iXdata ) )
		{
			pDATA->m_bIsTrain = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("BOXTYPE"), strXdata) )
		{
			pDATA->m_strBoxType = strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("CORENUMI"), iXdata) )
		{
			pDATA->m_nCoreNumI = iXdata ;
		}						
		if (m_mysys.GetXdata(pEnt, _T("CORENUMII"), iXdata) )
		{
			pDATA->m_nCoreNumII= iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("BOXPOS"), strXdata))
		{
			pDATA->m_strBoxPos= strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("HASDDUNIT"), iXdata))
		{
			pDATA->m_bHasDDUnit = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISALU"), iXdata) )
		{
			pDATA->m_bIsAlu = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("HASPHONE"), iXdata) )
		{
			pDATA->m_bHasPhone = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("DSNUM"), iXdata) )
		{
			pDATA->m_nDSNum = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("SPEEDLIMIT"), iXdata) )
		{
			pDATA->m_nSpeedLimit = iXdata ;
		}
	}
	else 	if (strClassName==_T("CGdDATA"))
	{
		CGdDATA *pDATA = dynamic_cast<CGdDATA*>(&entData) ;
		if(m_mysys.GetXdata(pEnt, _T("GUIDAONAME"), strXdata))
		{
			pDATA->m_strName = strXdata ;
		}						
		if(m_mysys.GetXdata(pEnt, _T("CIRCUITTYPE"), strXdata))
		{
			pDATA->m_strCircuitType = strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("DEVOFHZ25"), strXdata ) )
		{
			pDATA->m_str25HzDev = strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISDH"), iXdata) )
		{
			pDATA->m_bIsDH = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISDMH"), iXdata) )
		{
			pDATA->m_bIsDMH = iXdata ;
		}						
		if (m_mysys.GetXdata(pEnt, _T("IS4LINE"), iXdata) )
		{
			pDATA->m_bIs4Line= iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISSHAREXB"), iXdata))
		{
			pDATA->m_bIsShareXB= iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("IS1FNJ"), iXdata))
		{
			pDATA->m_bIs1FnJ = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISMAINSEC"), iXdata) )
		{
			pDATA->m_bIsMainSec = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("LEFT_FORS"), strXdata) )
		{
			pDATA->m_strLeftFOrS= strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("RIGHT_FORS"), strXdata) )
		{
			pDATA->m_strRightFOrS= strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("FREQ_LEFT"), strXdata) )
		{
			pDATA->m_strFreqLeft = strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("FREQ_RIGHT"), strXdata) )
		{
			pDATA->m_strFreqRight = strXdata ;
		}
	}
	else 	if (strClassName==_T("CDcDATA"))
	{
		CDcDATA *pDATA = dynamic_cast<CDcDATA*>(&entData) ;
		AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
		m_mysys.GetAttValue(pRef, _T("BIANHAO"), pDATA->m_strName) ;
		if(m_mysys.GetXdata(pEnt, _T("LOC"), iXdata))
		{
			pDATA->m_nLoc = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("JGQYNUM"), iXdata ) )
		{
			if (iXdata==0)
			{
				iXdata = 1 ;
			}
			pDATA->m_nJG_QyNum = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("JGQYTYPE"), strXdata) )
		{
			if (!strXdata.IsEmpty())
			{
				pDATA->m_strJG_QyType = strXdata ;
			}
		}
		if (m_mysys.GetXdata(pEnt, _T("JGHASMT"), iXdata) )
		{
			pDATA->m_bJG_HasMT = iXdata ;
		}						
		if (m_mysys.GetXdata(pEnt, _T("JGQYPOS"), strXdata) )
		{
			pDATA->m_strJG_QyPos= strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("XGQYNUM"), iXdata ) )
		{
			pDATA->m_nXG_QyNum = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("XGQYTYPE"), strXdata) )
		{
			pDATA->m_strXG_QyType = strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("XGHASMT"), iXdata) )
		{
			pDATA->m_bXG_HasMT = iXdata ;
		}						
		if (m_mysys.GetXdata(pEnt, _T("XGQYPOS"), strXdata) )
		{
			pDATA->m_strXG_QyPos= strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("BOXTYPE"), strXdata))
		{
			pDATA->m_strBoxType= strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISSINGLEACT"), iXdata))
		{
			pDATA->m_bIsSingleAct = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ISCOMPLEX"), iXdata) )
		{
			pDATA->m_bIsComplex = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("RELATIONDC"), strXdata) )
		{
			pDATA->m_strRelationDc = strXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("ACTINDEX"), iXdata) )
		{
			pDATA->m_nActIndex = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("HASPHONE"), iXdata) )
		{
			pDATA->m_bHasPhone = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("HASDCQKBJ"), iXdata) )
		{
			pDATA->m_bHasDCQKBJ = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("SPEEDLIMIT"), iXdata) )
		{
			pDATA->m_nSpeedLimit = iXdata ;
		}
		if (m_mysys.GetXdata(pEnt, _T("CUTJYJPOS"), iXdata) )
		{
			pDATA->m_iCutJYJPos= iXdata ;
		}
	}
}
// 取得信号机/道岔/轨道属性数据
void CZnSxt::GetEntData(long nHandle, CEntDATA& entData)
{
	if (nHandle>0)
	{
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			this->GetEntData(pEnt, entData) ;
			pEnt->close() ;
		}
	}
}

// 设置信号机/道岔/轨道属性数据
void CZnSxt::SetEntData(AcDbEntity* pEnt, CEntDATA* pEntData)
{
	CString strClassName = pEntData->GetClassType() ;
	CString strXdata ;
	long iXdata = 0 ;
	if (strClassName==_T("CXhjDATA"))
	{
		CXhjDATA *pDATA = dynamic_cast<CXhjDATA*>(pEntData);
		AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
		m_mysys.SetAttValue(pRef, _T("XHJNAME"),  pDATA->m_strName ) ;
		m_mysys.SetXdata(pEnt, _T("LOC"), pDATA->m_nLoc) ;							
		m_mysys.SetXdata(pEnt, _T("ISTRAIN"), (long)(pDATA->m_bIsTrain)) ;
		m_mysys.SetXdata(pEnt, _T("BOXTYPE"), pDATA->m_strBoxType) ;
		m_mysys.SetXdata(pEnt, _T("CORENUMI"), pDATA->m_nCoreNumI) ;
		m_mysys.SetXdata(pEnt, _T("CORENUMII"), pDATA->m_nCoreNumII) ;				
		m_mysys.SetXdata(pEnt, _T("BOXPOS"), pDATA->m_strBoxPos) ;
		m_mysys.SetXdata(pEnt, _T("HASDDUNIT"), (long)(pDATA->m_bHasDDUnit));
		m_mysys.SetXdata(pEnt, _T("ISALU"), (long)(pDATA->m_bIsAlu)) ;
		m_mysys.SetXdata(pEnt, _T("HASPHONE"), (long)(pDATA->m_bHasPhone)) ;
		m_mysys.SetXdata(pEnt, _T("DSNUM"), pDATA->m_nDSNum) ;
		m_mysys.SetXdata(pEnt, _T("SPEEDLIMIT"), pDATA->m_nSpeedLimit) ;
	}
	else 	if (strClassName==_T("CGdDATA"))
	{
		CGdDATA *pDATA = dynamic_cast<CGdDATA*>(pEntData) ;
		m_mysys.SetXdata(pEnt, _T("GUIDAONAME"), pDATA->m_strName) ;
		m_mysys.SetXdata(pEnt, _T("CIRCUITTYPE"), pDATA->m_strCircuitType) ;
		m_mysys.SetXdata(pEnt, _T("DEVOFHZ25"), pDATA->m_str25HzDev) ;
		m_mysys.SetXdata(pEnt, _T("ISDH"), (long)(pDATA->m_bIsDH)) ;
		m_mysys.SetXdata(pEnt, _T("ISDMH"), (long)(pDATA->m_bIsDMH)) ;
		m_mysys.SetXdata(pEnt, _T("IS4LINE"), (long)(pDATA->m_bIs4Line)) ;
		m_mysys.SetXdata(pEnt, _T("ISSHAREXB"), (long)(pDATA->m_bIsShareXB)) ;
		m_mysys.SetXdata(pEnt, _T("IS1FNJ"), (long)(pDATA->m_bIs1FnJ));
		m_mysys.SetXdata(pEnt, _T("ISMAINSEC"), (long)(pDATA->m_bIsMainSec)) ;
		m_mysys.SetXdata(pEnt, _T("LEFT_FORS"), pDATA->m_strLeftFOrS) ;
		m_mysys.SetXdata(pEnt, _T("RIGHT_FORS"), pDATA->m_strRightFOrS) ;
		m_mysys.SetXdata(pEnt, _T("FREQ_LEFT"), pDATA->m_strFreqLeft) ;
		m_mysys.SetXdata(pEnt, _T("FREQ_RIGHT"), pDATA->m_strFreqRight) ;
	}
	else 	if (strClassName==_T("CDcDATA"))
	{
		CDcDATA *pDATA = dynamic_cast<CDcDATA*>(pEntData) ;
		AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
		m_mysys.SetAttValue(pRef, _T("BIANHAO"), pDATA->m_strName) ;
		m_mysys.SetXdata(pEnt, _T("LOC"), pDATA->m_nLoc) ;	
		m_mysys.SetXdata(pEnt, _T("JGQYNUM"), pDATA->m_nJG_QyNum ) ;
		m_mysys.SetXdata(pEnt, _T("JGQYTYPE"), pDATA->m_strJG_QyType) ;
		m_mysys.SetXdata(pEnt, _T("JGHASMT"), (long)(pDATA->m_bJG_HasMT)) ;
		m_mysys.SetXdata(pEnt, _T("JGQYPOS"), pDATA->m_strJG_QyPos) ;
		m_mysys.SetXdata(pEnt, _T("XGQYNUM"), pDATA->m_nXG_QyNum ) ;
		m_mysys.SetXdata(pEnt, _T("XGQYTYPE"), pDATA->m_strXG_QyType) ;
		m_mysys.SetXdata(pEnt, _T("XGHASMT"), (long)pDATA->m_bXG_HasMT) ;
		m_mysys.SetXdata(pEnt, _T("XGQYPOS"), pDATA->m_strXG_QyPos) ;
		m_mysys.SetXdata(pEnt, _T("BOXTYPE"), pDATA->m_strBoxType) ;
		m_mysys.SetXdata(pEnt, _T("ISSINGLEACT"), (long)(pDATA->m_bIsSingleAct)) ;
		m_mysys.SetXdata(pEnt, _T("ISCOMPLEX"), (long)(pDATA->m_bIsComplex)) ;
		m_mysys.SetXdata(pEnt, _T("RELATIONDC"), pDATA->m_strRelationDc) ;
		m_mysys.SetXdata(pEnt, _T("ACTINDEX"), pDATA->m_nActIndex) ;
		m_mysys.SetXdata(pEnt, _T("HASPHONE"), (long)(pDATA->m_bHasPhone)) ;
		m_mysys.SetXdata(pEnt, _T("HASDCQKBJ"), (long)(pDATA->m_bHasDCQKBJ)) ;
		m_mysys.SetXdata(pEnt, _T("SPEEDLIMIT"), pDATA->m_nSpeedLimit) ;
		m_mysys.SetXdata(pEnt, _T("CUTJYJPOS"), pDATA->m_iCutJYJPos) ;
	}
}
// 设置信号机/道岔/轨道属性数据
void CZnSxt::SetEntData(long nHandle, CEntDATA* pEntData)
{
	if (nHandle>0)
	{
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForWrite))
		{
			this->SetEntData(pEnt, pEntData) ;
			pEnt->close() ;
		}
	}
}

// 清除BELONG_ENT属性为nHandleBelong的实体, iType=0不递归，只找一层
int CZnSxt::ClearEnt(long nHandleBelong, int iType)
{
	int iRet = 0 ;
	CLongArray nArrayHandle ;
	this->FindEntBelong(nHandleBelong, nArrayHandle, iType) ;
	iRet = m_mysys.Erase(nArrayHandle) ;

	return iRet ;
}

//更新关联道岔属性,iMode=1时，是删除关联（将strConDc的关联道岔删除strDc）
int CZnSxt::UpdataConDc(const CString& strDc, const CString& strConDc, int iMode)
{
	CString strMsg ;

	CStringArray strArrayDc ;
	CBlkUtility::DivideString(strConDc, _T(","), strArrayDc) ;
	//strArrayDc.InsertAt(0, strCurDc) ;

	if (iMode==1)
	{
		for (int i=0; i<strArrayDc.GetCount(); i++)
		{
			CString strDcTmp = strArrayDc.GetAt(i) ;
			CLongArray nArrayHandleTmp ;
			int iNumDc = this->FindDc(strDcTmp, nArrayHandleTmp) ;
			if (iNumDc==1) //找到一个名称为strDcTmp的道岔
			{
				CString strConDcTmp ;
				m_mysys.GetXdata(nArrayHandleTmp.GetAt(0), _T("RELATIONDC"), strConDcTmp) ;
				if (!strConDcTmp.IsEmpty())
				{
					CStringArray strArray1 ;
					CBlkUtility::DivideString(strConDcTmp, _T(","), strArray1) ;
					int iLoc = CBlkUtility::FindStrInArray(strArray1, strDc) ;
					if (iLoc!=-1)
					{
						strArray1.RemoveAt(iLoc) ;
						CString strRet ;
						CBlkUtility::ConvertArrayToString(strArray1, _T(","), strRet) ;
                        m_mysys.SetXdata(nArrayHandleTmp.GetAt(0), _T("RELATIONDC"), strRet) ;
						if (strRet.IsEmpty())
						{
							 m_mysys.SetXdata(nArrayHandleTmp.GetAt(0), _T("ISSINGLEACT"), (long)1) ;
						}
					}
				}
			}
		}
	}
	else
	{
		CLongArray nArrayHandleConDc ;
		for (int i=0; i<strArrayDc.GetCount(); i++)
		{
			CString strDcTmp = strArrayDc.GetAt(i) ;
			if (strDcTmp==strDc)
			{
				strMsg.Format(_T("%s中有和%s相同编号的道岔，将不更新其多动关联字段！"), strConDc, strDcTmp) ;
				AfxMessageBox(strMsg) ;
				return 0 ;
			}
			CLongArray nArrayHandleTmp ;
			int iNumDc = this->FindDc(strDcTmp, nArrayHandleTmp) ;
			if (iNumDc==0)
			{
				strMsg.Format(_T("没有找到编号为%s的道岔，将不更新其多动关联字段！"), strDcTmp) ;
				AfxMessageBox(strMsg) ;
				return 0 ;
			}
			else if (iNumDc>1)
			{
				strMsg.Format(_T("找到多于1个编号为%s的道岔，将不更新其多动关联字段！"), strDcTmp) ;
				AfxMessageBox(strMsg) ;
				return 0 ;
			}
			else if (iNumDc==1)
			{
				nArrayHandleConDc.Add(nArrayHandleTmp.GetAt(0)) ;
			}
		}

		CString strDcSrc = strDc ;
		for (int i=0; i<strArrayDc.GetCount(); i++)
		{
			CString strDcTmp = strArrayDc.GetAt(i) ;
			strArrayDc.SetAt(i, strDcSrc) ;
			strDcSrc = strDcTmp ;
			CString strConDcTmp  ;
			CBlkUtility::ConvertArrayToString(strArrayDc, _T(","), strConDcTmp) ;	
			m_mysys.SetXdata(nArrayHandleConDc.GetAt(i), _T("RELATIONDC"), strConDcTmp) ;		
			m_mysys.SetXdata(nArrayHandleConDc.GetAt(i), _T("ISSINGLEACT"), (long)0) ;	
		}
	}
	
	return 1;
}

// 查找指定名称的道岔
int CZnSxt::FindDc(const CString& strName , CLongArray& nArrayHandle)
{
	int iRet = 0 ;

	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;

				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;				
				if (strBlkName.Left(2)==_T("DC"))
				{
					CString strBianHao ;
					if (m_mysys.GetAttValue(pRef, _T("BIANHAO"), strBianHao))
					{
						if (strBianHao==strName)
						{
							long nHandle = m_mysys.GetHandle(pRef) ;
							nArrayHandle.Add(nHandle) ;
							iRet++ ;
						}
					}
				}
			}

			pEnt->close() ;
		}
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;

	return iRet ;
}

// 道岔几动，共几动（此处的几动是对于网络图而言，非实际）
int CZnSxt::GetDcActionInfo(const CString& strQyType, int iActionNum, int iActionIndex, CString& strActionInfo)
{
		if (strQyType==_T("ZD6-D"))
		{
			strActionInfo.Format(_T("%d/%d"), iActionIndex, iActionNum) ;
		}
		else if (strQyType==_T("ZD6-EJ"))
		{
			strActionInfo.Format(_T("%d/%d"), iActionIndex, iActionNum) ;
		}
		else if (strQyType==_T("ZD6-EJJ"))
		{
			strActionInfo.Format(_T("1/1")) ;
		}
		else if (strQyType==_T("ZYJ7+SH6"))
		{
			strActionInfo.Format(_T("1/1")) ;
		}
		else if (strQyType==_T("ZYJ7+SH6+SH6"))
		{
			strActionInfo.Format(_T("1/1")) ;
		}
		else	if (strQyType==_T("ZYJ7")||strQyType==_T("S700K"))
		{
			strActionInfo.Format(_T("1/1")) ;
		}

	return 0;
}

// 根据当前径路类型，设置其所在层
int CZnSxt::SetLayer(const AcDbObjectId& objId, int iType)
{
	long nHandle = m_mysys.GetHandle(objId) ;
	this->SetLayer(nHandle, iType) ;
	return 0;
}

// 根据当前径路类型，设置其所在层
int CZnSxt::SetLayer(long nHandle, int iType)
{
	if (iType==0)
	{
		m_mysys.SetLayer(nHandle, _T("CRSC_SJY_XTS_SXT_DLJL_ZZJ")) ;
	}
	else if (iType==1)
	{
		m_mysys.SetLayer(nHandle, _T("CRSC_SJY_XTS_SXT_DLJL_XHJ")) ;
	}
	else if (iType==2)
	{
		m_mysys.SetLayer(nHandle, _T("CRSC_SJY_XTS_SXT_DLJL_GD")) ;
	}
	else if (iType==3)
	{
		m_mysys.SetLayer(nHandle, _T("CRSC_SJY_XTS_SXT_DLJL_DMH")) ;
	}
	return 0;
}

// 显示轨道名称（辅助信息）
int CZnSxt::ShowGdName(AcDbEntity* pEnt)
{
	AcDbObjectId objId = m_pDb->clayer() ;
	m_mysys.SetCLayer( _T("PMT_SHOWINFO_GUIDAONAME")) ;

	if (pEnt->isKindOf(AcDbPolyline::desc()))
	{
		CString strGuiDaoName ;
		if (m_mysys.GetXdata(pEnt, _T("GUIDAONAME"), strGuiDaoName))
		{
			long nHandleGd = m_mysys.GetHandle(pEnt) ;
			CLongArray nArrayBelong ;
			this->FindEntBelong(nHandleGd, nArrayBelong) ;
			//long nHandShowGdName  = 0 ;
			int iNumFind = 0 ;
			for (int i=0; i<nArrayBelong.GetCount(); i++)
			{
				long iXdata = 0 ;
				if (m_mysys.GetXdata(nArrayBelong.GetAt(i), _T("PMT_SHOWINFO_GUIDAONAME"), iXdata)&&iXdata==1)
				{
					//nHandShowGdName = nArrayBelong.GetAt(i) ;
					m_mysys.Erase(nArrayBelong.GetAt(i)) ;
					iNumFind++ ;
				}
			}

			AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;
			AcGePoint3d pt_3d_left(0,0,0), pt_3d_right(0,0,0) ;
			pPolyLine->getPointAt(0, pt_3d_left) ;
			pPolyLine->getPointAt(1, pt_3d_right) ;
			AcGeLineSeg3d lineSeg3d(pt_3d_left, pt_3d_right) ;
			AcGePoint3d pt_3d_mid = lineSeg3d.midPoint() ;
			AcGeVector3d vec = lineSeg3d.direction() ;

			AcDbObjectId objIdGuiDaoName ;
			m_mysys.AddText(objIdGuiDaoName, strGuiDaoName, pt_3d_mid, pt_3d_mid, AcDb::kTextCenter, AcDb::kTextVertMid, 2.5, 0.8, vec.angleOnPlane(AcGePlane::kXYPlane)) ;
			m_mysys.SetXdata(objIdGuiDaoName, _T("PMT_SHOWINFO_GUIDAONAME"), (long)1) ;
			m_mysys.SetXdata(objIdGuiDaoName, _T("BELONG_ENT"), nHandleGd) ;	
		}						
	}

	m_pDb->setClayer(objId) ;

	return 0;
}


// 显示轨道送受电（辅助信息）
int CZnSxt::ShowGdFS(AcDbEntity* pEnt)
{
	AcDbObjectId objId = m_pDb->clayer() ;
	m_mysys.SetCLayer( _T("PMT_SHOWINFO_FSD")) ;

	if (pEnt->isKindOf(AcDbPolyline::desc()))
	{
		CString strGuiDaoName ;
		if (m_mysys.GetXdata(pEnt, _T("GUIDAONAME"), strGuiDaoName))
		{
			long nHandleGd = m_mysys.GetHandle(pEnt) ;
			CLongArray nArrayBelong ;
			this->FindEntBelong(nHandleGd, nArrayBelong) ;
			int iNumFind = 0 ;
			for (int i=0; i<nArrayBelong.GetCount(); i++)
			{
				long iXdata = 0 ;
				if (m_mysys.GetXdata(nArrayBelong.GetAt(i), _T("PMT_SHOWINFO_FSD"), iXdata)&&iXdata==1)
				{
					m_mysys.Erase(nArrayBelong.GetAt(i)) ;
					iNumFind++ ;
				}
			}

			AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;
			AcGePoint3d pt_3d_left(0,0,0), pt_3d_right(0,0,0) ;
			pPolyLine->getStartPoint(pt_3d_left) ;
			pPolyLine->getEndPoint(pt_3d_right) ;
			CString strLeftFORS, strRightFORS  ;
			CString strBlockName ;
			AcDbBlockReference *pRef = NULL ;
			//左侧
			if (m_mysys.GetXdata(pEnt, _T("LEFT_FORS"), strLeftFORS))
			{
				if (strLeftFORS!=_T(""))
				{
					strBlockName.Format(_T("BOX_FSD_%s_0"), strLeftFORS) ;
					pt_3d_left.x+=2.2 ;
					if(m_mysys.InsertBlock(pRef, strBlockName, pt_3d_left))
					{
						m_mysys.SetXdata(pRef, _T("PMT_SHOWINFO_FSD"), 1) ;
						m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleGd) ;
						pRef->close() ;
						pRef = NULL ;
					}
				}
			}	
			//右侧
			if (m_mysys.GetXdata(pEnt, _T("RIGHT_FORS"), strRightFORS))
			{
				if (strRightFORS!=_T(""))
				{
					strBlockName.Format(_T("BOX_FSD_%s_0"), strRightFORS) ;
					pt_3d_right.x-=2.2 ;
					if(m_mysys.InsertBlock(pRef, strBlockName, pt_3d_right))
					{
						m_mysys.SetXdata(pRef, _T("PMT_SHOWINFO_FSD"), 1) ;
						m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleGd) ;	
						pRef->close() ;
						pRef = NULL ;
					}
				}
			}
		}						
	}

	m_pDb->setClayer(objId) ;

	return 0;
}
// 显示隐藏道岔关联的切割绝缘节
int CZnSxt::ShowCutJYJ(long nHandle, bool bShow)
{
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;

				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;				
				if (strBlkName.Left(5)==_T("JYJ_JX"))
				{
					int nHandleBelongTmp= 0 ;
					m_mysys.GetXdata(pEnt, _T("BELONGDC"), nHandleBelongTmp) ;
					if (nHandleBelongTmp==nHandle)
					{
						pEnt->upgradeOpen() ;
						pEnt->setVisibility(bShow==true?AcDb::kVisible:AcDb::kInvisible) ;
						pEnt->downgradeOpen() ;
					}
				}
			}

			pEnt->close() ;
		}	
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;
	return 0;
}

// 显示隐藏所有切割绝缘节
int CZnSxt::ShowCutJYJ(bool bShow)
{
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;

				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;				
				if (strBlkName.Left(5)==_T("JYJ_JX"))
				{
					pEnt->upgradeOpen() ;
					pEnt->setVisibility(bShow==true?AcDb::kVisible:AcDb::kInvisible) ;
					pEnt->downgradeOpen() ;
				}
			}

			pEnt->close() ;
		}	
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;
	return 0;
}

int CZnSxt::Test2(void)
{
	CString strSql ;
	CADORecordset cSet(&m_AdoDb) ;
	//begin 计算盒子内芯线的编号 core_sn
	//////////////////////////////////////////////////////////////////////////
	//获取连接电缆的字符串，类似35-12(4)
	CString strCableStr = _T("") ;
	strSql.Format(_T("select dev_name from cable_core_draw where belong_box_handle_low=251 group by dev_name order by Max(pt_y) desc")) ;
	if (cSet.Open(strSql))
	{
		int iCout= cSet.GetRecordCount() ;
		acutPrintf(_T("\n%d"), iCout) ;
		while (!cSet.IsEOF())
		{
			CString strDevName ;
			cSet.GetFieldValue(_T("dev_name"), strDevName) ;
			acutPrintf(_T("\n%s"), strDevName) ;
			cSet.MoveNext() ;
		}
		cSet.Close() ;
	}
	return 0;
}

// 填充电缆芯线定义数据表
int CZnSxt::FillDefineCoreDetail(void)
{
	m_AdoDb.ClearTable(_T("define_core_detail")) ;

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from define_cable_type ")) ;
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nId = 0 ;
				cSet.GetFieldValue(_T("id"), nId) ;

				CString strCoreDetail ;
				cSet.GetFieldValue(_T("core_detail"), strCoreDetail) ;
				int iCoreDetail[4] = {0, 0, 0, 0} ; //分别对应普通芯、对绞，星绞，屏蔽星绞
				CStringArray strArrayCoreDetail ;
				CBlkUtility::DivideString(strCoreDetail, _T("+"), strArrayCoreDetail) ;
				int iCount = strArrayCoreDetail.GetCount() ;
				for (int i=(iCount-1); i>=0; i--)
				{
					CString strCorePart, strPre, strBack ;
					strCorePart = strArrayCoreDetail.GetAt(i) ;
					int iLoc = strCorePart.Find(_T("*")) ;
					if (iLoc!=-1)
					{
						strPre = strCorePart.Left(iLoc) ;
						strBack = strCorePart.Right(strCorePart.GetLength()-iLoc-1) ;
						if (strBack==_T("1"))
						{
							iCoreDetail[0] = _tstoi(strPre) ;
							cSet.Edit(); 
							cSet.SetFieldValue(_T("single_core_num"), iCoreDetail[0]) ;
							cSet.Update() ;
							for (int j=0; j<iCoreDetail[0]; j++)
							{
								strSql.Format(_T("insert into define_core_detail (cable_type_id, core_sn, core_group_type, index_in_group) values(%d, '%d', '1', %d)"), nId, j+1, j) ;
								m_AdoDb.Execute(strSql) ;
							}
						}
						else if (strBack==_T("2"))
						{
							iCoreDetail[1] = _tstoi(strPre) ;
							cSet.Edit(); 
							cSet.SetFieldValue(_T("double_core_num"), iCoreDetail[1]) ;
							cSet.Update() ;
							for (int j=0; j<iCoreDetail[1]; j++)
							{
								for (int m=0; m<2; m++)
								{
									strSql.Format(_T("insert into define_core_detail (cable_type_id, core_sn, core_group_type, index_in_group) values(%d, 'D%d-%d', '2', %d)"), nId, j+1, m+1, j) ;
									m_AdoDb.Execute(strSql) ;
								}
							}
						}
						else if (strBack==_T("4"))
						{
							iCoreDetail[2] = _tstoi(strPre) ;
							cSet.Edit(); 
							cSet.SetFieldValue(_T("four_core_num"), iCoreDetail[2]) ;
							cSet.Update() ;
							for (int j=0; j<iCoreDetail[2]; j++)
							{
								CString strRoman ;
								CBlkUtility::DigToRoman(j+1, strRoman, 0) ;
								for (int m=0; m<4; m++)
								{
									strSql.Format(_T("insert into define_core_detail (cable_type_id, core_sn, core_group_type, index_in_group) values(%d, '%s-%d', '4', %d)"), nId, strRoman,  m+1, j) ;
									m_AdoDb.Execute(strSql) ;
								}
							}
						}
						else if (strBack==_T("4P"))
						{
							iCoreDetail[3] = _tstoi(strPre) ;
							cSet.Edit(); 
							cSet.SetFieldValue(_T("fourp_core_num"), iCoreDetail[3]) ;
							cSet.Update() ;
							for (int j=0; j<iCoreDetail[3]; j++)
							{
								CString strRoman ;
								CBlkUtility::DigToRoman(j+1, strRoman, 0) ;
								for (int m=0; m<4; m++)
								{
									strSql.Format(_T("insert into define_core_detail (cable_type_id, core_sn, core_group_type, index_in_group) values(%d, '%sP-%d', '4P', %d)"), nId, strRoman,  m+1, j) ;
									m_AdoDb.Execute(strSql) ;
								}
							}
						}
					}

				}

				cSet.MoveNext() ;
			}
			cSet.MoveFirst() ;

			while(!cSet.IsEOF())
			{
				int iBackupNum = 0 ;
				long nId = 0 ;
				cSet.GetFieldValue(_T("id"), nId) ;

				CString  strBackupDetail ;			
				cSet.GetFieldValue(_T("backup_detail"), strBackupDetail) ;
				CStringArray strArrayBackupDetail ;
				CBlkUtility::DivideString(strBackupDetail, _T("+"), strArrayBackupDetail) ;
				int iCount = strArrayBackupDetail.GetCount() ;
				for (int i=0; i<iCount; i++)
				{
					CString strCorePart, strPre, strBack ;
					strCorePart = strArrayBackupDetail.GetAt(i) ;
					int iLoc = strCorePart.Find(_T("*")) ;
					if (iLoc!=-1)
					{
						strPre = strCorePart.Left(iLoc) ;
						strBack = strCorePart.Right(strCorePart.GetLength()-iLoc-1) ;
						if (strBack==_T("1"))
						{
							iBackupNum+=_tstoi(strPre) ;
						}
						else if (strBack==_T("2"))
						{
							iBackupNum+=(_tstoi(strPre)*2) ;
						}
						else if (strBack==_T("4"))
						{
							iBackupNum+=(_tstoi(strPre)*4) ;
						}
						else if (strBack==_T("4P"))
						{
							iBackupNum+=(_tstoi(strPre)*4) ;
						}
					}
				}

				//更新define_core_detail:backup
				strSql.Format(_T("update define_core_detail set backup=1 where id in(select top %d id from define_core_detail where cable_type_id=%d order by id desc)"), iBackupNum, nId) ;
				m_AdoDb.Execute(strSql) ;

				cSet.MoveNext() ;
			}


			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in test"));
	}
	return 0;
}

// 更新送受电盒子
int CZnSxt::UpdateFsBox(AcDbEntity* pEnt)
{
	CString strSql ;
	long nHandleLine = m_mysys.GetHandle(pEnt) ;
	for (int i=0; i<2; i++)
	{
		strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_%s=%d and sxt_ent_type\\100=2"), i==0?_T("right"):_T("left"), nHandleLine) ;
		long nHandleJyj = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleJyj) ;
		if (nHandleJyj!=0)
		{
			this->DrawBoxFsE(nHandleJyj) ;
		}
	}
	return 0;
}

// 更新电码化盒子
int CZnSxt::UpdateDmhBox(AcDbEntity* pEnt)
{
	CString strSql ;
	long nHandleLine = m_mysys.GetHandle(pEnt) ;
	for (int i=0; i<2; i++)
	{
		strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_%s=%d and sxt_ent_type\\100=2"), i==0?_T("right"):_T("left"), nHandleLine) ;
		long nHandleJyj = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleJyj) ;
		if (nHandleJyj!=0)
		{
			this->DrawBoxDMH(nHandleJyj) ;
		}
	}
	return 0;
}

// 绘制指定绝缘节两端的电码化箱盒
void CZnSxt::DrawBoxDMH(long nHandleJyj)
{
	//先清除原来的
	this->ClearBoxDMH(nHandleJyj) ;

	AcGePoint3d pt_3d_up, pt_3d_down ;
	BOOL bGetPtOfSxtJyj = this->GetPtOfSxtJyj(nHandleJyj, pt_3d_up, pt_3d_down) ;
	if (bGetPtOfSxtJyj==FALSE) //没有双线部分，直接退出，解决了没有双线图时运行此函数会导致平面图信号机等移位问题
	{
		return ;
	}

	//保存当前图层，设置要绘制的图层
	AcDbObjectId ojbIdLayerOld = m_pDb->clayer() ;
	m_mysys.SetCLayer(_T("CRSC_SJY_XTS_SXT_DLJL_DMH"), 4) ;
	m_iColorIndexCur = 256 ;

	// begin 绘制盒子
	CString strSql ;
	strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleJyj) ;
	int iUpOrDown = 0 ;
	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_upordown"), iUpOrDown) ;

	///begin 绝缘节所在线段信息	
	AcGeVector2d vecOnLine = GetAngleOfJyjOnLine(nHandleJyj) ;
	double dAngleOnLine = 0 ;
	dAngleOnLine = vecOnLine.angle() ;
	//end  绝缘节所在线段信息

	//左右轨道
	long nHandleLeftLine = 0, nHandleRightLine = 0 ;
	this->GetGdBesideJyj(nHandleJyj, nHandleLeftLine, nHandleRightLine) ;

	CGdDATA dataGdLeft, dataGdRight ;
	this->GetEntData(nHandleLeftLine, dataGdLeft) ;
	this->GetEntData(nHandleRightLine, dataGdRight) ;

	AcDbBlockReference* pRef = NULL ;
	AcGePoint3d pt_3d_cen; //双线中间线和绝缘节交点位置，此处为厄流插入点
	pt_3d_cen = m_mysys.GetMidPoint(pt_3d_up, pt_3d_down) ;
	double dEntX = pt_3d_cen.x, dEntY = pt_3d_cen.y ;
	CString strBlkName ;
	AcGePoint3d pt_3d_xb(0,0,0) ; //送受电盒子

	//双线中线一段
	AcGePoint2d pt_2d_cen1 = pt_3d_cen.convert2d(AcGePlane::kXYPlane)+vecOnLine ;
	AcGePoint3d pt_3d_cen1(0,0,0) ;
	m_mysys.ConvertPoint(pt_2d_cen1, pt_3d_cen1) ;

	CStringArray strArrayAtt ;

	//绝缘节左边
	if (dataGdLeft.m_strRightFOrS!=_T("N")&&dataGdLeft.m_bIsDMH)
	{
		CString strGd, strFreq ;
		m_mysys.GetXdata(nHandleLeftLine, _T("GUIDAONAME"), strGd) ;
		if (dataGdLeft.m_strRightFOrS!=_T("F"))
		{
			strGd.Append(_T("J")) ;
		}
		m_mysys.GetXdata(nHandleLeftLine, _T("FREQ_RIGHT"), strFreq) ;
		strArrayAtt.Add(strGd) ;
		strArrayAtt.Add(strFreq) ;
		strBlkName.Format(_T("BOX_FSD_%s_1"), dataGdLeft.m_strRightFOrS) ;
		double dBoxX = dEntX-4 ;
		double dBoxY = dEntY+(iUpOrDown==0?(dataGdLeft.m_bIsDH?10:6):-(dataGdLeft.m_bIsDH?10:6)) ;
		pt_3d_xb.x = dBoxX ;
		pt_3d_xb.y = dBoxY ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_xb, &strArrayAtt, FALSE))
		{
			m_mysys.RotationEnt(pRef, dAngleOnLine, pt_3d_cen) ;
			m_mysys.SetXdata(pRef, _T("IS_FOR"), (long)1) ; //0:for轨道电路，1:for电码化
			m_mysys.SetXdata(pRef, _T("BELONG_JYJ"), nHandleJyj) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleLeftLine) ;
			m_mysys.SetXdata(pRef, _T("LEFT_RIGHT"), (long)0) ;
			//m_mysys.SetAttValue(pRef, _T("FREQ"), strFreq, FALSE) ;
			pRef->close() ;
			pRef = NULL ;
		}
	}
	//绝缘节右边
	if (dataGdRight.m_strLeftFOrS!=_T("N")&&dataGdRight.m_bIsDMH)
	{
		CString strGd, strFreq ;
		m_mysys.GetXdata(nHandleRightLine, _T("GUIDAONAME"), strGd) ;
		if (dataGdRight.m_strLeftFOrS!=_T("F"))
		{
			strGd.Append(_T("J")) ;
		}
		m_mysys.GetXdata(nHandleRightLine, _T("FREQ_LEFT"), strFreq) ;
		strArrayAtt.RemoveAll() ;
		strArrayAtt.Add(strGd) ;
		strArrayAtt.Add(strFreq) ;
		strBlkName.Format(_T("BOX_FSD_%s_1"), dataGdRight.m_strLeftFOrS) ;
		double dBoxX = dEntX+4 ;
		double dBoxY = dEntY+(iUpOrDown==0?(dataGdRight.m_bIsDH?10:6):-(dataGdRight.m_bIsDH?10:6)) ;
		pt_3d_xb.x = dBoxX ;
		pt_3d_xb.y = dBoxY ;
		if (m_mysys.InsertBlock(pRef, strBlkName, pt_3d_xb, &strArrayAtt, FALSE))
		{
			m_mysys.RotationEnt(pRef, dAngleOnLine, pt_3d_cen) ;
			m_mysys.SetXdata(pRef, _T("IS_FOR"), (long)1) ; //0:for轨道电路，1:for电码化
			m_mysys.SetXdata(pRef, _T("BELONG_JYJ"), nHandleJyj) ;
			m_mysys.SetXdata(pRef, _T("BELONG_ENT"), nHandleRightLine) ;
			m_mysys.SetXdata(pRef, _T("LEFT_RIGHT"), (long)1) ;
			//m_mysys.SetAttValue(pRef, _T("FREQ"), strFreq, FALSE) ;

			pRef->close() ;
			pRef = NULL ;
		}
	}		
	//end 绘制盒子

	m_pDb->setClayer(ojbIdLayerOld) ; //恢复当前图层
}

// 清除指定的绝缘节两侧电码化箱盒
int CZnSxt::ClearBoxDMH(long nHandleJyj)
{
	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandle ;
	pRb = acutBuildList(1001, _T("BELONG_JYJ"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandle) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		long nHandle = nArrayHandle.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandle, pEnt, AcDb::kForRead))
		{
			long nHandleBelong = 0 ;
			m_mysys.GetXdata(pEnt, _T("BELONG_JYJ"), nHandleBelong) ;
			if (nHandleBelong==nHandleJyj)
			{
				long iIsFor = 0 ;
				m_mysys.GetXdata(pEnt, _T("IS_FOR"), iIsFor) ;
				if (iIsFor==1) //is_for=0表示是轨道电路送受电的盒子等，=1表示电码化的
				{
					pEnt	->upgradeOpen() ;
					pEnt->erase() ;
				}
			}
			pEnt->close() ;
		}		
	}
	return 0 ;
}

void CZnSxt::DrawBoxDMH(void)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type\\100=2 and ((sxt_ent_type mod 100)\\10)<>5 and sxt_ent_type<>201")) ; //整除为2的,且不是250、251之类的切割绝缘节，也不是201之类的渡线绝缘节
		if (cSet.Open(strSql))
		{
			while(!cSet.IsEOF())
			{
				long nHandle = 0 ;
				cSet.GetFieldValue(_T("sxt_ent_handle"), nHandle) ;
				this->DrawBoxDMH(nHandle) ;
				cSet.MoveNext() ;
			}
			cSet.Close() ;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in DrawBoxDMH"));
	}
}

//取得所有信号楼电缆径路和电缆径路
int CZnSxt::GetCable(CLongArray (&nArrayHandle)[2])
{
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();

	AcDbEntity * pEnt = NULL ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			//不可见的实体（自身隐藏或者所在层隐藏）放弃
			if (pEnt->visibility()==AcDb::kInvisible||m_mysys.IsOnOffLayer(pEnt))
			{
				pEnt->close() ;
				continue;
			}

			if (pEnt->isKindOf(AcDbPolyline::desc()))
			{
				long nIsCable = 0 ;
				if(m_mysys.GetXdata(pEnt, _T("IS_CABLE"), nIsCable)&&nIsCable==1)
				{
					long nHandleCur = m_mysys.GetHandle(pEnt) ;
					long nIsXhlCable = 0 ;
					if(m_mysys.GetXdata(pEnt, _T("IS_XHLCABLE"), nIsXhlCable)&&nIsXhlCable==1)
					{
						nArrayHandle[0].Add(nHandleCur) ;
					}
					else
					{
						nArrayHandle[1].Add(nHandleCur) ;
					}
				}
			}

			pEnt->close() ;
		}	
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;
	return 0;
}

int CZnSxt::ModEntData(int iType)
{
	if (iType==2)
	{
		struct resbuf* pRb ;
		int nLen = 0 ;
		CLongArray nArrayHandle ;
		pRb = acutBuildList(RTDXF0,_T("LWPOLYLINE"), 1001, _T("ISGUIDAO"),  0) ;
		nLen = m_mysys.GetSSEntHandle(NULL, NULL, NULL, pRb, nArrayHandle) ;
		acutRelRb(pRb) ;
		if (nLen==0)
		{
			return 0 ;
		}

		CEntPropertyDlg dlg ;
		CGdDATA *pDATA = new CGdDATA ;		
		for (int i=0; i<nLen; i++)
		{
			AcDbEntity* pEnt = NULL ;
			long nTemp = nArrayHandle.GetAt(i) ;
			if (m_mysys.OpenAcDbEntity(nTemp, pEnt, AcDb::kForRead))
			{		
				int iTmp = 0 ;
				CString strTmp =_T("") ;

				if(dlg.m_grid.m_iItemIsNull[0]==0&&m_mysys.GetXdata(pEnt, _T("GUIDAONAME"), strTmp))
				{
					if (i==0)
					{
						pDATA->m_strName = strTmp ;
					}
					else if (pDATA->m_strName!=strTmp)
					{
						dlg.m_grid.m_iItemIsNull[0] = 1 ;
					}
				}						
				if(dlg.m_grid.m_iItemIsNull[1]==0&&m_mysys.GetXdata(pEnt, _T("CIRCUITTYPE"), strTmp))
				{				
					if (i==0)
					{
						pDATA->m_strCircuitType = strTmp ;
					}
					else if (pDATA->m_strCircuitType!=strTmp)
					{
						dlg.m_grid.m_iItemIsNull[1] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[2]==0&&m_mysys.GetXdata(pEnt, _T("DEVOFHZ25"), strTmp ) )
				{
					if (i==0)
					{
						pDATA->m_str25HzDev = strTmp ;
					}
					else if (pDATA->m_str25HzDev!=strTmp)
					{
						dlg.m_grid.m_iItemIsNull[2] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[3]==0&&m_mysys.GetXdata(pEnt, _T("ISDH"), iTmp) )
				{
					if (i==0)
					{
						pDATA->m_bIsDH = iTmp ;
					}
					else if (pDATA->m_bIsDH!=iTmp)
					{
						dlg.m_grid.m_iItemIsNull[3] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[4]==0&&m_mysys.GetXdata(pEnt, _T("ISDMH"), iTmp) )
				{
					if (i==0)
					{
						pDATA->m_bIsDMH = iTmp ;
					}
					else if (pDATA->m_bIsDMH!=iTmp)
					{
						dlg.m_grid.m_iItemIsNull[4] = 1 ;
					}
				}						
				if (dlg.m_grid.m_iItemIsNull[5]==0&&m_mysys.GetXdata(pEnt, _T("IS4LINE"), iTmp) )
				{
					if (i==0)
					{
						pDATA->m_bIs4Line = iTmp ;
					}
					else if (pDATA->m_bIs4Line!=iTmp)
					{
						dlg.m_grid.m_iItemIsNull[5] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[6]==0&&m_mysys.GetXdata(pEnt, _T("ISSHAREXB"), iTmp))
				{
					if (i==0)
					{
						pDATA->m_bIsShareXB = iTmp ;
					}
					else if (pDATA->m_bIsShareXB!=iTmp)
					{
						dlg.m_grid.m_iItemIsNull[6] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[7]==0&&m_mysys.GetXdata(pEnt, _T("IS1FNJ"), iTmp))
				{
					if (i==0)
					{
						pDATA->m_bIs1FnJ = iTmp ;
					}
					else if (pDATA->m_bIs1FnJ!=iTmp)
					{
						dlg.m_grid.m_iItemIsNull[7] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[8]==0&&m_mysys.GetXdata(pEnt, _T("ISMAINSEC"), iTmp) )
				{
					if (i==0)
					{
						pDATA->m_bIsMainSec = iTmp ;
					}
					else if (pDATA->m_bIsMainSec!=iTmp)
					{
						dlg.m_grid.m_iItemIsNull[8] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[9]==0&&m_mysys.GetXdata(pEnt, _T("LEFT_FORS"), strTmp) )
				{
					if (i==0)
					{
						pDATA->m_strLeftFOrS = strTmp ;
					}
					else if (pDATA->m_strLeftFOrS!=strTmp)
					{
						dlg.m_grid.m_iItemIsNull[9] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[10]==0&&m_mysys.GetXdata(pEnt, _T("RIGHT_FORS"), strTmp) )
				{
					if (i==0)
					{
						pDATA->m_strRightFOrS = strTmp ;
					}
					else if (pDATA->m_strRightFOrS!=strTmp)
					{
						dlg.m_grid.m_iItemIsNull[10] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[11]==0&&m_mysys.GetXdata(pEnt, _T("FREQ_RIGHT"), strTmp) )
				{				
					if (i==0)
					{
						pDATA->m_strFreqRight = strTmp ;
					}
					else if (pDATA->m_strFreqRight!=strTmp)
					{
						dlg.m_grid.m_iItemIsNull[11] = 1 ;
					}
				}
				if (dlg.m_grid.m_iItemIsNull[12]==0&&m_mysys.GetXdata(pEnt, _T("FREQ_LEFT"), strTmp) )
				{
					if (i==0)
					{
						pDATA->m_strFreqLeft = strTmp ;
					}
					else if (pDATA->m_strFreqLeft!=strTmp)
					{
						dlg.m_grid.m_iItemIsNull[12] = 1 ;
					}
				}

				pEnt->close() ;
			}
		}
		dlg.m_grid.m_pEntDATA = pDATA ;
		if (dlg.DoModal()==IDOK)
		{
			CString strCellText = _T(""), strTmp = _T("") ;
			int iNumber = 0 ;
			for (int i=0; i<nArrayHandle.GetCount(); i++)
			{	
				long nHandleCur = nArrayHandle.GetAt(i) ;
				AcDbEntity* pEnt = NULL ;
				if (m_mysys.OpenAcDbEntity(nHandleCur, pEnt))
				{
					strCellText = dlg.m_grid.QuickGetText(0, 0) ;
					if (strCellText!=_T("*多种*"))
					{
						m_mysys.SetXdata(pEnt, _T("GUIDAONAME"), strCellText) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 1) ;		
					if (strCellText!=_T("*多种*"))
					{
						m_mysys.SetXdata(pEnt, _T("CIRCUITTYPE"), strCellText) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 2) ;	
					if (strCellText!=_T("*多种*"))
					{
						m_mysys.SetXdata(pEnt, _T("DEVOFHZ25"), strCellText) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 3) ;	
					if (strCellText!=_T("*多种*"))
					{
						iNumber = 0 ;
						iNumber = dlg.m_grid.QuickGetBool(0, 3) ;
						m_mysys.SetXdata(pEnt, _T("ISDH"), iNumber) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 4) ;	
					if (strCellText!=_T("*多种*"))
					{
						iNumber = 0 ;
						iNumber = dlg.m_grid.QuickGetBool(0, 4) ;
						m_mysys.SetXdata(pEnt, _T("ISDMH"), iNumber) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 5) ;	
					if (strCellText!=_T("*多种*"))
					{
						iNumber = 0 ;
						iNumber = dlg.m_grid.QuickGetBool(0, 5) ;
						m_mysys.SetXdata(pEnt, _T("IS4LINE"), iNumber) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 6) ;	
					if (strCellText!=_T("*多种*"))
					{
						iNumber = 0 ;
						iNumber = dlg.m_grid.QuickGetBool(0, 6) ;
						m_mysys.SetXdata(pEnt, _T("ISSHAREXB"), iNumber) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 7) ;	
					if (strCellText!=_T("*多种*"))
					{
						iNumber = 0 ;
						iNumber = dlg.m_grid.QuickGetBool(0, 7) ;
						m_mysys.SetXdata(pEnt, _T("IS1FNJ"), iNumber) ;
					}	
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 8) ;	
					if (strCellText!=_T("*多种*"))
					{
						iNumber = 0 ;
						iNumber = dlg.m_grid.QuickGetBool(0, 8) ;
						m_mysys.SetXdata(pEnt, _T("ISMAINSEC"), iNumber) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 9) ;	
					if (strCellText!=_T("*多种*"))
					{
						strTmp = _T("N") ;
						if (strCellText==_T("送电"))
						{
							strTmp = _T("F") ;
						}
						else if (strCellText==_T("受电"))
						{
							strTmp = _T("S") ;
						}
						m_mysys.SetXdata(pEnt, _T("LEFT_FORS"), strTmp) ;					
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 10) ;	
					if (strCellText!=_T("*多种*"))
					{
						strTmp = _T("N") ;
						if (strCellText==_T("送电"))
						{
							strTmp = _T("F") ;
						}
						else if (strCellText==_T("受电"))
						{
							strTmp = _T("S") ;
						}
						m_mysys.SetXdata(pEnt, _T("RIGHT_FORS"), strTmp) ;					
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 11) ;	
					if (strCellText!=_T("*多种*"))
					{
						m_mysys.SetXdata(pEnt, _T("FREQ_LEFT"), strCellText) ;
					}
					strCellText = _T("") ;
					strCellText = dlg.m_grid.QuickGetText(0, 12) ;	
					if (strCellText!=_T("*多种*"))
					{
						m_mysys.SetXdata(pEnt, _T("FREQ_RIGHT"), strCellText) ;
					}
					//同步更新相关信息
					pEnt->downgradeOpen() ;
					int iShowOrHide = 0 ;
					//if (m_mysys.ReadFromRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_GUIDAONAME"), iShowOrHide) &&iShowOrHide==0)
					CLongArray nArrayShowGdName ;
					if (FindShowGdName(pEnt, nArrayShowGdName)>0)
					{
						this->ShowGdName(pEnt) ; //更新轨道名称（辅助信息）
					}
					if (m_mysys.ReadFromRec(_T("PMT_SHOWINFO"), _T("PMT_SHOWINFO_FSD"), iShowOrHide) &&iShowOrHide==0)
					{
						this->ShowGdFS(pEnt) ; //更新送受电（辅助信息）
					}
					this->UpdateFsBox(pEnt) ; //更新送受电盒子（在双线中）
					this->UpdateDmhBox(pEnt) ; //更新电码化盒子（在双线中）

					pEnt->close() ;
				}
			}
		}
	}
	return 0;
}


int CZnSxt::GetCableParam(double& dCoeff,  vector<int > &vecCableParam)
{
	vecCableParam.resize(6) ;
	CZnUtility::GetCableParam(dCoeff, vecCableParam[0], vecCableParam[1],  vecCableParam[2], vecCableParam[3], vecCableParam[4], vecCableParam[5]) ;
	return 0;
}

// 查找辅助显示的轨道名称
int CZnSxt::FindShowGdName(AcDbEntity* pEntGd, CLongArray& nArrayHandle)
{
	int iRet = 0 ;

	long nHandleGd = m_mysys.GetHandle(pEntGd) ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandleTmp ;
	pRb = acutBuildList(RTDXF0,_T("TEXT"), 1001, _T("PMT_SHOWINFO_GUIDAONAME"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandleTmp) ;
	acutRelRb(pRb) ;
	for (int i=0; i<nLen; i++)
	{
		long nHandleCur = nArrayHandleTmp.GetAt(i) ;
		long nHandleBelong = 0 ;
		if (m_mysys.GetXdata(nHandleCur, _T("BELONG_ENT"), nHandleBelong))
		{
			if (nHandleBelong == nHandleGd )
			{
				nArrayHandle.Add(nHandleCur) ;
				iRet++ ;
			}
		}
	}

	return iRet ;
}

// 以绝缘节或信号机基点为中心构造一个小圆来求和其相交的多段线（左右轨道）
//返回值：0，错误；2，表示信号机/绝缘节在直线上；15，表示左右侧连线都有；5，只有右侧线；10，只有左侧线
int CZnSxt::GetIntersectPLine2(AcDbEntity *pEntSrc, CLongArray &nArrayHandleIntersect, CLongArray &nArrayIndexOfVertex, AcGePoint3dArray &pt3dArrayIntersect)
{
	int iRet = 0 ;

	if (pEntSrc->isKindOf(AcDbCircle::desc()))
	{
		AcDbCircle* pCircle = AcDbCircle::cast(pEntSrc) ;
		AcGePoint3d pt_3d_cen = pCircle->center() ; //圆心，同时也是绝缘节或者信号机基点

		AcDbBlockTable * pBlkTbl = NULL ;
		m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);

		AcDbBlockTableRecord * pBlkTblRec = NULL ;
		pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
		pBlkTbl->close() ;
		AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
		pBlkTblRec->newIterator( pBlkTblRecIter );
		pBlkTblRec->close();

		int iNumTwoIntersectPt = 0, iNumOneLeftIntersectPt = 0, iNumOneRightIntersectPt = 0 ;
		AcDbEntity * pEnt = NULL ;
		for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
		{
			if (iRet==0)
			{
				break;
			}
			//遍历并打开实体 ;
			if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
			{
				//只查询相交的多段线
				if (!pEnt->isEqualTo(pEntSrc)&&pEnt->isKindOf(AcDbPolyline::desc()))
				{
					AcDbPolyline *pPolyLine = AcDbPolyline::cast(pEnt) ;

					AcDb::Visibility bIsVisible  = pPolyLine->visibility() ;
					double dLenOfPline = m_mysys.GetLineLen(pPolyLine) ;
					if (bIsVisible==AcDb::kInvisible||m_mysys.IsOnOffLayer(pEnt)||dLenOfPline<1)
					{
						pEnt->close() ;
						continue;
					}

					AcGePoint3dArray arrayPt3d ;
					Acad::ErrorStatus es = pEntSrc->intersectWith(pEnt, AcDb::kOnBothOperands, arrayPt3d);
					int iPtNum = arrayPt3d.length() ;

					if(es==Acad::eOk && iPtNum>0&&iPtNum<3)
					{
						UINT nIndexOfVertex = 0 ;
						UINT nHandleIntersectEnt = 0 ;
						nHandleIntersectEnt = m_mysys.GetHandle(pEnt) ;
						AcGePoint3d pt_3d_intersect ;
// 						pt_3d_intersect = arrayPt3d.at(0) ;

						if (iPtNum==2) //和圆有2个交点的,
						{
							if ((iNumTwoIntersectPt+iNumOneLeftIntersectPt+iNumOneRightIntersectPt)==0)
							{
								iNumTwoIntersectPt++ ;
								nArrayHandleIntersect.Add(nHandleIntersectEnt) ;
								AcGeLineSeg3d linseg(arrayPt3d.at(0), arrayPt3d.at(1)) ;
								pt_3d_intersect = linseg.closestPointTo(pt_3d_cen) ; //此处交点以绝缘节或信号机基点到直线垂足为宜
								int iPtOnPLine = m_mysys.IsPointOnPolyLine(pPolyLine, pt_3d_intersect, nIndexOfVertex) ;
								nArrayIndexOfVertex.Add(iPtOnPLine) ;
								pt3dArrayIntersect.append(pt_3d_intersect) ;
								iRet = 2 ;
							}
							else
							{
								iRet = 0 ;
							}
						}
						else if (iPtNum==1) //和圆有1个交点的
						{
							pt_3d_intersect = arrayPt3d.at(0) ;
							if (pt_3d_intersect.x<pt_3d_cen.x) //交点在圆心左侧
							{
								if (iNumTwoIntersectPt==0&&iNumOneLeftIntersectPt==0)
								{
									iNumOneLeftIntersectPt++ ;
									nArrayHandleIntersect.Add(nHandleIntersectEnt) ;
									nArrayIndexOfVertex.Add(pPolyLine->numVerts()-1) ;
									AcGePoint3d pt_3d_end ;
									pPolyLine->getEndPoint(pt_3d_end) ;
									pt3dArrayIntersect.append(pt_3d_end) ;
									if (iRet==-1)
									{
										iRet = 1 ;
									}
									else if (iRet==5)
									{
										iRet = 1*10+5 ;
									}
									else
									{
										iRet = 0 ;
									}
								}
								else
								{
									iRet = 0 ;
								}
							}
							else
							{
								if (iNumTwoIntersectPt==0&&iNumOneRightIntersectPt==0)
								{
									iNumOneRightIntersectPt++ ;
									nArrayHandleIntersect.Add(nHandleIntersectEnt) ;
									nArrayIndexOfVertex.Add(0) ;
									AcGePoint3d pt_3d_start ;
									pPolyLine->getStartPoint(pt_3d_start) ;
									pt3dArrayIntersect.append(pt_3d_start) ;
									if (iRet==-1)
									{
										iRet = 5 ;
									}
									else if (iRet==1)
									{
										iRet = 5*10+1 ;
									}
									else
									{
										iRet = 0 ;
									}
								}
								else
								{
									iRet = 0 ;
								}
							}
						}
					}
				}

				pEnt->close() ;
			}		
		}
		delete pBlkTblRecIter ;
		pBlkTblRecIter = NULL ;
	}

	return iRet ;
}


// 取得属于指定道岔的多段线（在双线中）
int CZnSxt::GetSxBelongDc(long nHandleDc, long &nHandlePline)
{
	int iRet = 0 ;

	struct resbuf* pRb ;
	int nLen = 0 ;
	CLongArray nArrayHandleTmp ;
	pRb = acutBuildList(RTDXF0, _T("LWPOLYLINE"), 1001, _T("ForZZJ"),  0) ;
	nLen = m_mysys.GetSSEntHandle(_T("X"), NULL, NULL, pRb, nArrayHandleTmp) ;
	acutRelRb(pRb) ;

	for (int i=0; i<nLen; i++)
	{
		long nHandleCur = nArrayHandleTmp.GetAt(i) ;
		AcDbEntity* pEnt = NULL ;
		if (m_mysys.OpenAcDbEntity(nHandleCur, pEnt, AcDb::kForRead))
		{
			CString strForZZJ ;
			m_mysys.GetXdata(pEnt, _T("ForZZJ"), strForZZJ) ;
			CStringArray strArrayForZZJ ;
			CBlkUtility::DivideString(strForZZJ, _T("-"), strArrayForZZJ) ;
			if (strArrayForZZJ.GetCount()==5)
			{
				CString strTmp = strArrayForZZJ.GetAt(0) ;
				long nHandleDcTmp = 0 ;
				nHandleDcTmp = _ttol(strTmp) ;
				if (nHandleDcTmp==nHandleDc)
				{
					nHandlePline = nHandleCur ;
					iRet++ ;
					pEnt->close() ;
					break;
				}
			}
			pEnt->close() ;
		}		
	}
	return iRet ;
}
//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
void CZnSxt::GetPathGuiDao4( long nHandleLineStart,long nHandleLineEnd,vector<CString>&sVectorPath,vector<CString>&sDaocha, CStringArray &DaochaNum,CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	CStringArray nArrayDaoChaNum;
	nArrayDaoChaNum.Copy(DaochaNum);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//压入对应的道岔定反位
		acutPrintf(_T("\n 搜索结束"));
		for(int i=0;i<sVectorPath.size();i++)
		{
			//输出搜索到的结果
			acutPrintf(_T("\t第%d 轨道区段名为%s"),i,sVectorPath[i].GetString());
		}
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//打印经过道岔定反位
		acutPrintf(_T("\n 经过道岔："));
		for(int k=0;k<sDaocha.size();k++)
		{
			if(sDaocha[k].GetString()!=_T(""))
			{
				acutPrintf(_T("\t：%s"),sDaocha[k].GetString());
			}
		}
		for(int k=0;k<nArrayDaoChaNum.GetCount();k++)
		{	
			if(nArrayDaoChaNum[i].GetString()!=_T(""))
			{
				acutPrintf(_T("\t：%s"),nArrayDaoChaNum[k].GetString());
			}

		}
		/*		sDaocha.pop_back();*/
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassDaocha;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		FindNextLine4(nHandleLineStart,nHandleLineEnd,Dacha,PassDaocha,GuDao,nArrayHandleNext,bForword);
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					CStringArray Daochas;
					CBlkUtility::DivideString(PassDaocha[i],_T("_"),Daochas);
					for(int i=0;i<Daochas.GetCount();i++)
					{
						if(CBlkUtility::FindStrInArray(nArrayDaoChaNum,Daochas[i])==-1)
						{
							nArrayDaoChaNum.Add(Daochas[i]);
						}
					}
					//this->GetPathGuiDao2(nHandNext,nHandleLineEnd,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetPathGuiDao4(nHandNext,nHandleLineEnd,sVectorPath,sDaocha,nArrayDaoChaNum,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					sDaocha.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
void CZnSxt::GetPathGuiDao2( long nHandleLineStart,long nHandleLineEnd,vector<CString>&sVectorPath,vector<CString>&sDaocha, CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//压入对应的道岔定反位
		acutPrintf(_T("\n 搜索结束"));
		for(int i=0;i<sVectorPath.size();i++)
		{
			//输出搜索到的结果
			acutPrintf(_T("\t第%d 轨道区段名为%s"),i,sVectorPath[i].GetString());
		}
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//打印经过道岔定反位
		//acutPrintf(_T("\n 经过道岔："));
		// 		for(int k=0;k<sDaocha.size();k++)
		// 		{
		// 			if(sDaocha[k]!=_T(""))
		// 			{
		// 				acutPrintf(_T("%s;\t"),sDaocha[k].GetString());
		// 			}
		// 		}
		PrintGuoDaocha(sDaocha);
		/*		sDaocha.pop_back();*/
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		//存储走过的道岔
		CStringArray Dacha;
		FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					this->GetPathGuiDao2(nHandNext,nHandleLineEnd,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					sDaocha.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。
//Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
//vector<CString>sXHJ用于存储进路上经过的信号机：注意终点轨道上的信号机没有纳入考虑
void CZnSxt::GetPathGuiDaoAndXHJ( long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	static num=4;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		CLongArray nArrayPassXHJ;
		bool btoward=bForword;
		//获取终止轨道信号机
		this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
		CString  Name_PassXHJ;
		for(int k=0;k<nArrayPassXHJ.GetCount();k++)
		{
			CString name_xhj;
			GetEntName(nArrayPassXHJ[k],name_xhj);
			Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
		}
		sXHJ.push_back(Name_PassXHJ);
		oper_excel.WriteDatatoExcel(1,num,4,(num-3));
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//PrintGuoDaocha(sXHJ);
		vector<CString> tempXHJ;
		TiquGuoDaocha(sXHJ,tempXHJ);
		oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
		for(int i=0;i<GuDao.GetCount();i++)
		{
			if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
			{
				CString temp=_T("由")+sVectorPath[0];
				oper_excel.WriteDatatoExcel(1,num,5,temp);
				oper_excel.WriteDatatoExcel(1,num,17,_T("BS"));

			}
			else
			{
				CString temp=_T("至")+Gd_name;
				oper_excel.WriteDatatoExcel(1,num,5,temp);
				//写迎面进路
				oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
				oper_excel.WriteDatatoExcel(1,num,16,Gd_name);
			}
			CString AnniuEnd;
			CString AnniuStart;
			int count =tempXHJ.size();
			AnniuStart=tempXHJ[0]+_T("LA");
			AnniuEnd=tempXHJ[count-1]+_T("LA");
			CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
			oper_excel.WriteDatatoExcel(1,num,6,JinLuAnniu);
		}
		num++;
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		FindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetPathGuiDaoAndXHJ(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。
//Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
//vector<CString>sXHJ用于存储进路上经过的信号机：注意终点轨道上的信号机没有纳入考虑
//特别用于列车进路获取联锁表信息，增加起始信号机和终止信号机参数
void CZnSxt::GetLieChePathGuiDaoAndXHJ( long nHandleStartXHJ,long nHandleEndXHJ,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		CLongArray nArrayPassXHJ;
		bool btoward=bForword;
		//获取终止轨道信号机
		this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
		CString  Name_PassXHJ;
		for(int k=0;k<nArrayPassXHJ.GetCount();k++)
		{
			CString name_xhj;
			GetEntName(nArrayPassXHJ[k],name_xhj);
			Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
		}
		sXHJ.push_back(Name_PassXHJ);
	    oper_excel.WriteDatatoExcel(1,num,4,(num-3));
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//PrintGuoDaocha(sXHJ);
		vector<CString> tempXHJ;
		TiquGuoDaocha(sXHJ,tempXHJ);
		oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
			if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
			{
				CString temp=_T("由")+sVectorPath[0];
				oper_excel.WriteDatatoExcel(1,num,5,temp);
				oper_excel.WriteDatatoExcel(1,num,17,_T("BS"));

			}
			else
			{
				CString temp=_T("至")+Gd_name;
				oper_excel.WriteDatatoExcel(1,num,5,temp);
				//写迎面进路
				oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
				oper_excel.WriteDatatoExcel(1,num,16,Gd_name);
			}
			CString AnniuEnd;
			CString AnniuStart;
			GetEntName(nHandleStartXHJ,AnniuStart);
			oper_excel.WriteDatatoExcel(1,num,9,AnniuStart);
			AnniuStart+=_T("LA");
			GetEntName(nHandleEndXHJ,AnniuEnd);
			AnniuEnd+=_T("LA");
			CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
			oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		num++;
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayGuiDaoCX;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		LieCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayGuiDaoCX,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetLieChePathGuiDaoAndXHJ(nHandleStartXHJ,nHandleEndXHJ,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。
//Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
//vector<CString>sXHJ用于存储进路上经过的信号机：注意终点轨道上的信号机没有纳入考虑
//特别用于列车进路获取联锁表信息，增加起始信号机和终止信号机参数
void CZnSxt::GetLieChePathGuiDaoAndXHJ( CString& Start_Gd_name,long nHandleStartXHJ,long nHandleEndXHJ,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		CLongArray nArrayPassXHJ;
		bool btoward=bForword;
		//获取终止轨道信号机
		this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
		CString  Name_PassXHJ;
		for(int k=0;k<nArrayPassXHJ.GetCount();k++)
		{
			CString name_xhj;
			GetEntName(nArrayPassXHJ[k],name_xhj);
			Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
		}
		sXHJ.push_back(Name_PassXHJ);
		oper_excel.WriteDatatoExcel(1,num,4,(num-3));
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//PrintGuoDaocha(sXHJ);
		vector<CString> tempXHJ;
		TiquGuoDaocha(sXHJ,tempXHJ);
		oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
		{
			CString temp=_T("至")+Gd_name;
			oper_excel.WriteDatatoExcel(1,num,5,temp);
			//写迎面进路
			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
			oper_excel.WriteDatatoExcel(1,num,16,Gd_name);

		}
		else if(CBlkUtility::FindStrInArray(GuDao,Start_Gd_name)!=-1)
		{
			CString temp=_T("由")+Start_Gd_name;
			oper_excel.WriteDatatoExcel(1,num,5,temp);
			oper_excel.WriteDatatoExcel(1,num,17,_T("BS"));
		}
		CString AnniuEnd;
		CString AnniuStart;
		GetEntName(nHandleStartXHJ,AnniuStart);
		oper_excel.WriteDatatoExcel(1,num,9,AnniuStart);
		AnniuStart+=_T("LA");
		GetEntName(nHandleEndXHJ,AnniuEnd);
		AnniuEnd+=_T("LA");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		num++;
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		if(Gd_name==_T("15-17DG"))
		{
			Gd_name=Gd_name;
		}
// 		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
// 		{
// 			return;
// 		}
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayGuiDaoCX;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		LieCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayGuiDaoCX,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		for(int i=0;i<count;i++)
		{
			CString name;
			m_mysys.GetXdata(nArrayHandleNext.GetAt(i),_T("GUIDAONAME"),name);
			name=name;
		}
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetLieChePathGuiDaoAndXHJ(Start_Gd_name,nHandleStartXHJ,nHandleEndXHJ,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}


//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。
//Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
//vector<CString>sXHJ用于存储进路上经过的信号机：注意终点轨道上的信号机没有纳入考虑
//特别用于列车进路获取联锁表信息，增加起始信号机和终止信号机参数
//增加参数iJL_Cnt，用于统计变更进路个数，没有变更进路时，为1，有变更进路时大于1
/***********************************函数功能描述**********************************************************/
/*********函数名称：GetTongGuoPathGuiDaoAndXHJ******************************************************************************************************/
/*********函数功能：用于寻找通过进路，要求通过进路均为正线通过**************************************************************/
/*********输入：CString& Start_Gd_name,起始轨道名称；long nHandleStartXHJ,起始信号机句柄；long nHandleEndXHJ,终止信号机句柄；long& nHandleLineFirst,起始轨道句柄；******/
/****************long nHandleLineStart,本次调用时起始轨道句柄；long nHandleLineEnd,终止轨道句柄；***********************************************/
/****************long LastDaocha,上次调用时走过的道岔句柄；vector<CString>&sVectorPath,走过的轨道区段；vector<CString>&sDaocha,走过的道岔；*****/
/****************vector<CString>& sXHJ,走过的信号机；CStringArray &GuDao,平面图的股道名称；CLongArray&nArrayHandleLine,走过的轨道句柄；*/
/****************vector<CString> &vec_strGuiDaoCX,超限绝缘轨道，int &iJL_Cnt,改进路包括的进路条数；bool bForword，进路搜索方向************/
/*********输出：**************************************************************/
/************************注释：2015-07-16 pm-15:48 by luo*******************************************************/
void CZnSxt::GetJieChePathGuiDaoAndXHJ( CString& Start_Gd_name,long nHandleStartXHJ,long nHandleEndXHJ,long& nHandleLineFirst,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,vector<CString> &vec_strGuiDaoCX,int &iJL_Cnt,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		CLongArray nArrayPassXHJ;
		bool btoward=bForword;
		//获取终止轨道信号机
		this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
		CString  Name_PassXHJ;
		for(int k=0;k<nArrayPassXHJ.GetCount();k++)
		{
			CString name_xhj;
			GetEntName(nArrayPassXHJ[k],name_xhj);
			Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
		}
		sXHJ.push_back(Name_PassXHJ);
		//oper_excel.WriteDatatoExcel(1,num,4,(num-2));
		oper_excel.WriteDatatoExcel(1,num,4,iJLnum);
		vector<CString>tempGuidao;
		TiquGuoDaocha(sVectorPath,tempGuidao);
		int i_m=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleLineFirst);
		if(i_m!=-1)
		{
			vec_strGuiDaoCX.push_back(this->strArrayGuiDaoCX.GetAt(i_m));
		}
		else
		{
			vec_strGuiDaoCX.push_back(_T(""));
		}
		//CString strTemp;
		for(int i=0;i<vec_strGuiDaoCX.size();i++)
		{
			if(vec_strGuiDaoCX[i]!=_T(""))
			{
				CString strTemp;
				strTemp=_T("，")+vec_strGuiDaoCX[i];
				tempGuidao.push_back(strTemp);
			}
		}
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//PrintGuoDaocha(sXHJ);
		vector<CString> tempXHJ;
		TiquGuoDaocha(sXHJ,tempXHJ);
		oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
	    {
			CString temp=_T("至")+Gd_name;
	 	    oper_excel.WriteDatatoExcel(1,num,5,temp);
		 	//写迎面进路
		 	oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
		 	oper_excel.WriteDatatoExcel(1,num,16,Gd_name);
	
		}
		else if(CBlkUtility::FindStrInArray(GuDao,Start_Gd_name)!=-1)
		{
		 	CString temp=_T("由")+Start_Gd_name;
		 	oper_excel.WriteDatatoExcel(1,num,5,temp);
		 	oper_excel.WriteDatatoExcel(1,num,17,_T("BS"));
		}
		CString AnniuEnd;
		CString AnniuStart;
		GetEntName(nHandleStartXHJ,AnniuStart);
		oper_excel.WriteDatatoExcel(1,num,9,AnniuStart);
		AnniuStart+=_T("LA");
		GetEntName(nHandleEndXHJ,AnniuEnd);
		AnniuEnd+=_T("LA");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		//判断是接车还是发车，看起始信号机或终止信号机
		//GetHandleByName(str_xhj,nHandleDCTemp)
		//判断是否为正线，如果不为正线通过，则直接提前退出
		int iCntTemp=0;
		for(iCntTemp=0;iCntTemp<nArrayHandleTem.GetCount()-1;iCntTemp++)
		{
			long nHandle=nArrayHandleTem.GetAt(iCntTemp);
			double d_width1=0;
			double d_width2=0;
			CUserSystem my_sis;
			if(my_sis.GetPlineWidthAt(nHandle,0,d_width1,d_width2)==Acad::eOk)
			{
				if(fabs(d_width1-0.5)<=1e-6&&fabs(d_width2-0.5)<=1e-6)
				{//线宽必须为0.5
				}
				else
				{
					break;
				}
			}
			else
				break;
			long nHandleNext=0;
			if(FindNextZhiGuidao(nHandle,nHandleNext,bForword)==TRUE)
			{
				if(nHandleNext!=0&&nHandleNext==nArrayHandleTem.GetAt(iCntTemp+1))
				{
					if(my_sis.GetPlineWidthAt(nHandleNext,0,d_width1,d_width2)==Acad::eOk)
					{
						if(fabs(d_width1-0.5)<=1e-6&&fabs(d_width2-0.5)<=1e-6)
						{

						}
						else
						{
							break;
						}
					}
					else
						break;

				}
				else
					break;
			}
			else
				break;
		}
		//考虑加入条件判断
		if(iCntTemp==nArrayHandleTem.GetCount()-1)
		{
			oper_excel.WriteDatatoExcel(1,num,10,_T("U"));

		}
		else
		{
			oper_excel.WriteDatatoExcel(1,num,10,_T("UU"));
		}
		num++;
		iJL_Cnt++;
		this->iJLnum++;

		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{

		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		if(Gd_name==_T("15-17DG"))
		{
			Gd_name=Gd_name;
		}
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		LieCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		int count =0;
		count =nArrayHandleNext.GetCount();
		for(int i=0;i<count;i++)
		{
			CString name;
			m_mysys.GetXdata(nArrayHandleNext.GetAt(i),_T("GUIDAONAME"),name);
			name=name;
		}
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					vec_strGuiDaoCX.push_back(strArrayCXGdName.GetAt(i));
					long thisdaocha=nArrayHandleThisDC[i];
					this->GetJieChePathGuiDaoAndXHJ(Start_Gd_name,nHandleStartXHJ,nHandleEndXHJ,nHandleLineFirst,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,vec_strGuiDaoCX,iJL_Cnt,bForword);
					vec_strGuiDaoCX.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
			}
		}
	}
	sVectorPath.pop_back();
}

// 输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。
// Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
// vector<CString>sXHJ用于存储进路上经过的信号机：注意终点轨道上的信号机没有纳入考虑
// 特别用于列车进路获取联锁表信息，增加起始信号机和终止信号机参数
// 增加参数iJL_Cnt，用于统计变更进路个数，没有变更进路时，为1，有变更进路时大于1
/***********************************函数功能描述**********************************************************/
/*********函数名称：GetTongGuoPathGuiDaoAndXHJ******************************************************************************************************/
/*********函数功能：用于寻找通过进路，要求通过进路均为正线通过**************************************************************/
/*********输入：CString& Start_Gd_name,起始轨道名称；long nHandleStartXHJ,起始信号机句柄；long nHandleEndXHJ,终止信号机句柄；long& nHandleLineFirst,起始轨道句柄；******/
/****************long nHandleLineStart,本次调用时起始轨道句柄；long nHandleLineEnd,终止轨道句柄；***********************************************/
/****************long LastDaocha,上次调用时走过的道岔句柄；vector<CString>&sVectorPath,走过的轨道区段；vector<CString>&sDaocha,走过的道岔；*****/
/****************vector<CString>& sXHJ,走过的信号机；CStringArray &GuDao,平面图的股道名称；CLongArray&nArrayHandleLine,走过的轨道句柄；*/
/****************vector<CString> &vec_strGuiDaoCX,超限绝缘轨道，int &iJL_Cnt,改进路包括的进路条数；bool bForword，进路搜索方向************/
/*********输出：**************************************************************/
/************************注释：2015-07-16 pm-15:48 by luo*******************************************************/
void CZnSxt::GetTongGuoPathGuiDaoAndXHJ( CString& Start_Gd_name,long nHandleStartXHJ,long nHandleEndXHJ,long& nHandleLineFirst,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,vector<CString> &vec_strGuiDaoCX,int &iJL_Cnt,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		//通过进路中，结束轨道区段不用加进去
		//sVectorPath.push_back(Gd_name);
		//nArrayHandleTem.Add(nHandleLineStart);
		int iCntTemp=0;
		for(iCntTemp=0;iCntTemp<nArrayHandleTem.GetCount()-1;iCntTemp++)
		{
			long nHandle=nArrayHandleTem.GetAt(iCntTemp);
			double d_width1=0;
			double d_width2=0;
			CUserSystem my_sis;
			if(my_sis.GetPlineWidthAt(nHandle,0,d_width1,d_width2)==Acad::eOk)
			{
				if(fabs(d_width1-0.5)<=1e-6&&fabs(d_width2-0.5)<=1e-6)
				{//线宽必须为0.5
				}
				else
				{
					return;
				}
			}
			else
				return;
			long nHandleNext=0;
			if(FindNextZhiGuidao(nHandle,nHandleNext,bForword)==TRUE)
			{
				if(nHandleNext!=0&&nHandleNext==nArrayHandleTem.GetAt(iCntTemp+1))
				{
					if(my_sis.GetPlineWidthAt(nHandleNext,0,d_width1,d_width2)==Acad::eOk)
					{
						if(fabs(d_width1-0.5)<=1e-6&&fabs(d_width2-0.5)<=1e-6)
						{

						}
						else
						{
							return;
						}
					}
					else
						return;

				}
				else
					return;
			}
			else
				return;
		}
		CLongArray nArrayPassXHJ;
		bool btoward=bForword;
		//获取终止轨道信号机
		this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
		CString  Name_PassXHJ;
		for(int k=0;k<nArrayPassXHJ.GetCount();k++)
		{
			CString name_xhj;
			GetEntName(nArrayPassXHJ[k],name_xhj);
			Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
		}
		sXHJ.push_back(Name_PassXHJ);
		//通过进路不写编号
		//oper_excel.WriteDatatoExcel(1,num,4,(num-2));
		vector<CString>tempGuidao;
		TiquGuoDaocha(sVectorPath,tempGuidao);
		int i_m=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleLineFirst);
		if(i_m!=-1)
		{
			vec_strGuiDaoCX.push_back(this->strArrayGuiDaoCX.GetAt(i_m));
		}
		else
		{
			vec_strGuiDaoCX.push_back(_T(""));
		}
		//CString strTemp;
		for(int i=0;i<vec_strGuiDaoCX.size();i++)
		{
			if(vec_strGuiDaoCX[i]!=_T(""))
			{
				CString strTemp;
				strTemp=_T("，")+vec_strGuiDaoCX[i];
				tempGuidao.push_back(strTemp);
			}
		}
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//PrintGuoDaocha(sXHJ);
		vector<CString> tempXHJ;
		TiquGuoDaocha(sXHJ,tempXHJ);
		oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
// 		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
// 		{
// 			CString temp=_T("至")+Gd_name;
// 			oper_excel.WriteDatatoExcel(1,num,5,temp);
// 			//写迎面进路
// 			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
// 			oper_excel.WriteDatatoExcel(1,num,16,Gd_name);
// 
// 		}
// 		else if(CBlkUtility::FindStrInArray(GuDao,Start_Gd_name)!=-1)
// 		{
// 			CString temp=_T("由")+Start_Gd_name;
// 			oper_excel.WriteDatatoExcel(1,num,5,temp);
// 			oper_excel.WriteDatatoExcel(1,num,17,_T("BS"));
// 		}
		CString AnniuEnd;
		CString AnniuStart;
		GetEntName(nHandleStartXHJ,AnniuStart);
		oper_excel.WriteDatatoExcel(1,num,9,AnniuStart);
		AnniuStart+=_T("TA");
		GetEntName(nHandleEndXHJ,AnniuEnd);
		AnniuEnd+=_T("LA");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		//判断是接车还是发车，看起始信号机或终止信号机
		//GetHandleByName(str_xhj,nHandleDCTemp)
		//判断是否为正线，如果不为正线通过，则直接提前退出
		
		//考虑加入条件判断
		if(iCntTemp==nArrayHandleTem.GetCount()-1)
		{
			oper_excel.WriteDatatoExcel(1,num,10,_T("L或U"));

		}
// 		else
// 		{
// 			oper_excel.WriteDatatoExcel(1,num,10,_T("UU"));
// 		}
		this->num=this->num+2;
		iJL_Cnt++;
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{

		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		if(Gd_name==_T("15-17DG"))
		{
			Gd_name=Gd_name;
		}
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		LieCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		int count =0;
		count =nArrayHandleNext.GetCount();
		for(int i=0;i<count;i++)
		{
			CString name;
			m_mysys.GetXdata(nArrayHandleNext.GetAt(i),_T("GUIDAONAME"),name);
			name=name;
		}
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					vec_strGuiDaoCX.push_back(strArrayCXGdName.GetAt(i));
					long thisdaocha=nArrayHandleThisDC[i];
					this->GetTongGuoPathGuiDaoAndXHJ(Start_Gd_name,nHandleStartXHJ,nHandleEndXHJ,nHandleLineFirst,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,vec_strGuiDaoCX,iJL_Cnt,bForword);
					vec_strGuiDaoCX.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
			}
		}
	}
	sVectorPath.pop_back();
}

//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。
//Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
//vector<CString>sXHJ用于存储进路上经过的信号机：注意终点轨道上的信号机没有纳入考虑
//特别用于列车进路获取联锁表信息，增加起始信号机和终止信号机参数
//增加参数iJL_Cnt，用于统计变更进路个数，没有变更进路时，为1，有变更进路时大于1
void CZnSxt::GetFaChePathGuiDaoAndXHJ( CString& Start_Gd_name,long nHandleStartXHJ,long nHandleEndXHJ,long& nHandleLineFirst,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,vector<CString> &vec_strGuiDaoCX,int &iJL_Cnt,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		//发车最后一条轨道不用加入
		//sVectorPath.push_back(Gd_name);
		//nArrayHandleTem.Add(nHandleLineStart);
		CLongArray nArrayPassXHJ;
		bool btoward=bForword;
		//获取终止轨道信号机
		this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
		CString  Name_PassXHJ;
		for(int k=0;k<nArrayPassXHJ.GetCount();k++)
		{
			CString name_xhj;
			GetEntName(nArrayPassXHJ[k],name_xhj);
			Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
		}
		sXHJ.push_back(Name_PassXHJ);
		oper_excel.WriteDatatoExcel(1,num,4,this->iJLnum);
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		int i_m=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleLineFirst);
		if(i_m!=-1)
		{
			vec_strGuiDaoCX.push_back(this->strArrayGuiDaoCX.GetAt(i_m));
		}
		else
		{
			vec_strGuiDaoCX.push_back(_T(""));
		}
		//CString strTemp;
		for(int i=0;i<vec_strGuiDaoCX.size();i++)
		{
			if(vec_strGuiDaoCX[i]!=_T(""))
			{
				CString strTemp;
				strTemp=_T("，")+vec_strGuiDaoCX[i];
				tempGuidao.push_back(strTemp);
			}
		}
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//PrintGuoDaocha(sXHJ);
		vector<CString> tempXHJ;
		TiquGuoDaocha(sXHJ,tempXHJ);
		oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
		{
			CString temp=_T("至")+Gd_name;
			oper_excel.WriteDatatoExcel(1,num,5,temp);
			//写迎面进路
			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
			oper_excel.WriteDatatoExcel(1,num,16,Gd_name);

		}
		else if(CBlkUtility::FindStrInArray(GuDao,Start_Gd_name)!=-1)
		{
			CString temp=_T("由")+Start_Gd_name;
			oper_excel.WriteDatatoExcel(1,num,5,temp);
			oper_excel.WriteDatatoExcel(1,num,17,_T("BS"));
		}
		CString AnniuEnd;
		CString AnniuStart;
		GetEntName(nHandleStartXHJ,AnniuStart);
		oper_excel.WriteDatatoExcel(1,num,9,AnniuStart);
		AnniuStart+=_T("LA");
		GetEntName(nHandleEndXHJ,AnniuEnd);
		AnniuEnd+=_T("LA");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		//判断是接车还是发车，看起始信号机或终止信号机
		oper_excel.WriteDatatoExcel(1,num,10,_T("L或LU或U"));
		num++;
		iJL_Cnt++;
		this->iJLnum++;
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{

		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		if(Gd_name==_T("15-17DG"))
		{
			Gd_name=Gd_name;
		}
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		LieCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		int count =0;
		count =nArrayHandleNext.GetCount();
		for(int i=0;i<count;i++)
		{
			CString name;
			m_mysys.GetXdata(nArrayHandleNext.GetAt(i),_T("GUIDAONAME"),name);
			name=name;
		}
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					vec_strGuiDaoCX.push_back(strArrayCXGdName.GetAt(i));
					long thisdaocha=nArrayHandleThisDC[i];
					this->GetFaChePathGuiDaoAndXHJ(Start_Gd_name,nHandleStartXHJ,nHandleEndXHJ,nHandleLineFirst,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,vec_strGuiDaoCX,iJL_Cnt,bForword);
					vec_strGuiDaoCX.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
			}
		}
	}
	sVectorPath.pop_back();
}
/************************函数：GetDiaoChePathGuiDaoAndXHJ********************************************************************************************/
/***********功能：通过调车进路的起始轨道和终止轨道，输出进路走过的轨道和道岔以及信号机，并将联锁信息写入Excel*****************************************/
/***********输入：CString& StartXHJ,起始信号机名称；CString& EndXHJ,终端信号机名称；long nHandleLineStart,起始轨道；********************/
/******************long nHandleLineEnd,终止轨道；long LastDaocha,走到起始轨道上一次走过的道岔；********************************************/
/******************CStringArray &GuDao,股道名称；bool bForword，进路推进方向***************************************************************/
/***********输出：vector<CString>&sVectorPath,存储走过的轨道区段；vector<CString>&sDaocha,存储走过的道岔；**************************/
/******************vector<CString>& sXHJ,存储走过的信号机；CLongArray&nArrayHandleLine,推进过程中的下一个轨道区段********************/ 
/******************************注释：2015-06-06 pm 14:44 by luo*********************************************************************************/
void CZnSxt::GetDiaoChePathGuiDaoAndXHJ( CString& StartXHJ,CString& EndXHJ,long& nHandleLineFirst,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,vector<CString>& vec_strGuiDaoCX,int &iJL_Cnt,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	long t1=GetTickCount();
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		CStringArray str_array_xhj;
		TiquEffectiveData(sXHJ,str_array_xhj);
		CString AnniuEnd;
		CString AnniuStart;
		//如果终端信号机不在进路上，则返回
		CString temp=EndXHJ;
		CString jinlu;
		int count=str_array_xhj.GetCount();
		if(CBlkUtility::FindStrInArray(str_array_xhj,temp)==-1&&CBlkUtility::FindStrInArray(GuDao,temp)==-1)
		{
			return;
		}
		else if(CBlkUtility::FindStrInArray(GuDao,temp)!=-1)
		{
			//为股道时
			jinlu=_T("至")+temp;
			if(count>0)
			{
				AnniuEnd=str_array_xhj[count-1]+_T("DA");
			}
		}
		else
		{
			//为信号机
			long nHandleDC=0;
			GetHandleByName(temp,nHandleDC);
			//判断信号机方向
			int iToward=-1;
			if(this->GetBlockToward(nHandleDC,iToward)==TRUE)
			{
				if(iToward==1)
				{
					//向右
					if(bForword==true)
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							AnniuEnd=str_array_xhj[count-2]+_T("A");
						}
						else if(count>0)
						{
							AnniuEnd=str_array_xhj[count-1]+_T("A");
						}
						// oper_excel.oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
					}
					else
					{
						CString tempZ;
						if(count>1)
						{
							tempZ=str_array_xhj[count-1];
						}
						jinlu=_T("向")+temp;
						AnniuEnd =temp+_T("A");
					}

				}
				else if(iToward==2)
				{
					if(bForword==true)
					{
						jinlu=_T("向")+temp;
						if(count>0)
							AnniuEnd =str_array_xhj[count-1]+_T("A");
					}
					else
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							AnniuEnd=str_array_xhj[count-2]+_T("A");
						}
						else if(count>0)
							AnniuEnd=str_array_xhj[count-1]+_T("A");
					}
				}

			}
		}
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//CLongArray nArrayPassXHJ;
		oper_excel.WriteDatatoExcel(1,num,4,num-3);
		//oper_excel.WriteDatatoExcel(1,)
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		//当前轨道是否存在超限绝缘
		//增加超限区段,第一条轨道线并未考虑到，在这里加上
	 		int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleLineFirst);
	 		if(i!=-1)
	 		{
	 			vec_strGuiDaoCX.push_back(this->strArrayGuiDaoCX.GetAt(i));
	 		}
	 		else
	 		{
				vec_strGuiDaoCX.push_back(_T(""));
	 		}
		//CString strTemp;
		for(int i=0;i<vec_strGuiDaoCX.size();i++)
		{
			if(vec_strGuiDaoCX[i]!=_T(""))
			{
				CString strTemp;
			    strTemp=_T("，")+vec_strGuiDaoCX[i];
				tempGuidao.push_back(strTemp);
			}
		}
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		CStringArray strArray_GXHJ;
		TiquEffectiveData(sXHJ,strArray_GXHJ);
		//去掉走过的信号机中同方向的信号机
		vector<CString > vec_xhj_didui;
		for(int i=0;i<strArray_GXHJ.GetCount();i++)
		{
			int fangxiang=-1;
			long nHandleDCTemp=0;
			GetHandleByName(strArray_GXHJ.GetAt(i),nHandleDCTemp);
			if(GetBlockToward(nHandleDCTemp,fangxiang)==TRUE)
			{
				if(fangxiang==1&&bForword==false)
				{
					vec_xhj_didui.push_back(strArray_GXHJ.GetAt(i)+_T("，"));
				}
				else if(fangxiang==2&&bForword==true)
				{
					vec_xhj_didui.push_back(strArray_GXHJ.GetAt(i)+_T("，"));
				}
			}
		}
		long lastdc=0;
		CStringArray nArrayDXDC;
		CLongArray  nArrayHandleNext;
		FindNextDuiXiangDCByLine(nHandleLineEnd,lastdc,GuDao,nArrayHandleNext,nArrayDXDC,bForword);
		for(int i=0;i<nArrayDXDC.GetCount();i++)
		{
			vec_xhj_didui.push_back(nArrayDXDC.GetAt(i)+_T("，"));
			acutPrintf(_T("对向：%s"),nArrayDXDC.GetAt(i));
		}
		//进站信号机敌对
		long nHandleLine_Start=0;
		long nHandleDC_Start=0;
		GetHandleByName(StartXHJ,nHandleDC_Start);
		bool fangxiang=false;
		GetXHJ_ZuoCe_GdLine(nHandleDC_Start,nHandleLine_Start,fangxiang);
		long lastdc3=0;
		CStringArray nArrayLCXHJ2;
		CLongArray nArrayHandleNext3;
		FindNextLieCheXHJByLine(nHandleLine_Start,lastdc3,GuDao,nArrayHandleNext3,nArrayLCXHJ2,!fangxiang);
		if(nArrayLCXHJ2.GetCount()!=0)
		{
			//只有进站信号机敌对信号存在，敌对列车信号才能存在
			long lastdc2=0;
			CStringArray nArrayLCXHJ;
			CLongArray nArrayHandleNext2;
			FindNextLieCheXHJByLine(nHandleLineEnd,lastdc2,GuDao,nArrayHandleNext2,nArrayLCXHJ,bForword);
			if(nArrayLCXHJ.GetCount()!=0&&nArrayLCXHJ2.GetCount()!=0)
			{
				for(int i=0;i<nArrayLCXHJ2.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ2.GetAt(i)+_T("L，"));
					acutPrintf(_T("同向敌对：%s"),nArrayLCXHJ2.GetAt(i));
				}
				for(int i=0;i<nArrayLCXHJ.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ.GetAt(i)+_T("L，"));
					acutPrintf(_T("反向敌对：%s"),nArrayLCXHJ.GetAt(i));
				}
			}
		}
		oper_excel.WriteDatatoExcel(1,num,13,vec_xhj_didui);
		//写进路
		oper_excel.WriteDatatoExcel(1,num,5,jinlu);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
		{
			//写迎面列车进路
			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
		}

		//GetEntName(nHandleStartXHJ,AnniuStart);
		oper_excel.WriteDatatoExcel(1,num,3,StartXHJ);
		oper_excel.WriteDatatoExcel(1,num,9,StartXHJ);
		AnniuStart=StartXHJ+_T("A");
		//AnniuEnd=temp+_T("A");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		oper_excel.WriteDatatoExcel(1,num,10,_T("B"));
		num++;
		long t2=GetTickCount();
		CString str;
		str.Format("GetDiaoChePathGuiDaoAndXHJ time:%d ms",t2-t1);
		iJL_Cnt++;
		//acutPrintf(_T("\n %s"),str);
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		//DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					//sVectorPath.push_back(strArrayCXGdName.GetAt(i));
			     	vec_strGuiDaoCX.push_back(strArrayCXGdName.GetAt(i));
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					//this->GetDiaoChePathGuiDaoAndXHJ(StartXHJ,EndXHJ,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,bForword);
					this->GetDiaoChePathGuiDaoAndXHJ(StartXHJ,EndXHJ,nHandleLineFirst,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,vec_strGuiDaoCX,iJL_Cnt,bForword);
					vec_strGuiDaoCX.pop_back();
					//nArrayHandleLine.Copy(nArrayHandleTem);
					//sVectorPath.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
	//vec_strGuiDaoCX.pop_back();
}
/************************函数：GetDiaoChePathGuiDaoAndXHJ********************************************************************************************/
/***********功能：通过调车进路的起始轨道和终止轨道，输出进路走过的轨道和道岔以及信号机，并将联锁信息写入Excel*****************************************/
/***********输入：CString& StartXHJ,起始信号机名称；CString& EndXHJ,终端信号机名称；long nHandleLineStart,起始轨道；********************/
/******************long nHandleLineEnd,终止轨道；long LastDaocha,走到起始轨道上一次走过的道岔；********************************************/
/******************CStringArray &GuDao,股道名称；bool bForword，进路推进方向***************************************************************/
/***********输出：vector<CString>&sVectorPath,存储走过的轨道区段；vector<CString>&sDaocha,存储走过的道岔；**************************/
/******************vector<CString>& sXHJ,存储走过的信号机；CLongArray&nArrayHandleLine,推进过程中的下一个轨道区段********************/ 
/******************************注释：2015-06-06 pm 14:44 by luo*********************************************************************************/
void CZnSxt::GetDiaoChePathGuiDaoAndXHJ( CString& StartXHJ,CString& EndXHJ,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	long t1=GetTickCount();
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//CStringArray strArray_XHJData;
		//TiquEffectiveData(sXHJ,strArray_XHJData);
		CStringArray str_array_xhj;
		TiquEffectiveData(sXHJ,str_array_xhj);
		CString AnniuEnd;
		CString AnniuStart;
		//如果终端信号机不在进路上，则返回
		CString temp=EndXHJ;
		CString jinlu;
// 		vector<CString> tempXHJ;
// 		//CStringArray str_array_xhj
// 		TiquGuoDaocha(sXHJ,tempXHJ);
		//TiquEffectiveData(sXHJ)
		int count=str_array_xhj.GetCount();
		//temp.Remove(_T("至"));
		//temp.Remove(_T("向"));
		//acutPrintf("temp =%s",temp);
		if(CBlkUtility::FindStrInArray(str_array_xhj,temp)==-1&&CBlkUtility::FindStrInArray(GuDao,temp)==-1)
		{
			return;
		}
		else if(CBlkUtility::FindStrInArray(GuDao,temp)!=-1)
		{
			//为股道时
			jinlu=_T("至")+temp;
			if(count>0)
			{
				AnniuEnd=str_array_xhj[count-1]+_T("DA");
			}
		}
		else
		{
			//为信号机
			long nHandleDC=0;
			GetHandleByName(temp,nHandleDC);
			//判断信号机方向
			int iToward=-1;
		   if(this->GetBlockToward(nHandleDC,iToward)==TRUE)
		   {
			   if(iToward==1)
			   {
				   //向右
				   if(bForword==true)
				   {
					   jinlu=_T("至")+temp;
					   if(count>1)
					   {
						   AnniuEnd=str_array_xhj[count-2]+_T("A");
					   }
					   else if(count>0)
					   {
						   AnniuEnd=str_array_xhj[count-1]+_T("A");
					   }
					  // oper_excel.oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
				   }
				   else
				   {
					   CString tempZ;
					   if(count>1)
					   {
						  tempZ=str_array_xhj[count-1];
					   }
					   jinlu=_T("向")+temp;
					   AnniuEnd =temp+_T("A");
				   }
					   
			   }
			   else if(iToward==2)
			   {
				   if(bForword==true)
				   {
					   jinlu=_T("向")+temp;
					   if(count>0)
					   AnniuEnd =str_array_xhj[count-1]+_T("A");
				   }
				   else
				   {
					   jinlu=_T("至")+temp;
					   if(count>1)
					   {
						   AnniuEnd=str_array_xhj[count-2]+_T("A");
					   }
					   else if(count>0)
						   AnniuEnd=str_array_xhj[count-1]+_T("A");
			      }
		   }

		}
	}
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//CLongArray nArrayPassXHJ;
		oper_excel.WriteDatatoExcel(1,num,4,num-3);
		//oper_excel.WriteDatatoExcel(1,)
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		 oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		CStringArray strArray_GXHJ;
		TiquEffectiveData(sXHJ,strArray_GXHJ);
		//去掉走过的信号机中同方向的信号机
		vector<CString > vec_xhj_didui;
		for(int i=0;i<strArray_GXHJ.GetCount();i++)
		{
			int fangxiang=-1;
			long nHandleDCTemp=0;
			GetHandleByName(strArray_GXHJ.GetAt(i),nHandleDCTemp);
			if(GetBlockToward(nHandleDCTemp,fangxiang)==TRUE)
			{
				if(fangxiang==1&&bForword==false)
				{
                   vec_xhj_didui.push_back(strArray_GXHJ.GetAt(i)+_T("，"));
				}
				else if(fangxiang==2&&bForword==true)
				{
                    vec_xhj_didui.push_back(strArray_GXHJ.GetAt(i)+_T("，"));
				}
			}
		}
		long lastdc=0;
		CStringArray nArrayDXDC;
		CLongArray  nArrayHandleNext;
		FindNextDuiXiangDCByLine(nHandleLineEnd,lastdc,GuDao,nArrayHandleNext,nArrayDXDC,bForword);
		for(int i=0;i<nArrayDXDC.GetCount();i++)
		{
			vec_xhj_didui.push_back(nArrayDXDC.GetAt(i)+_T("，"));
			acutPrintf(_T("对向：%s"),nArrayDXDC.GetAt(i));
		}
		//进站信号机敌对
		long nHandleLine_Start=0;
		long nHandleDC_Start=0;
		GetHandleByName(StartXHJ,nHandleDC_Start);
		bool fangxiang=false;
		GetXHJ_ZuoCe_GdLine(nHandleDC_Start,nHandleLine_Start,fangxiang);
		long lastdc3=0;
		CStringArray nArrayLCXHJ2;
		CLongArray nArrayHandleNext3;
		FindNextLieCheXHJByLine(nHandleLine_Start,lastdc3,GuDao,nArrayHandleNext3,nArrayLCXHJ2,!fangxiang);
		if(nArrayLCXHJ2.GetCount()!=0)
		{
			//只有进站信号机敌对信号存在，敌对列车信号才能存在
			long lastdc2=0;
			CStringArray nArrayLCXHJ;
			CLongArray nArrayHandleNext2;
			FindNextLieCheXHJByLine(nHandleLineEnd,lastdc2,GuDao,nArrayHandleNext2,nArrayLCXHJ,bForword);
			if(nArrayLCXHJ.GetCount()!=0&&nArrayLCXHJ2.GetCount()!=0)
			{
				for(int i=0;i<nArrayLCXHJ2.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ2.GetAt(i)+_T("L，"));
					acutPrintf(_T("同向敌对：%s"),nArrayLCXHJ2.GetAt(i));
				}
				for(int i=0;i<nArrayLCXHJ.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ.GetAt(i)+_T("L，"));
					acutPrintf(_T("反向敌对：%s"),nArrayLCXHJ.GetAt(i));
				}
			}
		}
		oper_excel.WriteDatatoExcel(1,num,13,vec_xhj_didui);
		//写进路
		oper_excel.WriteDatatoExcel(1,num,5,jinlu);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
		{
			//写迎面列车进路
			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
		}
		
		//GetEntName(nHandleStartXHJ,AnniuStart);
		//在外边写
		//oper_excel.WriteDatatoExcel(1,num,3,StartXHJ);
		oper_excel.WriteDatatoExcel(1,num,9,StartXHJ);
		AnniuStart=StartXHJ+_T("A");
		//AnniuEnd=temp+_T("A");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		oper_excel.WriteDatatoExcel(1,num,10,_T("B"));
		num++;
		long t2=GetTickCount();
		CString str;
		str.Format("GetDiaoChePathGuiDaoAndXHJ time:%d ms",t2-t1);
		//acutPrintf(_T("\n %s"),str);
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		//DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					//sVectorPath.push_back(strArrayCXGdName.GetAt(i));
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetDiaoChePathGuiDaoAndXHJ(StartXHJ,EndXHJ,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					//sVectorPath.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
/************************函数：GetDiaoChePathGuiDaoAndXHJ********************************************************************************************/
/***********功能：通过调车进路的起始轨道和终止轨道，输出进路走过的轨道和道岔以及信号机，并将联锁信息写入Excel*****************************************/
/***********输入：CString& StartXHJ,起始信号机名称；CString& EndXHJ,终端信号机名称；long nHandleLineStart,起始轨道；********************/
/******************long nHandleLineEnd,终止轨道；long LastDaocha,走到起始轨道上一次走过的道岔；********************************************/
/******************CStringArray &GuDao,股道名称；bool bForword，进路推进方向***************************************************************/
/***********输出：vector<CString>&sVectorPath,存储走过的轨道区段；vector<CString>&sDaocha,存储走过的道岔；**************************/
/******************vector<CString>& sXHJ,存储走过的信号机；CLongArray&nArrayHandleLine,推进过程中的下一个轨道区段********************/ 
/******************************注释：2015-06-06 pm 14:44 by luo*********************************************************************************/
void CZnSxt::GetDiaoChePathGuiDaoAndXHJ( CString& StartXHJ,CString& EndXHJ,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,int &iJL_Cnt,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	//long t1=GetTickCount();
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//CStringArray strArray_XHJData;
		//TiquEffectiveData(sXHJ,strArray_XHJData);
		CStringArray str_array_xhj;
		acutPrintf(_T("\n进路内信号机："));
		for(int i=0;i<sXHJ.size();i++)
		{
			acutPrintf(_T("\t%s"),sXHJ[i]);
		}
		TiquEffectiveData(sXHJ,str_array_xhj);
		acutPrintf(_T("\n提取后信号机："));
		for(int i=0;i<str_array_xhj.GetCount();i++)
		{
			acutPrintf(_T("\t%s"),str_array_xhj.GetAt(i));
		}
		CString AnniuEnd;
		CString AnniuStart;
		//如果终端信号机不在进路上，则返回
		CString temp=EndXHJ;
		CString jinlu;
		int count=str_array_xhj.GetCount();
		if(CBlkUtility::FindStrInArray(str_array_xhj,temp)==-1&&CBlkUtility::FindStrInArray(GuDao,temp)==-1)
		{
			return;
		}
		else if(CBlkUtility::FindStrInArray(GuDao,temp)!=-1)
		{
			//为股道时
			jinlu=_T("至")+temp;
			if(count>0)
			{
				AnniuEnd=str_array_xhj[count-1]+_T("A");
			}
		}
		else
		{
			//为信号机
			long nHandleDC=0;
			if(temp.Left(1)==_T('X')||temp.Left(1)==_T('S'))
			{
				temp.Remove(_T('D'));
			}
			GetHandleByName(temp,nHandleDC);
			//判断信号机方向
			int iToward=-1;
			if(this->GetBlockToward(nHandleDC,iToward)==TRUE)
			{
				if(iToward==1)
				{
					//向右
					if(bForword==true)
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							AnniuEnd=str_array_xhj[count-2]+_T("A");
						}
						else if(count>0)
						{
							AnniuEnd=str_array_xhj[count-1]+_T("A");
						}
						// oper_excel.oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
					}
					else
					{
						CString tempZ;
						if(count>1)
						{
							tempZ=str_array_xhj[count-1];
						}
						jinlu=_T("向")+temp;
						AnniuEnd =temp+_T("A");
					}

				}
				else if(iToward==2)
				{
					if(bForword==true)
					{
						jinlu=_T("向")+temp;
						if(count>0)
							AnniuEnd =str_array_xhj[count-1]+_T("A");
					}
					else
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							AnniuEnd=str_array_xhj[count-2]+_T("A");
						}
						else if(count>0)
							AnniuEnd=str_array_xhj[count-1]+_T("A");
					}
				}

			}
		}
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//CLongArray nArrayPassXHJ;
		oper_excel.WriteDatatoExcel(1,num,4,num-3);
		//oper_excel.WriteDatatoExcel(1,)
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//CStringArray strArray_GXHJ;
		//TiquEffectiveData(sXHJ,strArray_GXHJ);
		//去掉走过的信号机中同方向的信号机
		vector<CString > vec_xhj_didui;
		for(int i=0;i<str_array_xhj.GetCount();i++)
		{
			int fangxiang=-1;
			long nHandleDCTemp=0;
			CString str_xhj=str_array_xhj.GetAt(i);
			if(str_xhj.Left(1)==_T('S')||str_xhj.Left(1)==_T('X'))
			{
				str_xhj.Remove(_T('D'));
			}
			//取信号机的句柄
			GetHandleByName(str_xhj,nHandleDCTemp);
			if(str_array_xhj.GetAt(i)==_T("X3")&&StartXHJ==_T("D16"))
			{
				CString strtemp=str_array_xhj.GetAt(i);
			}
			if(GetBlockToward(nHandleDCTemp,fangxiang)==TRUE)
			{
				if(fangxiang==1&&bForword==false)
				{
					vec_xhj_didui.push_back(str_array_xhj.GetAt(i)+_T("，"));
					acutPrintf(_T("didui:%s"),str_array_xhj.GetAt(i));
				}
				else if(fangxiang==2&&bForword==true)
				{
					vec_xhj_didui.push_back(str_array_xhj.GetAt(i)+_T("，"));
					acutPrintf(_T("didui:%s"),str_array_xhj.GetAt(i));
				}
				else
				{
					//acutPrintf(_T("\n信号机方向不对\n"));
				}
			}
		}
		long lastdc=0;
		CStringArray nArrayDXDC;
		CLongArray  nArrayHandleNext;
		//这个函数对于左方向来说求得的对向调车信号机不全
		if(StartXHJ==_T("D4")&&EndXHJ==_T("D10"))
		{
			StartXHJ=StartXHJ;
		}
		FindNextDuiXiangDCByLine(nHandleLineEnd,lastdc,GuDao,nArrayHandleNext,nArrayDXDC,bForword);
		for(int i=0;i<nArrayDXDC.GetCount();i++)
		{
			vec_xhj_didui.push_back(nArrayDXDC.GetAt(i)+_T("，"));
			acutPrintf(_T("对向：%s"),nArrayDXDC.GetAt(i));
		}
		//进站信号机敌对
		long nHandleLine_Start=0;
		long nHandleDC_Start=0;
		GetHandleByName(StartXHJ,nHandleDC_Start);
		bool fangxiang=false;
		GetXHJ_ZuoCe_GdLine(nHandleDC_Start,nHandleLine_Start,fangxiang);
		long lastdc3=0;
		CStringArray nArrayLCXHJ2;
		CLongArray nArrayHandleNext3;
		FindNextLieCheXHJByLine(nHandleLine_Start,lastdc3,GuDao,nArrayHandleNext3,nArrayLCXHJ2,!fangxiang);
		if(nArrayLCXHJ2.GetCount()!=0)
		{
			//只有进站信号机敌对信号存在，敌对列车信号才能存在
			long lastdc2=0;
			CStringArray nArrayLCXHJ;
			CLongArray nArrayHandleNext2;
			FindNextLieCheXHJByLine(nHandleLineEnd,lastdc2,GuDao,nArrayHandleNext2,nArrayLCXHJ,bForword);
			if(nArrayLCXHJ.GetCount()!=0&&nArrayLCXHJ2.GetCount()!=0)
			{
				for(int i=0;i<nArrayLCXHJ2.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ2.GetAt(i)+_T("L，"));
					acutPrintf(_T("同向敌对：%s"),nArrayLCXHJ2.GetAt(i));
				}
				for(int i=0;i<nArrayLCXHJ.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ.GetAt(i)+_T("L，"));
					acutPrintf(_T("反向敌对：%s"),nArrayLCXHJ.GetAt(i));
				}
			}
		}
		oper_excel.WriteDatatoExcel(1,num,13,vec_xhj_didui);
		//写进路
		oper_excel.WriteDatatoExcel(1,num,5,jinlu);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
		{
			//写迎面列车进路
			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
		}

		//GetEntName(nHandleStartXHJ,AnniuStart);
		//在外边写
		//oper_excel.WriteDatatoExcel(1,num,3,StartXHJ);
		oper_excel.WriteDatatoExcel(1,num,9,StartXHJ);
		AnniuStart=StartXHJ+_T("A");
		//AnniuEnd=temp+_T("A");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		oper_excel.WriteDatatoExcel(1,num,10,_T("B"));
		num++;
		long t2=GetTickCount();
		CString str;
//		str.Format("GetDiaoChePathGuiDaoAndXHJ time:%d ms",t2-t1);
		iJL_Cnt++;
		//acutPrintf(_T("\n %s"),str);
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		//DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					//sVectorPath.push_back(strArrayCXGdName.GetAt(i));
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//int iDc_Cnt=0;
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetDiaoChePathGuiDaoAndXHJ(StartXHJ,EndXHJ,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,iJL_Cnt,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					//sVectorPath.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
/************************函数：GetDiaoChePathGuiDaoAndXHJ********************************************************************************************/
/***********功能：通过调车进路的起始轨道和终止轨道，输出进路走过的轨道和道岔以及信号机，并将联锁信息写入Excel*****************************************/
/***********输入：CString& StartXHJ,起始信号机名称；CString& EndXHJ,终端信号机名称；long nHandleLineStart,起始轨道；********************/
/******************long nHandleLineEnd,终止轨道；long LastDaocha,走到起始轨道上一次走过的道岔；********************************************/
/******************CStringArray &GuDao,股道名称；bool bForword，进路推进方向***************************************************************/
/***********输出：vector<CString>&sVectorPath,存储走过的轨道区段；vector<CString>&sDaocha,存储走过的道岔；**************************/
/******************vector<CString>& sXHJ,存储走过的信号机；CLongArray&nArrayHandleLine,推进过程中的下一个轨道区段********************/ 
/******************************注释：2015-06-06 pm 14:44 by luo*********************************************************************************/
void CZnSxt::GetDiaoChePathGuiDaoAndXHJ2( CString& StartXHJ,CString& EndXHJ,long& nHandleLineFirst,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,CStringArray &strArrayJieJinquduan,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,vector<CString>& vec_strGuiDaoCX, int &iJL_Cnt,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	//long t1=GetTickCount();
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//CStringArray strArray_XHJData;
		//TiquEffectiveData(sXHJ,strArray_XHJData);
		CStringArray str_array_xhj;
		acutPrintf(_T("\n进路内信号机："));
		for(int i=0;i<sXHJ.size();i++)
		{
			acutPrintf(_T("\t%s"),sXHJ[i]);
		}
		TiquEffectiveData(sXHJ,str_array_xhj);
		acutPrintf(_T("\n提取后信号机："));
		for(int i=0;i<str_array_xhj.GetCount();i++)
		{
			acutPrintf(_T("\t%s"),str_array_xhj.GetAt(i));
		}
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		vector<CString>tempGuidao;
		TiquGuoDaocha(sVectorPath,tempGuidao);
		CString AnniuEnd;
		CString AnniuStart;
		//如果终端信号机不在进路上，则返回
		CString temp=EndXHJ;
		CString jinlu;
		int count=str_array_xhj.GetCount();
		if(CBlkUtility::FindStrInArray(str_array_xhj,temp)==-1&&CBlkUtility::FindStrInArray(GuDao,temp)==-1)
		{
	//		jinlu=_T("至")+temp;
// 			if(count>0)
// 			{
// 				AnniuEnd=str_array_xhj[count-1]+_T("A");
// 			}
			return;
		}
		else if(CBlkUtility::FindStrInArray(GuDao,temp)!=-1)
		{
			//为股道时
			jinlu=_T("至")+temp;
			if(count>0)
			{
				AnniuEnd=str_array_xhj[count-1]+_T("A");
			}
		}
		else
		{
			//为信号机
			//对于非股道调车，需要去掉最后的区段
			tempGuidao.pop_back();
			long nHandleDC=0;
			if(temp.Left(1)==_T('X')||temp.Left(1)==_T('S'))
			{
				temp.Remove(_T('D'));
			}
			GetHandleByName(temp,nHandleDC);
			//判断信号机方向
			int iToward=-1;
			if(this->GetBlockToward(nHandleDC,iToward)==TRUE)
			{
				if(iToward==1)
				{
					//向右
					if(bForword==true)
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							//这种条件只有在无岔区段的情况下成立，需要加条件
							CString strGuidao;
							int cnt=tempGuidao.size();
							strGuidao=tempGuidao[cnt-1];
							if(strGuidao.Right(3)==_T("WG,"))
							{
								AnniuEnd=str_array_xhj[count-2]+_T("A");
								//去掉无岔区段
								tempGuidao.pop_back();
							}
							else
							{
								AnniuEnd=str_array_xhj[count-1]+_T("A");
							}
							
						}
						else if(count>0)
						{
							AnniuEnd=str_array_xhj[count-1]+_T("A");
						}
						// oper_excel.oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
					}
					else
					{
						CString tempZ;
						if(count>1)
						{
							tempZ=str_array_xhj[count-1];
						}
						jinlu=_T("向")+temp;
						AnniuEnd =temp+_T("A");
					}

				}
				else if(iToward==2)
				{
					if(bForword==true)
					{
						jinlu=_T("向")+temp;
						if(count>0)
							AnniuEnd =str_array_xhj[count-1]+_T("A");
					}
					else
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							CString strGuidao;
							int cnt=tempGuidao.size();
							strGuidao=tempGuidao[cnt-1];
							if(strGuidao.Right(3)==_T("WG,"))
							{
								AnniuEnd=str_array_xhj[count-2]+_T("A");
								//去掉无岔区段
								tempGuidao.pop_back();
							}
							else
							{
								AnniuEnd=str_array_xhj[count-1]+_T("A");
							}
						}
						else if(count>0)
							AnniuEnd=str_array_xhj[count-1]+_T("A");
					}
				}

			}
			
		}
		//轨道名
// 		CString Gd_name;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
// 		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//CLongArray nArrayPassXHJ;
		oper_excel.WriteDatatoExcel(1,num,4,this->iJLnum);
		//oper_excel.WriteDatatoExcel(1,)
// 		vector<CString>tempGuidao;
// 		//PrintGuoDaocha(sVectorPath);
// 		TiquGuoDaocha(sVectorPath,tempGuidao);
// 		 tempGuidao.pop_back();
		//TiquGuoDaocha(sVectorPath,tempGuidao);
		//当前轨道是否存在超限绝缘
		//增加超限区段,第一条轨道线并未考虑到，在这里加上
		int i_m=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleLineFirst);
		if(i_m!=-1)
		{
			vec_strGuiDaoCX.push_back(this->strArrayGuiDaoCX.GetAt(i_m));
		}
		else
		{
			vec_strGuiDaoCX.push_back(_T(""));
		}
		//CString strTemp;
		for(int i=0;i<vec_strGuiDaoCX.size();i++)
		{
			if(vec_strGuiDaoCX[i]!=_T(""))
			{
				CString strTemp;
				strTemp=_T("，")+vec_strGuiDaoCX[i];
				tempGuidao.push_back(strTemp);
			}
		}
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		acutPrintf(_T("\n 走过的轨道区段："));
		for(int i=0;i<nArrayHandleTem.GetCount();i++)
		{
			CString Gd_name;
			m_mysys.GetXdata(nArrayHandleTem.GetAt(i),_T("GUIDAONAME"),Gd_name);
			acutPrintf(_T("%s\t"),Gd_name);
		}
		nArrayHandleTem.RemoveAt(nArrayHandleTem.GetCount()-1);
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		CString strTiaojian;
		for(int i=tempDaocha.size()-1;i>=0;i--)
		{
			if(tempDaocha[i]!=_T(""))
			{
				this->TiquFirstDaocha(tempDaocha[i],strTiaojian);
				//strTiaojian=tempDaocha[i];
				//strTiaojian.Remove(_T(','));
			}
			
		}
		//CStringArray strArray_GXHJ;
		//TiquEffectiveData(sXHJ,strArray_GXHJ);
		//去掉走过的信号机中同方向的信号机
		vector<CString > vec_xhj_didui;
		for(int i=0;i<str_array_xhj.GetCount();i++)
		{
			int fangxiang=-1;
			long nHandleDCTemp=0;
			CString str_xhj=str_array_xhj.GetAt(i);
			if(str_xhj.Left(1)==_T('S')||str_xhj.Left(1)==_T('X'))
			{
				str_xhj.Remove(_T('D'));
			}
			//取信号机的句柄
			GetHandleByName(str_xhj,nHandleDCTemp);
			if(StartXHJ==_T("D11"))
			{
				CString strtemp=str_array_xhj.GetAt(i);
			}
			if(GetBlockToward(nHandleDCTemp,fangxiang)==TRUE)
			{
				if(fangxiang==1&&bForword==false)
				{
					vec_xhj_didui.push_back(str_array_xhj.GetAt(i)+_T("，"));
					acutPrintf(_T("didui:%s"),str_array_xhj.GetAt(i));
				}
				else if(fangxiang==2&&bForword==true)
				{
					vec_xhj_didui.push_back(str_array_xhj.GetAt(i)+_T("，"));
					acutPrintf(_T("didui:%s"),str_array_xhj.GetAt(i));
				}
				else
				{
					//acutPrintf(_T("\n信号机方向不对\n"));
				}
			}
		}
		long lastdc=0;
		CStringArray nArrayDXDC;
		CLongArray  nArrayHandleNext;
		CStringArray strArrayDXDaocha;
		//这个函数对于左方向来说求得的对向调车信号机不全
		if(StartXHJ==_T("D4")&&EndXHJ==_T("D10"))
		{
			StartXHJ=StartXHJ;
		}
		FindNextDuiXiangDCByLine2(nHandleLineEnd,lastdc,GuDao,nArrayHandleNext,nArrayDXDC,strArrayDXDaocha,bForword);
		CLongArray nArrayHandleDXDC;
		for(int k=0;k<nArrayDXDC.GetCount();k++)
		{
			//vec_xhj_didui.push_back(nArrayDXDC.GetAt(i)+_T("，"));
			int i_add=0;
			acutPrintf(_T("对向：%s"),nArrayDXDC.GetAt(k));
			long nHandleDXDC=0;
			//注意这里需要去掉_T('D')
			CString tempXHJ=nArrayDXDC.GetAt(k);
			if(tempXHJ.Left(1)==_T('X')||tempXHJ.Left(1)==_T('S'))
			{
				tempXHJ.Remove(_T('D'));
			}
			GetHandleByName(tempXHJ,nHandleDXDC);
			//CStringArray strArrayJieJinquduan;
			CLongArray nArrayHandleNextTXLine;
			CStringArray strArrayTXDC;
			//通过一个信号机获取其调车终端信号机
			GetNextDCXHJByDCXHJ(nHandleDXDC,GuDao,strArrayJieJinquduan,nArrayHandleNextTXLine,strArrayTXDC);
			//获取同方向调车信号机终端后
			int iCnt_TXDC=strArrayTXDC.GetCount();
			if(iCnt_TXDC>1)
			{
				//并且存在不过进路内轨道的调车进路，则需要添加敌对条件，并且应该返回“条件”
				long nHandleLineStartTem=0;
				long nHandleLineEndTem=0;
				bool fangxiang=false;
                GetXHJ_YouCe_GdLine(nHandleDXDC,nHandleLineStartTem,fangxiang);
				if(nHandleLineStartTem==0)
				{
					acutPrintf(_T("\n获取信号右侧线失败"));
				}
				for(int i=0;i<strArrayTXDC.GetCount();i++)
				{
					long nHandlexhj=0;
					//需要注意
					acutPrintf(_T("调至：%s"),strArrayTXDC.GetAt(i));
					GetHandleByName(strArrayTXDC.GetAt(i),nHandlexhj);
					if(nHandlexhj==0)
					{
						acutPrintf(_T("\n获取信号机句柄失败"));

					}
					bool fangxiang2=false;
					GetXHJ_ZuoCe_GdLine(nHandlexhj,nHandleLineEndTem,fangxiang2);
					if(nHandleLineEndTem==0)
					{
						acutPrintf(_T("\n获取信号机左侧线失败"));
					}
					long lastdcTemp=0;
					vector<CString> vec_sVectorPathTem;
					vector<CString> vec_sDaochaTem;
					vector<CString> vec_sXHJ_tem;
					CLongArray nArrayHandleLineTem2;
					vector<CString> vec_strTiaojianT;
					int iJL_CntTem=0;
					int iTJ_CntTem=0;
					this->IsAddConditionDiaoChePath(nHandleLineStartTem,nHandleLineEndTem,nArrayHandleTem,lastdcTemp,vec_sVectorPathTem,vec_sDaochaTem,vec_sXHJ_tem,GuDao,nArrayHandleLineTem2,vec_strGuiDaoCX,vec_strTiaojianT,iJL_CntTem,iTJ_CntTem,fangxiang);
					if(iTJ_CntTem>=1)
					{
						acutPrintf(_T("条件:%s"),vec_strTiaojianT[0]);
						CString str_temp;
			            if(strArrayDXDaocha[k]!=_T(""))
						{
							CString strTemp=strArrayDXDaocha[k];
							this->TiquFirstDaocha2(strArrayDXDaocha[k],strTemp);
							str_temp=_T("<")+strTemp+_T(">");
							vec_xhj_didui.push_back(str_temp+nArrayDXDC.GetAt(k)+_T(","));
						}
						else 	if(strTiaojian!=_T(""))
						{
							str_temp=_T("<")+strTiaojian+_T(">");
							vec_xhj_didui.push_back(str_temp+nArrayDXDC.GetAt(k)+_T(","));
						}
						else
						{
							vec_xhj_didui.push_back(vec_strTiaojianT[0]+nArrayDXDC.GetAt(k)+_T(","));
						}
						i_add=1;
      					break;
					}

				}
				if(i_add==0)
				{
					vec_xhj_didui.push_back(nArrayDXDC.GetAt(k)+_T("，"));
				}
				
			}
			else
			{
				vec_xhj_didui.push_back(nArrayDXDC.GetAt(k)+_T("，"));
			}

		}
		//考虑敌对条件
        
		//进站信号机敌对
		long nHandleLine_Start=0;
		long nHandleDC_Start=0;
		CString Startlcxhj=StartXHJ;
		if(Startlcxhj.Right(1)==_T('D'))
		{
			Startlcxhj.Remove(_T('D'));
		}
		GetHandleByName(Startlcxhj,nHandleDC_Start);
		bool fangxiang=false;
		if(bForword==true)
		{
			GetXHJ_YouCe_GdLine(nHandleDC_Start,nHandleLine_Start,fangxiang);
		}
		else
		{
			GetXHJ_ZuoCe_GdLine(nHandleDC_Start,nHandleLine_Start,fangxiang);
		}
		
		long lastdc3=0;
		CStringArray nArrayLCXHJ2;
		CLongArray nArrayHandleNext3;
		FindNextLieCheXHJByLine(nHandleLine_Start,lastdc3,GuDao,nArrayHandleNext3,nArrayLCXHJ2,!fangxiang);
		if(nArrayLCXHJ2.GetCount()!=0)
		{
			//只有进站信号机敌对信号存在，敌对列车信号才能存在
			long lastdc2=0;
			CStringArray nArrayLCXHJ;
			CLongArray nArrayHandleNext2;
			FindNextLieCheXHJByLine(nHandleLineEnd,lastdc2,GuDao,nArrayHandleNext2,nArrayLCXHJ,bForword);
			if(nArrayLCXHJ.GetCount()!=0&&nArrayLCXHJ2.GetCount()!=0)
			{
				for(int i=0;i<nArrayLCXHJ2.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ2.GetAt(i)+_T("，"));
					acutPrintf(_T("同向敌对：%s"),nArrayLCXHJ2.GetAt(i));
				}
				for(int i=0;i<nArrayLCXHJ.GetCount();i++)
				{
					vec_xhj_didui.push_back(nArrayLCXHJ.GetAt(i)+_T("，"));
					acutPrintf(_T("反向敌对：%s"),nArrayLCXHJ.GetAt(i));
				}
			}
		}
		oper_excel.WriteDatatoExcel(1,num,13,vec_xhj_didui);
		//写进路
		oper_excel.WriteDatatoExcel(1,num,5,jinlu);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
		{
			//写迎面列车进路
			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
		}

		//GetEntName(nHandleStartXHJ,AnniuStart);
		//在外边写
		//oper_excel.WriteDatatoExcel(1,num,3,StartXHJ);
		oper_excel.WriteDatatoExcel(1,num,9,StartXHJ);
		AnniuStart=StartXHJ+_T("A");
		//AnniuEnd=temp+_T("A");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		oper_excel.WriteDatatoExcel(1,num,10,_T("B"));
		num++;
		long t2=GetTickCount();
		CString str;
		//		str.Format("GetDiaoChePathGuiDaoAndXHJ time:%d ms",t2-t1);
		iJL_Cnt++;
		this->iJLnum++;
		//acutPrintf(_T("\n %s"),str);
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		//DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		DiaoCheFindNextLineAndXHJ2(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					vec_strGuiDaoCX.push_back(strArrayCXGdName.GetAt(i));
					//sVectorPath.push_back(strArrayCXGdName.GetAt(i));
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//int iDc_Cnt=0;
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetDiaoChePathGuiDaoAndXHJ2(StartXHJ,EndXHJ,nHandleLineFirst,nHandNext,nHandleLineEnd,thisdaocha,strArrayJieJinquduan,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,vec_strGuiDaoCX,iJL_Cnt,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					//sVectorPath.pop_back();
					vec_strGuiDaoCX.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
/************************函数：IsAddConditionDiaoChePath********************************************************************************************/
/***********功能：根据敌对进路的调车始端和调车终端，确定是否需要给敌对调车信号机加条件*****************************************/
/***********输入：CString& StartXHJ,起始信号机名称；CString& EndXHJ,终端信号机名称；long nHandleLineStart,起始轨道；********************/
/******************long nHandleLineEnd,终止轨道；long LastDaocha,走到起始轨道上一次走过的道岔；********************************************/
/******************CStringArray &GuDao,股道名称；bool bForword，进路推进方向***************************************************************/
/***********输出：vector<CString>&sVectorPath,存储走过的轨道区段；vector<CString>&sDaocha,存储走过的道岔；**************************/
/******************vector<CString>& sXHJ,存储走过的信号机；CLongArray&nArrayHandleLine,推进过程中的下一个轨道区段********************/ 
/******************************注释：2015-06-06 pm 14:44 by luo*********************************************************************************/
void CZnSxt::IsAddConditionDiaoChePath(long nHandleLineStart,long nHandleLineEnd,CLongArray &nArrayHandleStop,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,vector<CString>& vec_strGuiDaoCX, vector<CString>& vec_str_tiaojian,int &iJL_Cnt,int &iTJ_Cnt,bool bForword/*=true*/ )
{
	//int b_Ret=FALSE;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		CStringArray str_array_xhj;
		for(int i=0;i<sXHJ.size();i++)
		{
			//acutPrintf(_T("\t%s"),sXHJ[i]);
		}
		TiquEffectiveData(sXHJ,str_array_xhj);
		acutPrintf(_T("\n提取后信号机："));
		for(int i=0;i<str_array_xhj.GetCount();i++)
		{
			//acutPrintf(_T("\t%s"),str_array_xhj.GetAt(i));
		}
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		acutPrintf(_T("\n 调车进路走过的轨道区段："));
		for(int i=0;i<nArrayHandleTem.GetCount();i++)
		{
			CString Gd_name;
			m_mysys.GetXdata(nArrayHandleTem.GetAt(i),_T("GUIDAONAME"),Gd_name);
			acutPrintf(_T("%s\t"),Gd_name);
		}
		vector<CString>tempGuidao;
		TiquGuoDaocha(sVectorPath,tempGuidao);
		int j=0;
		for(j=0;j<nArrayHandleTem.GetCount();j++)
		{
			if(CBlkUtility::FindLongInArray(nArrayHandleStop,nArrayHandleTem.GetAt(j))!=-1)
			{
				//说明经过径路内轨道区段
				break;
			}
		}
		if(j==nArrayHandleTem.GetCount())
		{
			iTJ_Cnt++;
			vec_str_tiaojian.push_back("<>");
			acutPrintf(_T("\n需要加条件"));
		}

		sVectorPath.pop_back();
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		iJL_Cnt++;
		//return b_Ret;
	}
	else if(nHandleLineStart==0)
	{
		return ;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		CStringArray strArrayCXGdName;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		DiaoCheFindNextLineAndXHJ2(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,strArrayCXGdName,bForword);
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					vec_strGuiDaoCX.push_back(strArrayCXGdName.GetAt(i));
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					this->IsAddConditionDiaoChePath(nHandNext,nHandleLineEnd,nArrayHandleStop,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,vec_strGuiDaoCX,vec_str_tiaojian,iJL_Cnt,iTJ_Cnt,bForword);
					vec_strGuiDaoCX.pop_back();
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
			}
		}
	}
	sVectorPath.pop_back();
}
/*******************************函数：GetDiaoChePathGuiDaoAndDiDuiXHJ*************************************************************************************************************************************************/
/***********功能描述：获取调车起始轨道至调车终止轨道间的道岔、轨道区段、以及调车进路上的敌对信号机，即背向的调车信号机*******************************************************************************************/
/***********输入： CString& StartXHJ，起始信号机名称；CString& EndXHJ,，终端信号机名称，long nHandleLineStart,起始信号机所在轨道，long nHandleLineEnd终止信号机所在轨道，bool bForword进路方向*****/
/******************long LastDaocha,上一轨道走过的道岔，CStringArray &GuDao,股道名称************************************************************************************************************************************/
/***********输出：vector<CString>&sVectorPath,用于存储走过的轨道区段；vector<CString>&sDaocha,储存走过的道岔；***********************************************************************************************/
/***************** vector<CString>& sXHJ,储存走过的敌对信号机；CLongArray&nArrayHandleLine，储存当前轨道区段的后继区段***************************************************************************************/
/**********************************注释---2015-06-05-pm 16:23-by-luo****************************************************************************************************************************************************/

void CZnSxt::GetDiaoChePathGuiDaoAndDiDuiXHJ( CString& StartXHJ,CString& EndXHJ,long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, vector<CString>& sXHJ,CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	//static num=4;
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//CStringArray strArray_XHJData;
		//TiquEffectiveData(sXHJ,strArray_XHJData);
		CStringArray str_array_xhj;
		TiquEffectiveData(sXHJ,str_array_xhj);
		CString AnniuEnd;
		CString AnniuStart;
		//如果终端信号机不在进路上，则返回
		CString temp=EndXHJ;
		CString jinlu;
		vector<CString> tempXHJ;
		//CStringArray str_array_xhj
		TiquGuoDaocha(sXHJ,tempXHJ);
		//TiquEffectiveData(sXHJ)
		int count=str_array_xhj.GetCount();
		if(CBlkUtility::FindStrInArray(str_array_xhj,temp)==-1&&CBlkUtility::FindStrInArray(GuDao,temp)==-1)
		{
			return;
		}
		else if(CBlkUtility::FindStrInArray(GuDao,temp)!=-1)
		{
			//为股道时
			jinlu=_T("至")+temp;
			AnniuEnd=str_array_xhj[count-1]+_T("DA");
		}
		else
		{
			//为信号机
			long nHandleDC=0;
			GetHandleByName(temp,nHandleDC);
			//判断信号机方向
			int iToward=-1;
			if(this->GetBlockToward(nHandleDC,iToward)==TRUE)
			{
				if(iToward==1)
				{
					//向右
					if(bForword==true)
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							AnniuEnd=str_array_xhj[count-2]+_T("A");
						}
						else
						{
							AnniuEnd=str_array_xhj[count-1]+_T("A");
						}
						//oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
					}
					else
					{
						jinlu=_T("向")+str_array_xhj[count-1];
						AnniuEnd =str_array_xhj[count-1]+_T("A");
					}

				}
				else if(iToward==2)
				{
					if(bForword==true)
					{
						jinlu=_T("向")+temp;
						AnniuEnd =str_array_xhj[count-1]+_T("A");
					}
					else
					{
						jinlu=_T("至")+temp;
						if(count>1)
						{
							AnniuEnd=str_array_xhj[count-2]+_T("A");
						}
						else
							AnniuEnd=str_array_xhj[count-1]+_T("A");
					}
				}

			}
		}
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//CLongArray nArrayPassXHJ;
		oper_excel.WriteDatatoExcel(1,num,4,(num-3));
		vector<CString>tempGuidao;
		//PrintGuoDaocha(sVectorPath);
		TiquGuoDaocha(sVectorPath,tempGuidao);
		oper_excel.WriteDatatoExcel(1,num,14,tempGuidao);
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		//PrintGuoDaocha(sDaocha);
		vector<CString> tempDaocha;
		TiquGuoDaocha(sDaocha,tempDaocha);
		oper_excel.WriteDatatoExcel(1,num,12,tempDaocha);
		//PrintGuoDaocha(sXHJ);
		//		vector<CString> tempXHJ;
		//	TiquGuoDaocha(sXHJ,tempXHJ);
		oper_excel.WriteDatatoExcel(1,num,13,tempXHJ);
		//写进路
		oper_excel.WriteDatatoExcel(1,num,5,jinlu);
		if(CBlkUtility::FindStrInArray(GuDao,Gd_name)!=-1)
		{
			//写迎面列车进路
			oper_excel.WriteDatatoExcel(1,num,15,Gd_name);
		}

		//GetEntName(nHandleStartXHJ,AnniuStart);
		oper_excel.WriteDatatoExcel(1,num,3,StartXHJ);
		oper_excel.WriteDatatoExcel(1,num,9,StartXHJ);
		AnniuStart=StartXHJ+_T("A");
		//AnniuEnd=temp+_T("A");
		CString JinLuAnniu=AnniuStart+_T("    ")+AnniuEnd;
		oper_excel.WriteDatatoExcel(1,num,7,JinLuAnniu);
		oper_excel.WriteDatatoExcel(1,num,10,_T("B"));
		num++;
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		//存储走过的道岔
		CStringArray Dacha;
		CStringArray PassXHJ;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		DiaoCheFindNextLineAndXHJ(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,PassXHJ,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					sXHJ.push_back(PassXHJ[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					//this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					this->GetDiaoChePathGuiDaoAndXHJ(StartXHJ,EndXHJ,nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,sXHJ,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					sDaocha.pop_back();
					sXHJ.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
//输入起点轨道和终点轨道，寻找进路，找到的进路存入sVectorPath中。sDaocha用于存储进路上经过的道岔。Gudao存储进路搜索时遇到的可以停止搜索的轨道区段。nAarryHandleLine存储进路搜寻中已经访问的轨道句柄
void CZnSxt::GetPathGuiDao3( long nHandleLineStart,long nHandleLineEnd,long LastDaocha,vector<CString>&sVectorPath,vector<CString>&sDaocha, CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	CLongArray nArrayHandleTem;
	nArrayHandleTem.Copy(nArrayHandleLine);
	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
	{
		//轨道名
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		nArrayHandleTem.Add(nHandleLineStart);
		//应将nHandleLineEnd上所有道岔置于定位，待研究
		//压入对应的道岔定反位
		acutPrintf(_T("\n 搜索结束"));
		for(int i=0;i<sVectorPath.size();i++)
		{
			//输出搜索到的结果
			acutPrintf(_T("\t第%d 轨道区段名为%s"),i,sVectorPath[i].GetString());
		}
		sVectorPath.pop_back();
		acutPrintf(_T("\n 经过轨道区段：%d"),nArrayHandleTem.GetCount());
		// 		打印经过道岔定反位
		// 				acutPrintf(_T("\n 经过道岔："));
		// 			 		for(int k=0;k<sDaocha.size();k++)
		// 				 	{
		// 			 			if(sDaocha[k]!=_T(""))
		// 							{
		// 				 				acutPrintf(_T("%s;\t"),sDaocha[k].GetString());
		// 						}
		// 				 	}
		PrintGuoDaocha(sDaocha);
		/*		sDaocha.pop_back();*/
		return;
	}
	else if(nHandleLineStart==0)
	{
		return;
	}
	else
	{
		//将当前轨道加入已访问
		nArrayHandleTem.Add(nHandleLineStart);
		CString Gd_name;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
		sVectorPath.push_back(Gd_name);
		CLongArray nArrayHandleNext;
		CLongArray nArrayHandleThisDC;
		//存储走过的道岔
		CStringArray Dacha;
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
		FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,LastDaocha,nArrayHandleThisDC,nArrayHandleNext,bForword);
		//FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,)
		int count =0;
		count =nArrayHandleNext.GetCount();
		if(count!=0)
		{
			for(int i=0;i<count;i++)
			{
				long nHandNext=0;
				nHandNext =nArrayHandleNext[i];
				//CLongArray nArrayHandleNext2;
				//打印后继
				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
				if(CBlkUtility::FindLongInArray(nArrayHandleTem,nHandNext)==-1)
				{
					CString name;
					m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
					sDaocha.push_back(Dacha[i]);
					long thisdaocha=nArrayHandleThisDC[i];
					this->GetPathGuiDao3(nHandNext,nHandleLineEnd,thisdaocha,sVectorPath,sDaocha,GuDao,nArrayHandleTem,bForword);
					//nArrayHandleLine.Copy(nArrayHandleTem);
					sDaocha.pop_back();
				}
				//	sDaocha.pop_back();
			}
		}
	}
	sVectorPath.pop_back();
}
// void CZnSxt::GetPathGuiDao( long nHandleLineStart,long nHandleLineEnd,vector<CString>&sVectorPath, CStringArray &GuDao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
// {
// 	if(nHandleLineEnd!=0&&nHandleLineEnd==nHandleLineStart)
// 	{
// 		//轨道名
// 		CString Gd_name;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
// 		sVectorPath.push_back(Gd_name);
// 		//压入对应的道岔定反位
// 		acutPrintf(_T("\n 搜索结束"));
// 		for(int i=0;i<sVectorPath.size();i++)
// 		{
// 			//输出搜索到的结果
// 			acutPrintf(_T("\t第%d 股道名为%s"),i,sVectorPath[i].GetString());
// 		}
// 		sVectorPath.pop_back();
// 		return;
// 	}
// 	else if(nHandleLineStart==0)
// 	{
// 		return;
// 	}
// 	else
// 	{
// 		CString Gd_name;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),Gd_name);
// 		sVectorPath.push_back(Gd_name);
// 		CLongArray nArrayHandleNext;
// 		CStringArray Dacha;
// 		FindNextLine3(nHandleLineStart,nHandleLineEnd,Dacha,GuDao,nArrayHandleNext,bForword);
// 		int count =0;
// 		count =nArrayHandleNext.GetCount();
// 		if(count!=0)
// 		{
// 			for(int i=0;i<count;i++)
// 			{
// 				long nHandNext=0;
// 				nHandNext =nArrayHandleNext[i];
// 				CLongArray nArrayHandleNext2;
// 				CString name;
// 				m_mysys.GetXdata(nHandNext,_T("GUIDAONAME"),name);
// 				//打印后继
// 				//	acutPrintf(_T("\nnHandNext=%d \t name=%s"),nHandNext,name.GetString());
// 				this->GetPathGuiDao(nHandNext,nHandleLineEnd,sVectorPath,GuDao,nArrayHandleNext2,bForword);
// 			}
// 		}
// 	}
// 	sVectorPath.pop_back();
// }
// void CZnSxt::FindNextLine( long nHandleLineStart,long nHandleLineEnd,CStringArray &Gudao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
// {
// 	static colorindex=0;
// 	colorindex=colorindex+5;
// 	if(colorindex>255)
// 	{
// 			colorindex=0;
// 	}
//   try
//   {
//   // static int stop =0;
// 	if(nHandleLineStart==nHandleLineEnd)
// 	{//找到，结束
// 		return;
// 	}
// 		CString GuidaoName;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
// 		//acutPrintf(_T("轨道名称"))ⅡG
// 		//CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())
// 		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
// 		{
// 			//如果起始位股道，则结束
// 			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
// 			return;
// 		}
// 		else
// 		{
// 			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
// 		}
// 		
// 	CADORecordset cSet(&m_AdoDb) ;
// 	CString strSql ;
// 	strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 	long nLineType = 0 ;
// 	m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 	//表示为尽头线
// 	if (nLineType==2) 
// 	{
// 		CString name;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
// 		acutPrintf(_T("\n 尽头线：%s"),name.GetString());
// 		return ;
// 	}
// 	//判断轨道上DC个数
// 	CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
// 	//获取轨道信息，这个函数需要仔细看看
// 	this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
// 	int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
// 	int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
// 	//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
// 	CString guiname;
// 	m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
// 	//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
// 	long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
// 	strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
// 	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
// 	strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
// 	m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
// 	//如果是向右寻找，则找右端绝缘节。
// 	int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
// 	long nHandleNextLine = 0 ;
// 	strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 	CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 	//读取结果集
// 	m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 	if(iNumDC<1)
// 	{
// 		//轨道不包含道岔时，后继只有一个
// 		if(nLineType==0)
// 		{//不为交叉渡线时
// 			if(nHandleNextLine!=0)
// 			{
// 				nArrayHandleLine.Add(nHandleNextLine);
// // 				 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; ;
// // 				m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 			}
// 			else
// 			{
// 				acutPrintf(_T("\n nHandNextLine为0"));
// 			}
// 		}
// 		else if(nLineType==1)
// 		{//为交叉渡线时
// 			strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 			CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 			//读取结果集
// 		//	m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 			//渡线绝缘节在右侧时
// 			if(nHandleLeftJyj==0&&nHandleRightJyj!=0)
// 			{
// 				//找渡线绝缘节在左侧的渡线
// 				if(bForword==true)
// 				{
//                     m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"), nHandleNextLine);
// 					if(nHandleNextLine!=0)
// 					{
// 						nArrayHandleLine.Add(nHandleNextLine);
// // 						 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// // 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 					}
// 
// 					else
// 					{
// 						acutPrintf(_T("\n nHandNextLine为0"));
// 					}
// 				}
// 				else
// 				{
// 					//后继为道岔定位所在轨道
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 					//反位线对应的道岔
// 					long nHandleDC=0;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 					//道岔所在轨道即为后继轨道
// 				    m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
// 					if(nHandleNextLine!=0)
// 					{
// 						nArrayHandleLine.Add(nHandleNextLine);
// // 						 m_mysys.FlashEnt(nHandleNextLine,2000,200) ; 
// // 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 					}
// 					else
// 					{
// 					  acutPrintf(_T("\n nHandNextLine为0"));
// 					}
// 				}
// 			}
// 			//渡线绝缘节在做左侧时
// 			else if(nHandleLeftJyj!=0&&nHandleRightJyj==0)
// 			{
// 				if(bForword==false)
// 				{
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"), nHandleNextLine);
// 					if(nHandleNextLine!=0)
// 					{
// 						nArrayHandleLine.Add(nHandleNextLine);
// // 						 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// // 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 					}
// 				}
// 				else
// 				{
// 					////后继为道岔定位所在轨道
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 					//反位线对应的道岔
// 					long nHandleDC=0;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 					//道岔所在轨道即为后继轨道
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
// 					if(nHandleNextLine!=0)
// 					{
// 						nArrayHandleLine.Add(nHandleNextLine);
// // 						 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// // 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 					}
// 					else
// 					{
// 						acutPrintf(_T("\n nHandNextLine为0"));
// 					}
// 				}
// 
// 			}
// 		}
// 		//return;
// 	}
// 	else
// 	{//含有道岔时，可能存在多条后继
// 		//道岔为定位时后继
// 		nArrayHandleLine.Add(nHandleNextLine);
// 		for(int k=0;k<iNumDC;k++)
// 		{//道岔反位时后继
// 			//取道岔handle
// 			long nHandleDC=nArrayHandleDC[k];
// 			//查询反位所在线
// 			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 			long nHandle_fw=0;
// 			long nHandle_dw=0;
// 			int IsStart=-1;
// 			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 			m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 			if(IsStart==0&&bForword==true)
// 			{
// 				//向有推进时起点
// 				if(nHandle_dw!=0)
// 				{
// 					nArrayHandleLine.Add(nHandle_fw);
// // 					 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// // 					m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 				}
// 				strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 				long nLineType = 0 ;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 				acutPrintf(_T("\n nlineType=%d"),nLineType);
// 			}
// 			else if(IsStart>0&&bForword==false)
// 			{
// 				//向左推进时起点
// 				if(nHandle_fw!=0)
// 				{
//                      nArrayHandleLine.Add(nHandle_fw);
// // 					 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// // 					 m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 				}
// 				strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 				long nLineType = 0 ;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 				acutPrintf(_T("\n nlineType=%d"),nLineType);
// 			}
// 			acutPrintf(_T("Isstart=%d"),IsStart);
// 		}
// 	}
// 
//   }
//   catch(_com_error& e)
//   {
// 	  CString sBuff = CBlkUtility::GetErrorDescription(e);
// 	  AfxMessageBox(sBuff);        
//   }
//   catch(...)
//   {	
// 	  AfxMessageBox(_T("未知的错误!in FindNextLine"));
//   }	
// }
//记录访问过的道岔，避免走回路，顺便记录走过道岔的定反位，用于联锁表
// void CZnSxt::FindNextLine2( long nHandleLineStart,long nHandleLineEnd,CStringArray &Gudao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
// {
// 	static colorindex=0;
// 	colorindex=colorindex+5;
// 	if(colorindex>255)
// 	{
// 		colorindex=0;
// 	}
// 	try
// 	{
// 		// static int stop =0;
// 		if(nHandleLineStart==nHandleLineEnd)
// 		{//找到，结束
// 			return;
// 		}
// 		CString GuidaoName;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
// 		//acutPrintf(_T("轨道名称"))ⅡG
// 		//CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())
// 		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
// 		{
// 			//如果起始位股道，则结束
// 			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
// 			return;
// 		}
// 		else
// 		{
// 			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
// 		}
// 
// 		CADORecordset cSet(&m_AdoDb) ;
// 		CString strSql ;
// 		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 		long nLineType = 0 ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 		//表示为尽头线
// 		if (nLineType==2) 
// 		{
// 			CString name;
// 			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
// 			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
// 			return ;
// 		}
// 		//判断轨道上DC个数
// 		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
// 		//获取轨道信息，这个函数需要仔细看看
// 		this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
// 		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
// 		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
// 		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
// 		CString guiname;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
// 		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
// 		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
// 		//如果是向右寻找，则找右端绝缘节。
// 		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
// 		long nHandleNextLine = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 		//读取结果集
// 		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 		if(iNumDC<1)
// 		{
// 			//轨道不包含道岔时，后继只有一个
// 			if(nLineType==0)
// 			{//不为交叉渡线时
// 				if(nHandleNextLine!=0)
// 				{
// 					nArrayHandleLine.Add(nHandleNextLine);
// 					// 				 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; ;
// 					// 				m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 				}
// 				else
// 				{
// 					//还有可能当前线为某一个道岔的反位线，此时的线为渡线
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 					//反位线对应的道岔
// 					long nHandleDC=0;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 					if(nHandleDC!=0)
// 					{
// 						//查询道岔所在的线，该线为后继
// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 						//反位线对应的道岔
// 						long nHandle_dw=0;
//                        // long nHandle_fw=0;						
// 						int IsStart=-1;
// 						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 					    m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 						if(bForword==true&&IsStart>0)
// 						{
//                              //定位所在线为后继    
// 							nArrayHandleLine.Add(nHandle_dw);
// 						}
// 						else if(bForword==false&&IsStart==0)
// 						{
// 							nArrayHandleLine.Add(nHandle_dw);
// 						}
// 					}
// 					else
// 					{
//                        acutPrintf(_T("\n nHandNextLine为0"));
// 					}
// 				}
// 			}
// 			else if(nLineType==1)
// 			{//为交叉渡线时
// 				strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 				CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 				//读取结果集
// 				//	m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 				//渡线绝缘节在右侧时
// 				if(nHandleLeftJyj==0&&nHandleRightJyj!=0)
// 				{
// 					//找渡线绝缘节在左侧的渡线
// 					if(bForword==true)
// 					{
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"), nHandleNextLine);
// 						if(nHandleNextLine!=0)
// 						{
// 							nArrayHandleLine.Add(nHandleNextLine);
// 							// 						 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// 							// 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 						}
// 						else
// 						{
// 							acutPrintf(_T("\n nHandNextLine为0"));
// 						}
// 					}
// 					else
// 					{
// 						//后继为道岔定位所在轨道
// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 						//反位线对应的道岔
// 						long nHandleDC=0;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 						//道岔所在轨道即为后继轨道
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
// 						if(nHandleNextLine!=0)
// 						{
// 							nArrayHandleLine.Add(nHandleNextLine);
// 							// 						 m_mysys.FlashEnt(nHandleNextLine,2000,200) ; 
// 							// 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 						}
// 						else
// 						{
// 							acutPrintf(_T("\n nHandNextLine为0"));
// 						}
// 					}
// 				}
// 				//渡线绝缘节在做左侧时
// 				else if(nHandleLeftJyj!=0&&nHandleRightJyj==0)
// 				{
// 					if(bForword==false)
// 					{
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"), nHandleNextLine);
// 						if(nHandleNextLine!=0)
// 						{
// 							nArrayHandleLine.Add(nHandleNextLine);
// 							// 						 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// 							// 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 						}
// 					}
// 					else
// 					{
// 						////后继为道岔定位所在轨道
// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 						//反位线对应的道岔
// 						long nHandleDC=0;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 						//道岔所在轨道即为后继轨道
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
// 						if(nHandleNextLine!=0)
// 						{
// 							nArrayHandleLine.Add(nHandleNextLine);
// 							// 						 m_mysys.FlashEnt(nHandleNextLine,2000, 200) ; 
// 							// 						m_mysys.SetEntColorIndex(nHandleNextLine,colorindex);
// 						}
// 						else
// 						{
// 							acutPrintf(_T("\n nHandNextLine为0"));
// 						}
// 					}
// 				}
// 			}
// 			//return;
// 		}
// 		else
// 		{//含有道岔时，可能存在多条后继
// 			//道岔为定位时后继
// 			nArrayHandleLine.Add(nHandleNextLine);
// 			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
// 			for(int k=0;k<iNumDC;k++)
// 			{//道岔反位时后继,需要前面访问的道岔
// 				//取道岔handle
// 				long nHandleDC=nArrayHandleDC[k];
// 				//查询反位所在线
// 				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 				long nHandle_fw=0;
// 				long nHandle_dw=0;
// 				int IsStart=-1;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 				if(IsStart==0&&bForword==true)
// 				{
// 					//向有推进时起点
// 					if(nHandle_fw!=0)
// 					{
// 						nArrayHandleLine.Add(nHandle_fw);
// 					}
// 					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 					long nLineType = 0 ;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 				//	acutPrintf(_T("\n nlineType=%d"),nLineType);
// 				}
// 				else if(IsStart>0&&bForword==false)
// 				{
// 					//向左推进时起点
// 					if(nHandle_fw!=0)
// 					{
// 						nArrayHandleLine.Add(nHandle_fw);
// 					}
// 					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 					long nLineType = 0 ;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 					//acutPrintf(_T("\n nlineType=%d"),nLineType);
// 				}
// 			//	acutPrintf(_T("Isstart=%d"),IsStart);
// 			}
// 		}
// 
// 	}
// 	catch(_com_error& e)
// 	{
// 		CString sBuff = CBlkUtility::GetErrorDescription(e);
// 		AfxMessageBox(sBuff);        
// 	}
// 	catch(...)
// 	{	
// 		AfxMessageBox(_T("未知的错误!in FindNextLine"));
// 	}	
// }
//记录访问过的道岔，避免走回路，顺便记录走过道岔的定反位，用于联锁表，新加入返回进路上的敌对信号机
//关于敌对信号机：无岔区段上的信号机都为敌对信号机，有岔区段上的信号机，只有在进路上，信号机才算敌对
// void CZnSxt::FindNextLine3( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,CLongArray&nArrayHandleLine,CLongArray &nArrayHandleDDXHJ,bool bForword/*=true*/ )
// {
// 	try
// 	{
// 		// static int stop =0;
// 		if(nHandleLineStart==nHandleLineEnd)
// 		{//找到，结束
// 			return;
// 		}
// 		CString GuidaoName;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
// 		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
// 		{
// 			//如果起始位股道，则结束
// 			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
// 			return;
// 		}
// 		else
// 		{
// 			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
// 		}
// 		CADORecordset cSet(&m_AdoDb) ;
// 		CString strSql ;
// 		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 		long nLineType = 0 ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 		//表示为尽头线
// 		if (nLineType==2) 
// 		{
// 			CString name;
// 			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
// 			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
// 			return ;
// 		}
// 		//判断轨道上DC个数
// 		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
// 		//获取轨道信息，这个函数需要仔细看看
// 		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
// 		if(bForword==true)
// 		{
// 			this->GetGuiDaoInfoOrderByXAsc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
// 		}
// 		else
// 		{
// 			this->GetGuiDaoInfoOrderByXDesc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
// 		}
// 		//for test print DC
// 		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
// 		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
// 		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
// 		CString guiname;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
// 		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
// 		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
// 		//如果是向右寻找，则找右端绝缘节。
// 		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
// 		long nHandleNextLine = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 		//读取结果集
// 		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 		if(iNumDC<1)
// 		{
// 			//轨道不包含道岔时，后继只有一个
// 			if(nLineType==0)
// 			{//不为渡线时
// 				if(nHandleNextLine!=0)
// 				{
// 					nArrayHandleLine.Add(nHandleNextLine);
// 					CString Daocha=_T("");
// 					GuoDaoCha.Add(Daocha);
// 					nArrayHandleDDXHJ.Copy(nArrayHandleXHJ);
// 				}
// 				else
// 				{
// 					//还有可能当前线为某一个道岔的反位线
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 					//反位线对应的道岔
// 					long nHandleDC=0;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 					if(nHandleDC!=0)
// 					{
// 						//查询道岔所在的线，该线为后继
// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 						//反位线对应的道岔
// 						long nHandle_dw=0;
// 						// long nHandle_fw=0;						
// 						int IsStart=-1;
// 						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 						CString DCname;
// 						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
// 						if(bForword==true&&IsStart>0)
// 						{
// 							//定位所在线为后继
// 							nArrayHandleLine.Add(nHandle_dw);
// 							CString Daocha=_T("（")+DCname+_T(")");
// 							// 						   //道岔反位时，需要考虑是否存在带动道岔
// 							GuoDaoCha.Add(Daocha);
// 							nArrayHandleDDXHJ.Copy(nArrayHandleXHJ);
// 						}
// 						else if(bForword==false&&IsStart==0)
// 						{
// 							nArrayHandleLine.Add(nHandle_dw);
// 							CString Daocha=_T("（")+DCname+_T(")");
// 							//道岔反位时，需要考虑是否存在带动道岔
// 							GuoDaoCha.Add(Daocha);
// 							nArrayHandleDDXHJ.Copy(nArrayHandleXHJ);
// 						}
// 					}
// 					else
// 					{
// 						acutPrintf(_T("\n nHandNextLine为0"));
// 					}
// 				}
// 			}
// 			else
// 			{
// 			}
// 			//return;
// 		}//endif NumDC
// 		else
// 		{//含有道岔时，可能存在多条后继
// 			//道岔为定位时后继
// 			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
// 			CString DaochaD;
// 			for(int k=0;k<iNumDC;k++)
// 			{//道岔反位时后继,需要前面访问的道岔
// 				//取道岔handle
// 				long nHandleDC=nArrayHandleDC[k];
// 				//查询反位所在线
// 				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 				long nHandle_fw=0;
// 				long nHandle_dw=0;
// 				int IsStart=-1;
// 				CString DCname1;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
// 				long nHanderDC_another=0;
// 				//向右推进有后继时
// 				if(IsStart==0&&bForword==true)
// 				{
// 					//向右推进时起点
// 					if(nHandle_fw!=0)
// 					{
// 						//继续往下求一次后继，判断是否为渡线
// 						//nArrayHandleLine.Add(nHandle_fw);
// 						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
// 						long nLineType = 0 ;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 						if(nLineType==1)
// 						{
// 							//为渡线时，求反位线的后继
// 							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
// 							//如果是向右寻找，则找右端绝缘节。
// 							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
// 							long nHandleNextLine2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//读取结果集
// 							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
// 							//再找该反位线所在道岔的定位线
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
// 							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//反位线对应的道岔
// 							long nHandleDC2=0;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
// 							if(nHandleDC2!=0)
// 							{
// 								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
// 								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
// 								//查询道岔所在的线，该线为后继
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
// 								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 								//反位线对应的道岔
// 								long nHandle_dw2=0;				
// 								//int IsStart=-1;
// 								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
// 								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 								//nHandle_dw2即为渡线的后继
// 								if(nHandle_dw2!=0)
// 									nArrayHandleLine.Add(nHandle_dw2);
// 								//打印渡线道岔
// 								CString DCname_nMin;
// 								CString DCname_nMax;
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
// 								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
// 								long nHandle_Anothe_Min=0;
// 								long nHandle_Anothe_Max=0;
// 								//判断渡线道岔是否属于交叉渡线的道岔
// 								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 								{
// 									CString DC_Another_Min;
// 									CString DC_Another_Max;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
// 									GuoDaoCha.Add(Daocha);
// 								}
// 								else
// 								{
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									//道岔反位时，需要考虑是否存在带动道岔
// 									GuoDaoCha.Add(Daocha);
// 								}						
// 							}
// 						}
// 						else
// 						{//反位线不为渡线时
// 							nArrayHandleLine.Add(nHandle_fw);
// 							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
// 							//道岔反位时，需要考虑是否存在带动道岔
// 							GuoDaoCha.Add(Daocha);
// 						}
// 					}
// 				}
// 				else if(IsStart>0&&bForword==false)
// 				{
// 					//向左推进时起点
// 					if(nHandle_fw!=0)
// 					{
// 						//nArrayHandleLine.Add(nHandle_fw);
// 						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
// 						long nLineType = 0 ;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 						if(nLineType==1)
// 						{
// 							//为渡线时，求反位线的后继
// 							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
// 							//如果是向右寻找，则找右端绝缘节。
// 							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
// 							long nHandleNextLine2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//读取结果集
// 							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
// 							//再找该反位线所在道岔的定位线
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
// 							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//反位线对应的道岔
// 							long nHandleDC2=0;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
// 							if(nHandleDC2!=0)
// 							{
// 								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
// 								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
// 								//查询道岔所在的线，该线为后继
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
// 								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 								//反位线对应的道岔
// 								long nHandle_dw2=0;				
// 								//int IsStart=-1;
// 								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
// 								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 								//nHandle_dw2即为渡线的后继
// 								if(nHandle_dw2!=0)
// 									nArrayHandleLine.Add(nHandle_dw2);
// 								//打印渡线道岔
// 								CString DCname_nMin;
// 								CString DCname_nMax;
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
// 								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
// 								long nHandle_Anothe_Min=0;
// 								long nHandle_Anothe_Max=0;
// 								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 								{
// 									CString DC_Another_Min;
// 									CString DC_Another_Max;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
// 									GuoDaoCha.Add(Daocha);
// 								}
// 								else
// 								{
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									//道岔反位时，需要考虑是否存在带动道岔
// 									GuoDaoCha.Add(Daocha);
// 								}
// 							}
// 						}
// 						else
// 						{
// 							nArrayHandleLine.Add(nHandle_fw);
// 							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
// 							GuoDaoCha.Add(Daocha);
// 						}
// 					}
// 					//	acutPrintf(_T("Isstart=%d"),IsStart);
// 				}
// 				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
// 				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
// 				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
// 				if(b_dx==false)
// 				{
// 					if(k==iNumDC-1)
// 					{
// 						DaochaD=DaochaD+DCname1;
// 					}
// 					else
// 					{
// 						DaochaD=DaochaD+DCname1+_T("，");
// 					}
// 				}
// 				else
// 				{
// 					CString DCname_Min;
// 					CString DCname_Max;
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
// 					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
// 					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
// 					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
// 					long nHandle_Anothe_Min=0;
// 					long nHandle_Anothe_Max=0;
// 					if(k==iNumDC-1)
// 					{
// 						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 						{
// 							CString DC_Another_Min;
// 							CString DC_Another_Max;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
// 						}
// 						else
// 						{
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
// 						}
// 					}
// 					else
// 					{
// 						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 						{
// 							CString DC_Another_Min;
// 							CString DC_Another_Max;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
// 						}
// 						else
// 						{
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
// 						}
// 
// 					}
// 				}
// 			}
// 			nArrayHandleLine.Add(nHandleNextLine);
// 			GuoDaoCha.Add(DaochaD);
// 		}
// 	}
// 	catch(_com_error& e)
// 	{
// 		CString sBuff = CBlkUtility::GetErrorDescription(e);
// 		AfxMessageBox(sBuff);        
// 	}
// 	catch(...)
// 	{	
// 		AfxMessageBox(_T("未知的错误!in FindNextLine"));
// 	}	
// }
//记录访问过的道岔，避免走回路，顺便记录走过道岔的定反位，用于联锁表
void CZnSxt::FindNextLine3( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	try
	{
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		{
			//如果起始位股道，则结束
			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
			return;
		}
		else
		{
			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
		if(bForword==true)
		{
			this->GetGuiDaoInfoOrderByXAsc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		else
		{
			this->GetGuiDaoInfoOrderByXDesc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString  Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			// 			else if(nLineType==1)
			// 			{
			// 				//为渡线时
			// 				acutPrintf(_T("\n该线为渡线"));
			// 				strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
			// 				CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			// 				//读取结果集
			// 				//	m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
			// 				//渡线绝缘节在右侧时
			// 				if(nHandleLeftJyj==0&&nHandleRightJyj!=0)
			// 				{
			// 					//找渡线绝缘节在左侧的渡线
			// 					if(bForword==true)
			// 					{
			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"), nHandleNextLine);
			// 						if(nHandleNextLine!=0)
			// 						{
			// 							nArrayHandleLine.Add(nHandleNextLine);
			// 						}
			// 
			// 						else
			// 						{
			// 							acutPrintf(_T("\n nHandNextLine为0"));
			// 						}
			// 					}
			// 					else 
			// 					{
			// 						//后继为道岔定位所在轨道
			// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
			// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			// 						//反位线对应的道岔
			// 						long nHandleDC=0;
			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
			// 						//道岔所在轨道即为后继轨道
			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
			// 						if(nHandleNextLine!=0)
			// 						{
			// 							nArrayHandleLine.Add(nHandleNextLine);
			// 						}
			// 						else
			// 						{
			// 							acutPrintf(_T("\n nHandNextLine为0"));
			// 						}
			// 					}
			// 				}
			// 				//渡线绝缘节在做左侧时
			// 				else if(nHandleLeftJyj!=0&&nHandleRightJyj==0)
			// 				{
			// 					if(bForword==false)
			// 					{
			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"), nHandleNextLine);
			// 						if(nHandleNextLine!=0)
			// 						{
			// 							nArrayHandleLine.Add(nHandleNextLine);
			// 						}
			// 					}
			// 					else
			// 					{
			// 						////后继为道岔定位所在轨道
			// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
			// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			// 						//反位线对应的道岔
			// 						long nHandleDC=0;
			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
			// 						//道岔所在轨道即为后继轨道
			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
			// 						if(nHandleNextLine!=0)
			// 						{
			// 							nArrayHandleLine.Add(nHandleNextLine);
			// 						}
			// 						else
			// 						{
			// 							acutPrintf(_T("\n nHandNextLine为0"));
			// 						}
			// 					}
			// 
			// 				}
			// 			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			for(int k=0;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
									nArrayHandleLine.Add(nHandle_dw2);
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{//反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
									nArrayHandleLine.Add(nHandle_dw2);
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							nArrayHandleLine.Add(nHandle_fw);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}
			nArrayHandleLine.Add(nHandleNextLine);
			GuoDaoCha.Add(DaochaD);
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
//该函数中添加记录上次访问过的道岔，主要用于在寻找后继的时候，只将属于进路的道岔写入GuoDaoCha,LastDaocha用于记录上次到nHandleLineStart的道岔，nArrayHandleThisDaocha,用于记录这次最后访问的道岔号
void CZnSxt::FindNextLine3( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,long LastDaocha,CLongArray& nArrayHandleThisDaocha,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	try
	{
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		{
			//如果起始位股道，则结束
			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
			return;
		}
		else
		{
			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
		if(bForword==true)
		{
			this->GetGuiDaoInfoOrderByXAsc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		else
		{
			this->GetGuiDaoInfoOrderByXDesc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nHandleLineStart==nHandleLineEnd)
			{//找到，结束
				return;
			}
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					long nHandleThisDC=0;
					nArrayHandleThisDaocha.Add(nHandleThisDC);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString  Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			//查找上次访问的道岔位置
			int index_lastDaocha=-1;
			if(LastDaocha!=0)
			{
				index_lastDaocha=CBlkUtility::FindLongInArray(nArrayHandleDC,LastDaocha);
			}
			for(int k=index_lastDaocha+1;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线1"));
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{//反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线2"));
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							nArrayHandleLine.Add(nHandle_fw);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
							//acutPrintf(_T("\n遇到交叉渡线3"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
							//acutPrintf(_T("\n遇到交叉渡线"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}
			//所有道岔为定位时
			long nHandleThisDC=0;
			nArrayHandleThisDaocha.Add(nHandleThisDC);
			nArrayHandleLine.Add(nHandleNextLine);
			GuoDaoCha.Add(DaochaD);
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
//该函数中添加记录上次访问过的道岔，主要用于在寻找后继的时候，只将属于进路的道岔写入GuoDaoCha,LastDaocha用于记录上次到nHandleLineStart的道岔，nArrayHandleThisDaocha,用于记录这次最后访问的道岔号
//在原基础上加入轨道区段上的信号机，包括同方向信号机和背向信号机，信号机可能为调车信号机，也可能为列车信号机
void CZnSxt::FindNextLine3( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,long LastDaocha,CLongArray& nArrayHandleThisDaocha,CLongArray& nArrayZhiXHJ,CLongArray& nArrayXiangXHJ,CLongArray& nArrayHandleLine,bool bForword/*=true*/ )
{
	try
	{
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		{
			//如果起始位股道，则结束
			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
			return;
		}
		else
		{
			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
		if(bForword==true)
		{
			this->GetGuiDaoInfoOrderByXAsc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		else
		{
			this->GetGuiDaoInfoOrderByXDesc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nHandleLineStart==nHandleLineEnd)
			{//找到，结束
				return;
			}
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					long Zhi_XHJ=0;
					long Xiang_XHJ=0;
					this->GetGuiDaoDuanXHJ(bForword,nHandleNextLine,Zhi_XHJ,Xiang_XHJ);
					nArrayZhiXHJ.Add(Zhi_XHJ);
					nArrayXiangXHJ.Add(Xiang_XHJ);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					long nHandleThisDC=0;
					nArrayHandleThisDaocha.Add(nHandleThisDC);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString  Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pt_DC_x=0;
							double pt_zxhj_x=0;
							double pt_xxhj_x=0;
							long Zhi_XHJ=0;
							long Xiang_XHJ=0;
							this->GetGuiDaoDuanXHJ(bForword,nHandle_dw,Zhi_XHJ,Xiang_XHJ);
						
								if((GetBlockPosition_X(Zhi_XHJ,pt_zxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleDC,pt_DC_x)==TRUE))
								{
									if(pt_zxhj_x>pt_DC_x)
										nArrayZhiXHJ.Add(Zhi_XHJ);
								}
								else
								{
									nArrayZhiXHJ.Add(0);
								}
								if((GetBlockPosition_X(Zhi_XHJ,pt_xxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleDC,pt_DC_x)==TRUE))
								{
									if(pt_xxhj_x>pt_DC_x)
										nArrayXiangXHJ.Add(Xiang_XHJ);
								}
								else
								{
									nArrayXiangXHJ.Add(0);
								}
							nArrayZhiXHJ.Add(Zhi_XHJ);
							nArrayXiangXHJ.Add(Xiang_XHJ);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							GuoDaoCha.Add(Daocha);
							double pt_DC_x=0;
							double pt_zxhj_x=0;
							double pt_xxhj_x=0;
							long Zhi_XHJ=0;
							long Xiang_XHJ=0;
							if((GetBlockPosition_X(Zhi_XHJ,pt_zxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleDC,pt_DC_x)==TRUE))
							{
								if(pt_zxhj_x<pt_DC_x)
									nArrayZhiXHJ.Add(Zhi_XHJ);
							}
							else
							{
								nArrayZhiXHJ.Add(0);
							}
							if((GetBlockPosition_X(Zhi_XHJ,pt_xxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleDC,pt_DC_x)==TRUE))
							{
								if(pt_xxhj_x<pt_DC_x)
									nArrayXiangXHJ.Add(Xiang_XHJ);
							}
							else
							{
								nArrayXiangXHJ.Add(0);
							}
							nArrayZhiXHJ.Add(Zhi_XHJ);
							nArrayXiangXHJ.Add(Xiang_XHJ);
						}
					}
					else
					{
						acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			//查找上次访问的道岔位置
			int index_lastDaocha=-1;
			if(LastDaocha!=0)
			{
				index_lastDaocha=CBlkUtility::FindLongInArray(nArrayHandleDC,LastDaocha);
			}
			for(int k=index_lastDaocha+1;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									//long Zhi_XHJ=0;
									//long Xiang_XHJ=0;
									//this->GetGuiDaoDuanXHJ(bForword,nHandle_dw2,Zhi_XHJ,Xiang_XHJ);
									//nArrayZhiXHJ.Add(Zhi_XHJ);
									//nArrayXiangXHJ.Add(Xiang_XHJ);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pt_DC_x=0;
									double pt_zxhj_x=0;
									double pt_xxhj_x=0;
									long Zhi_XHJ=0;
									long Xiang_XHJ=0;
									this->GetGuiDaoDuanXHJ(bForword,nHandle_dw2,Zhi_XHJ,Xiang_XHJ);
									if((GetBlockPosition_X(Zhi_XHJ,pt_zxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
									{
										if(pt_zxhj_x>pt_DC_x)
											nArrayZhiXHJ.Add(Zhi_XHJ);
									}
									else
									{
										nArrayZhiXHJ.Add(0);
									}
									if((GetBlockPosition_X(Zhi_XHJ,pt_xxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
									{
										if(pt_xxhj_x>pt_DC_x)
											nArrayXiangXHJ.Add(Xiang_XHJ);
									}
									else
									{
										nArrayXiangXHJ.Add(0);
									}
									nArrayZhiXHJ.Add(Zhi_XHJ);
									nArrayXiangXHJ.Add(Xiang_XHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线1"));
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{//反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							long Zhi_XHJ=0;
							long Xiang_XHJ=0;
							this->GetGuiDaoDuanXHJ(bForword,nHandle_fw,Zhi_XHJ,Xiang_XHJ);
							nArrayZhiXHJ.Add(Zhi_XHJ);
							nArrayXiangXHJ.Add(Xiang_XHJ);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									//long Zhi_XHJ=0;
									//long Xiang_XHJ=0;
									//this,GetGuiDaoDuanXHJ(bForword,nHandleNextLine,Zhi_XHJ,Xiang_XHJ);
									//nArrayZhiXHJ.Add(Zhi_XHJ);
									//nArrayXiangXHJ.Add(Xiang_XHJ);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pt_DC_x=0;
									double pt_zxhj_x=0;
									double pt_xxhj_x=0;
									long Zhi_XHJ=0;
									long Xiang_XHJ=0;
									this->GetGuiDaoDuanXHJ(bForword,nHandle_dw2,Zhi_XHJ,Xiang_XHJ);
									if((GetBlockPosition_X(Zhi_XHJ,pt_zxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
									{
										if(pt_zxhj_x>pt_DC_x)
											nArrayZhiXHJ.Add(Zhi_XHJ);
									}
									else
									{
										nArrayZhiXHJ.Add(0);
									}
									if((GetBlockPosition_X(Zhi_XHJ,pt_xxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
									{
										if(pt_xxhj_x>pt_DC_x)
											nArrayXiangXHJ.Add(Xiang_XHJ);
									}
									else
									{
										nArrayXiangXHJ.Add(0);
									}
									nArrayZhiXHJ.Add(Zhi_XHJ);
									nArrayXiangXHJ.Add(Xiang_XHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线2"));
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							nArrayHandleLine.Add(nHandle_fw);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pt_DC_x=0;
							double pt_zxhj_x=0;
							double pt_xxhj_x=0;
							long Zhi_XHJ=0;
							long Xiang_XHJ=0;
							this->GetGuiDaoDuanXHJ(bForword,nHandle_fw,Zhi_XHJ,Xiang_XHJ);
							if(bForword==true)
							{
								if((GetBlockPosition_X(Zhi_XHJ,pt_zxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
								{
									if(pt_zxhj_x>pt_DC_x)
										nArrayZhiXHJ.Add(Zhi_XHJ);
								}
								else
								{
									nArrayZhiXHJ.Add(0);
								}
								if((GetBlockPosition_X(Zhi_XHJ,pt_xxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
								{
									if(pt_xxhj_x>pt_DC_x)
										nArrayXiangXHJ.Add(Xiang_XHJ);
								}
								else
								{
									nArrayXiangXHJ.Add(0);
								}

							}
							else
							{
								if((GetBlockPosition_X(Zhi_XHJ,pt_zxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
								{
									if(pt_zxhj_x<pt_DC_x)
										nArrayZhiXHJ.Add(Zhi_XHJ);
								}
								else
								{
									nArrayZhiXHJ.Add(0);
								}
								if((GetBlockPosition_X(Zhi_XHJ,pt_xxhj_x)==TRUE)&&(GetBlockPosition_X(nHandleThisDC,pt_DC_x)==TRUE))
								{
									if(pt_xxhj_x<pt_DC_x)
										nArrayXiangXHJ.Add(Xiang_XHJ);
								}
								else
								{
									nArrayXiangXHJ.Add(0);
								}

							}
							nArrayZhiXHJ.Add(Zhi_XHJ);
							nArrayXiangXHJ.Add(Xiang_XHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
							//acutPrintf(_T("\n遇到交叉渡线3"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
							//acutPrintf(_T("\n遇到交叉渡线"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}
			//所有道岔为定位时
			long nHandleThisDC=0;
			nArrayHandleThisDaocha.Add(nHandleThisDC);
			nArrayHandleLine.Add(nHandleNextLine);
			long Zhi_XHJ=0;
			long Xiang_XHJ=0;
			this->GetGuiDaoDuanXHJ(bForword,nHandleNextLine,Zhi_XHJ,Xiang_XHJ);
			nArrayZhiXHJ.Add(Zhi_XHJ);
			nArrayXiangXHJ.Add(Xiang_XHJ);
			GuoDaoCha.Add(DaochaD);
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
//该函数中添加记录上次访问过的道岔，主要用于在寻找后继的时候，只将属于进路的道岔写入GuoDaoCha,LastDaocha用于记录上次到nHandleLineStart的道岔，nArrayHandleThisDaocha,用于记录这次最后访问的道岔号
//在原基础上加入轨道区段上的信号机，包括同方向信号机和背向信号机，信号机可能为调车信号机，也可能为列车信号机
/*******************函数说明:FindNextLineAndXHJ*******************************************************************************************************************************************************************/
/**********功能：通过一条进路的起始轨道和终止轨道，找出起始轨道的后继轨道，并返回从起始轨道到下一条轨道中走过的道岔以及属于进路上的信号机，后继轨道可能有多条*******************************************************************/
/**********输入：nHandleLineStart,进路的起始轨道线；nHandLineEnd,设定进路的终止轨道线，用于终止进路寻找过程*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔；bForward,用于标记寻找后继防线，true为向右推进***************************************************************************/
/*****************Gudao，股道名称，可以用于终止继续寻找；JieJinQuDuan，接近区段名称;******************************************************************************************************/
/**********输出：GuoDaocha,用于记录在寻找进路的过程中走过的道岔,属于联锁表中的一项内容； nArrayHandleThisDaocha，到下一条进路时走过相应道岔*************************************/
/*****************nArrayHandleNextLine,返回所有的后继轨道区段;  GuoXHJ,到一条进路时走过的信号机，信号机属于进路内部*******************************************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
void CZnSxt::DiaoCheFindNextLineAndXHJ( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,long LastDaocha,CLongArray& nArrayHandleThisDaocha,CStringArray& GuoXHJ,CLongArray& nArrayHandleLine,bool bForword/*=true*/ )
{
	try
	{
		long t1=GetTickCount();
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			CLongArray nArrayPassXHJ;
			bool btoward=bForword;
			this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
			CString  Name_PassXHJ;
			for(int k=0;k<nArrayPassXHJ.GetCount();k++)
			{
				CString name_xhj;
				GetEntName(nArrayPassXHJ[k],name_xhj);
				CString EntName;
				GetEntBlkNameByHandle(nArrayPassXHJ[k],EntName);
				if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
				{
				 	name_xhj+=_T("D");
				}
				Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
			}
			GuoXHJ.Add(Name_PassXHJ);
			long t2=GetTickCount();
			CString str;
			str.Format("DiaoCheFindNextLineAndXHJ time:%d ms",t2-t1);
			//acutPrintf(_T("\n %s"),str);
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		//调车信号机遇到股道时结束
		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		{
			//如果起始位股道，则结束
			return;
		}
		else
		{
			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			long t2=GetTickCount();
			CString str;
			//str.Format("DiaoCheFindNextLineAndXHJ time:%d ms",t2-t1);
			//acutPrintf(_T("\n %s"),str);
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		if(bForword==true)
		{
			//this->GetGuiDaoDaoChaOrderByXAsc(nHandleLineStart, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineDaoChaOrderByXAsc(nHandleLineStart,nArrayHandleDC);
		}
		else
		{
			//this->GetGuiDaoChaOrderByXDesc(nHandleLineStart,  nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineChaOrderByXDesc(nHandleLineStart,nArrayHandleDC);
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nHandleLineStart==nHandleLineEnd)
			{//找到，结束
				CLongArray nArrayPassXHJ;
				bool btoward=bForword;
				this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
				CString  Name_PassXHJ;
				for(int k=0;k<nArrayPassXHJ.GetCount();k++)
				{
					CString name_xhj;
					GetEntName(nArrayPassXHJ[k],name_xhj);
					//对于调车来说，应该只包括对向的调车信号机
					CString EntName;
					GetEntBlkNameByHandle(nArrayPassXHJ[k],EntName);
					if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
					{
						name_xhj+=_T("D");
					}
				    Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
				}
// 				CString Daocha=_T("");
// 				GuoDaoCha.Add(Daocha);
				GuoXHJ.Add(Name_PassXHJ);
				return;
			}
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					CLongArray nArrayPassXHJ;
					//this->GetGuiDaoXHJ(nHandleNextLine,nArrayPassXHJ);
					//获取轨道左端信号机
					bool btoward=bForword;
					this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
					CString  Name_PassXHJ;
					for(int k=0;k<nArrayPassXHJ.GetCount();k++)
					{
						CString name_xhj;
						GetEntName(nArrayPassXHJ[k],name_xhj);
						CString EntName;
						GetEntBlkNameByHandle(nArrayPassXHJ[k],EntName);
						if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
						{
							name_xhj+=_T("D");
						}
					    Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");

					}
					GuoXHJ.Add(Name_PassXHJ);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					long nHandleThisDC=0;
					nArrayHandleThisDaocha.Add(nHandleThisDC);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						//acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			//查找上次访问的道岔位置
			int index_lastDaocha=-1;
			double d_x=0;
			if(LastDaocha!=0)
			{
				index_lastDaocha=CBlkUtility::FindLongInArray(nArrayHandleDC,LastDaocha);
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), LastDaocha) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"),d_x) ;
			}
			for(int k=index_lastDaocha+1;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线1"));
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{   //反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线2"));
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							//反位线不为渡线
							nArrayHandleLine.Add(nHandle_fw);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
							//acutPrintf(_T("\n遇到交叉渡线3"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
							//acutPrintf(_T("\n遇到交叉渡线"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}
			//所有道岔为定位时
			if(nHandleNextLine!=0)
			{
				long nHandleThisDC=0;
				nArrayHandleThisDaocha.Add(nHandleThisDC);
				nArrayHandleLine.Add(nHandleNextLine);
				CLongArray nPassXHJ;
				CString  Name_PassXHJ=_T("");
				//GetBlockPosition_X(nHandleThisDC,pointx);
				//GetGuiDaoXHJ(nHandleNextLine,nPassXHJ);
				//所有道岔为定位时后继
				int b_toward=(bForword);
				GetGuiDaoDuanXHJ(nHandleNextLine,b_toward,nPassXHJ);
				for(int k=0;k<nPassXHJ.GetCount();k++)
				{
					CString name;
					GetEntName(nPassXHJ[k],name);
					CString EntName;
					GetEntBlkNameByHandle(nPassXHJ[k],EntName);
					if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
					{
						name+=_T("D");
					}
					if(name==_T("X3"))
					{
						name=name;
					}
					Name_PassXHJ=Name_PassXHJ+name+_T("，");
				}
				GuoXHJ.Add(Name_PassXHJ);
				GuoDaoCha.Add(DaochaD);
			}
			else
			{
				//可能为某一个道岔的反位线
				//还有可能当前线为某一个道岔的反位线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
				//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
				//反位线对应的道岔
				long nHandleDC=0;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
				if(nHandleDC!=0)
				{
					//查询道岔所在的线，该线为后继
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandle_dw=0;
					// long nHandle_fw=0;						
					int IsStart=-1;
					//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
					CString DCname;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
					if(bForword==true&&IsStart>0)
					{
						//定位所在线为后继
						nArrayHandleLine.Add(nHandle_dw);
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						CString Daocha=DaochaD+_T("，")+_T("(")+DCname+_T(")");
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							// Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

						}
						else
						{
							// Daocha=_T("(")+DCname+_T(")");

						}
						//CString Daocha=_T("(")+DCname+_T(")");
						// 						   //道岔反位时，需要考虑是否存在带动道岔
						GuoDaoCha.Add(Daocha);
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
					}
					else if(bForword==false&&IsStart==0)
					{
						nArrayHandleLine.Add(nHandle_dw);
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						CString Daocha=DaochaD+_T(",")+_T("(")+DCname+_T(")");
						//道岔反位时，需要考虑是否存在带动道岔
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						//CString Daocha;
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							//CString Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
						}
						else
						{
							//CString Daocha=_T("(")+DCname+_T(")");
						}
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
						GuoDaoCha.Add(Daocha);
					}
					else
					{
					}
				}
			}
	}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}

//该函数中添加记录上次访问过的道岔，主要用于在寻找后继的时候，只将属于进路的道岔写入GuoDaoCha,LastDaocha用于记录上次到nHandleLineStart的道岔，nArrayHandleThisDaocha,用于记录这次最后访问的道岔号
//在原基础上加入轨道区段上的信号机，包括同方向信号机和背向信号机，信号机可能为调车信号机，也可能为列车信号机
/*******************函数说明:FindNextLineAndXHJ2*******************************************************************************************************************************************************************/
/**********功能：通过一条进路的起始轨道和终止轨道，找出起始轨道的后继轨道，并返回从起始轨道到下一条轨道中走过的道岔以及属于进路上的信号机，后继轨道可能有多条*******************************************************************/
/**********输入：nHandleLineStart,进路的起始轨道线；nHandLineEnd,设定进路的终止轨道线，用于终止进路寻找过程*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔；bForward,用于标记寻找后继防线，true为向右推进***************************************************************************/
/*****************Gudao，股道名称，可以用于终止继续寻找；JieJinQuDuan，接近区段名称;******************************************************************************************************/
/**********输出：GuoDaocha,用于记录在寻找进路的过程中走过的道岔,属于联锁表中的一项内容； nArrayHandleThisDaocha，到下一条进路时走过相应道岔*************************************/
/*****************nArrayHandleNextLine,返回所有的后继轨道区段;  GuoXHJ,到一条进路时走过的信号机，信号机属于进路内部*******************************************************************/
/*****************CStringArray&strCXGuiDaoName,用于记录需要占用的超限区段******************************************************************************************************************************************************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
void CZnSxt::DiaoCheFindNextLineAndXHJ2( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,long LastDaocha,CLongArray& nArrayHandleThisDaocha,CStringArray& GuoXHJ,CLongArray& nArrayHandleLine,CStringArray&strCXGuiDaoName,bool bForword/*=true*/ )
{
	try
	{
		long t1=GetTickCount();
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			CLongArray nArrayPassXHJ;
			bool btoward=bForword;
			this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
			CString  Name_PassXHJ;
			for(int k=0;k<nArrayPassXHJ.GetCount();k++)
			{
				CString name_xhj;
				GetEntName(nArrayPassXHJ[k],name_xhj);
				CString EntName;
				GetEntBlkNameByHandle(nArrayPassXHJ[k],EntName);
				if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
				{
					name_xhj+=_T("D");
				}
				Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
			}
			GuoXHJ.Add(Name_PassXHJ);
			long t2=GetTickCount();
			CString str;
			str.Format("DiaoCheFindNextLineAndXHJ time:%d ms",t2-t1);
			//acutPrintf(_T("\n %s"),str);
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		//调车信号机遇到股道时结束
		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		{
			//如果起始位股道，则结束
			return;
		}
		else
		{
			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s  handle=%ld"),name.GetString(),nHandleLineStart);
			long t2=GetTickCount();
			CString str;
			//str.Format("DiaoCheFindNextLineAndXHJ time:%d ms",t2-t1);
			//acutPrintf(_T("\n %s"),str);
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		if(bForword==true)
		{
			//this->GetGuiDaoDaoChaOrderByXAsc(nHandleLineStart, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineDaoChaOrderByXAsc(nHandleLineStart,nArrayHandleDC);
		}
		else
		{
			//this->GetGuiDaoChaOrderByXDesc(nHandleLineStart,  nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineChaOrderByXDesc(nHandleLineStart,nArrayHandleDC);
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nHandleLineStart==nHandleLineEnd)
			{//找到，结束
				CLongArray nArrayPassXHJ;
				bool btoward=bForword;
				this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
				CString  Name_PassXHJ;
				for(int k=0;k<nArrayPassXHJ.GetCount();k++)
				{
					CString name_xhj;
					GetEntName(nArrayPassXHJ[k],name_xhj);
					//对于调车来说，应该只包括对向的调车信号机
					CString EntName;
					GetEntBlkNameByHandle(nArrayPassXHJ[k],EntName);
					if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
					{
						name_xhj+=_T("D");
					}
					Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
				}
				// 				CString Daocha=_T("");
				// 				GuoDaoCha.Add(Daocha);
				GuoXHJ.Add(Name_PassXHJ);
				return;
			}
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					//增加超限区段
					int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine);
					if(i!=-1)
					{
						strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
					}
					else
					{
						strCXGuiDaoName.Add(_T(""));
					}
					CLongArray nArrayPassXHJ;
					//this->GetGuiDaoXHJ(nHandleNextLine,nArrayPassXHJ);
					//获取轨道左端信号机
					bool btoward=bForword;
					this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
					CString  Name_PassXHJ;
					for(int k=0;k<nArrayPassXHJ.GetCount();k++)
					{
						CString name_xhj;
						GetEntName(nArrayPassXHJ[k],name_xhj);
						CString EntName;
						GetEntBlkNameByHandle(nArrayPassXHJ[k],EntName);
						if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
						{
							name_xhj+=_T("D");
						}
						Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");

					}
					GuoXHJ.Add(Name_PassXHJ);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					long nHandleThisDC=0;
					nArrayHandleThisDaocha.Add(nHandleThisDC);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						//acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			//查找上次访问的道岔位置
			int index_lastDaocha=-1;
			double d_x=0;
			if(LastDaocha!=0)
			{
				index_lastDaocha=CBlkUtility::FindLongInArray(nArrayHandleDC,LastDaocha);
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), LastDaocha) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"),d_x) ;
			}
			for(int k=index_lastDaocha+1;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									CString strCXTemp;
									int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw2);
									if(i!=-1)
									{
										strCXTemp=this->strArrayGuiDaoCX.GetAt(i);
									}
									else
									{
										strCXTemp=_T("");
									}
									int j=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
									if(j!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(j);
									}
									else
									{
										strCXTemp+=_T("");
									}
									int k=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine2);
									if(k!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(k);
									}
									else
									{
										strCXTemp+=_T("");
									}
									strCXGuiDaoName.Add(strCXTemp);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线1"));
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{   //反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									CString strCXTemp;
									int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw2);
									if(i!=-1)
									{
										strCXTemp=this->strArrayGuiDaoCX.GetAt(i);
									}
									else
									{
										strCXTemp=_T("");
									}
									int j=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
									if(j!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(j);
									}
									else
									{
										strCXTemp+=_T("");
									}
									int k=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine2);
									if(k!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(k);
									}
									else
									{
										strCXTemp+=_T("");
									}
									strCXGuiDaoName.Add(strCXTemp);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线2"));
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							//反位线不为渡线
							nArrayHandleLine.Add(nHandle_fw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
							//acutPrintf(_T("\n遇到交叉渡线3"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
							//acutPrintf(_T("\n遇到交叉渡线"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}
			//所有道岔为定位时
			if(nHandleNextLine!=0)
			{
				long nHandleThisDC=0;
				nArrayHandleThisDaocha.Add(nHandleThisDC);
				nArrayHandleLine.Add(nHandleNextLine);
				int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine);
				if(i!=-1)
				{
					strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
				}
				else
				{
					strCXGuiDaoName.Add(_T(""));
				}
				CLongArray nPassXHJ;
				CString  Name_PassXHJ=_T("");
				//GetBlockPosition_X(nHandleThisDC,pointx);
				//GetGuiDaoXHJ(nHandleNextLine,nPassXHJ);
				//所有道岔为定位时后继
				int b_toward=(bForword);
				GetGuiDaoDuanXHJ(nHandleNextLine,b_toward,nPassXHJ);
				for(int k=0;k<nPassXHJ.GetCount();k++)
				{
					CString name;
					GetEntName(nPassXHJ[k],name);
					CString EntName;
					GetEntBlkNameByHandle(nPassXHJ[k],EntName);
					if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
					{
						name+=_T("D");
					}
					if(name==_T("X3"))
					{
						name=name;
					}
					Name_PassXHJ=Name_PassXHJ+name+_T("，");
				}
				GuoXHJ.Add(Name_PassXHJ);
				GuoDaoCha.Add(DaochaD);
			}
			else
			{
				//可能为某一个道岔的反位线
				//还有可能当前线为某一个道岔的反位线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
				//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
				//反位线对应的道岔
				long nHandleDC=0;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
				if(nHandleDC!=0)
				{
					//查询道岔所在的线，该线为后继
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandle_dw=0;
					// long nHandle_fw=0;						
					int IsStart=-1;
					//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
					CString DCname;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
					if(bForword==true&&IsStart>0)
					{
						//定位所在线为后继
						nArrayHandleLine.Add(nHandle_dw);
						int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
						if(i!=-1)
						{
							strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
						}
						else
						{
							strCXGuiDaoName.Add(_T(""));
						}
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						CString Daocha=DaochaD+_T("，")+_T("(")+DCname+_T(")");
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							// Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

						}
						else
						{
							// Daocha=_T("(")+DCname+_T(")");

						}
						//CString Daocha=_T("(")+DCname+_T(")");
						// 						   //道岔反位时，需要考虑是否存在带动道岔
						GuoDaoCha.Add(Daocha);
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
					}
					else if(bForword==false&&IsStart==0)
					{
						nArrayHandleLine.Add(nHandle_dw);
						int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
						if(i!=-1)
						{
							strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
						}
						else
						{
							strCXGuiDaoName.Add(_T(""));
						}
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						CString Daocha=DaochaD+_T(",")+_T("(")+DCname+_T(")");
						//道岔反位时，需要考虑是否存在带动道岔
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						//CString Daocha;
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							//CString Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
						}
						else
						{
							//CString Daocha=_T("(")+DCname+_T(")");
						}
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
						GuoDaoCha.Add(Daocha);
					}
					else
					{
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in DiaoCheFindNextLineAndXHJ"));
	}	

}
//该函数中添加记录上次访问过的道岔，主要用于在寻找后继的时候，只将属于进路的道岔写入GuoDaoCha,LastDaocha用于记录上次到nHandleLineStart的道岔，nArrayHandleThisDaocha,用于记录这次最后访问的道岔号
//在原基础上加入轨道区段上的信号机，包括同方向信号机和背向信号机，信号机可能为调车信号机，也可能为列车信号机
/*******************函数说明:FindNextLineAndXHJ*******************************************************************************************************************************************************************/
/**********功能：通过一条进路的起始轨道和终止轨道，找出起始轨道的后继轨道，并返回从起始轨道到下一条轨道中走过的道岔以及属于进路上的信号机，后继轨道可能有多条*******************************************************************/
/**********输入：nHandleLineStart,进路的起始轨道线；nHandLineEnd,设定进路的终止轨道线，用于终止进路寻找过程*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔；bForward,用于标记寻找后继防线，true为向右推进***************************************************************************/
/*****************Gudao，股道名称，可以用于终止继续寻找；JieJinQuDuan，接近区段名称;******************************************************************************************************/
/**********输出：GuoDaocha,用于记录在寻找进路的过程中走过的道岔,属于联锁表中的一项内容； nArrayHandleThisDaocha，到下一条进路时走过相应道岔*************************************/
/*****************nArrayHandleNextLine,返回所有的后继轨道区段;  GuoXHJ,到一条进路时走过的信号机，信号机属于进路内部*******************************************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
void CZnSxt::DiaoCheFindNextLineAndXHJ( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,long LastDaocha,CLongArray& nArrayHandleThisDaocha,CStringArray& GuoXHJ,CLongArray& nArrayHandleLine,CStringArray&strCXGuiDaoName, bool bForword/*=true*/ )
{
	try
	{
		long t1=GetTickCount();
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			CLongArray nArrayPassXHJ;
			bool btoward=bForword;
			this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
			CString  Name_PassXHJ;
			for(int k=0;k<nArrayPassXHJ.GetCount();k++)
			{
				CString name_xhj;
				GetEntName(nArrayPassXHJ[k],name_xhj);
				Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
			}
			GuoXHJ.Add(Name_PassXHJ);
			long t2=GetTickCount();
			CString str;
			str.Format("DiaoCheFindNextLineAndXHJ time:%d ms",t2-t1);
			//acutPrintf(_T("\n %s"),str);
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		//调车信号机遇到股道时结束
		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		{
			return;
		}
		else
		{
			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			long t2=GetTickCount();
			CString str;
			str.Format("DiaoCheFindNextLineAndXHJ time:%d ms",t2-t1);
			acutPrintf(_T("\n %s"),str);
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType;
		if(bForword==true)
		{
			//this->GetGuiDaoDaoChaOrderByXAsc(nHandleLineStart, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineDaoChaOrderByXAsc(nHandleLineStart,nArrayHandleDC);
		}
		else
		{
			//this->GetGuiDaoChaOrderByXDesc(nHandleLineStart,  nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineChaOrderByXDesc(nHandleLineStart,nArrayHandleDC);
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nHandleLineStart==nHandleLineEnd)
			{//找到，结束
				CLongArray nArrayPassXHJ;
				bool btoward=bForword;
				this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
				CString  Name_PassXHJ;
				for(int k=0;k<nArrayPassXHJ.GetCount();k++)
				{
					CString name_xhj;
					GetEntName(nArrayPassXHJ[k],name_xhj);
					//对于调车来说，应该只包括对向的调车信号机
					Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
				}
				GuoXHJ.Add(Name_PassXHJ);
				return;
			}
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					//增加超限区段
					int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine);
					if(i!=-1)
					{
						strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
					}
					else
					{
						strCXGuiDaoName.Add(_T(""));
					}
					CLongArray nArrayPassXHJ;
					//this->GetGuiDaoXHJ(nHandleNextLine,nArrayPassXHJ);
					//获取轨道左端信号机
					bool btoward=bForword;
					this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
					CString  Name_PassXHJ;
					for(int k=0;k<nArrayPassXHJ.GetCount();k++)
					{
						CString name_xhj;
						GetEntName(nArrayPassXHJ[k],name_xhj);
						Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");

					}
					GuoXHJ.Add(Name_PassXHJ);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					long nHandleThisDC=0;
					nArrayHandleThisDaocha.Add(nHandleThisDC);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						//acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			//查找上次访问的道岔位置
			int index_lastDaocha=-1;
			double d_x=0;
			if(LastDaocha!=0)
			{
				index_lastDaocha=CBlkUtility::FindLongInArray(nArrayHandleDC,LastDaocha);
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), LastDaocha) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"),d_x) ;
			}
			for(int k=index_lastDaocha+1;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									CString strCXTemp;
									int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw2);
									if(i!=-1)
									{
										strCXTemp=this->strArrayGuiDaoCX.GetAt(i);
									}
									else
									{
										strCXTemp=_T("");
									}
									int j=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
									if(j!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(j);
									}
									else
									{
										strCXTemp+=_T("");
									}
									int k=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine2);
									if(k!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(k);
									}
									else
									{
										strCXTemp+=_T("");
									}
									strCXGuiDaoName.Add(strCXTemp);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线1"));
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{   //反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									CString strCXTemp;
									int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw2);
									if(i!=-1)
									{
										strCXTemp=this->strArrayGuiDaoCX.GetAt(i);
									}
									else
									{
										strCXTemp=_T("");
									}
									int j=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
									if(j!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(j);
									}
									else
									{
										strCXTemp+=_T("");
									}
									int k=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine2);
									if(k!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(k);
									}
									else
									{
										strCXTemp+=_T("");
									}
									strCXGuiDaoName.Add(strCXTemp);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线2"));
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							//反位线不为渡线
							nArrayHandleLine.Add(nHandle_fw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
							//acutPrintf(_T("\n遇到交叉渡线3"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
							//acutPrintf(_T("\n遇到交叉渡线"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}
			//所有道岔为定位时
			// 			long nHandleThisDC=0;
			// 			nArrayHandleThisDaocha.Add(nHandleThisDC);
			// 			nArrayHandleLine.Add(nHandleNextLine);
			// 			CLongArray nPassXHJ;
			// 			CString  Name_PassXHJ=_T("");
			// 			//GetBlockPosition_X(nHandleThisDC,pointx);
			// 			//GetGuiDaoXHJ(nHandleNextLine,nPassXHJ);
			// 			//所有道岔为定位时后继
			// 			int b_toward=(bForword);
			// 			GetGuiDaoDuanXHJ(nHandleNextLine,b_toward,nPassXHJ);
			// 			for(int k=0;k<nPassXHJ.GetCount();k++)
			// 			{
			// 				CString name;
			// 				GetEntName(nPassXHJ[k],name);
			// 				Name_PassXHJ=Name_PassXHJ+name+_T("，");
			// 			}
			// 			GuoXHJ.Add(Name_PassXHJ);
			// 			GuoDaoCha.Add(DaochaD);
			// 	}
			//所有道岔为定位时
			if(nHandleNextLine!=0)
			{
				long nHandleThisDC=0;
				nArrayHandleThisDaocha.Add(nHandleThisDC);
				nArrayHandleLine.Add(nHandleNextLine);
				int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine);
				if(i!=-1)
				{
					strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
				}
				else
				{
					strCXGuiDaoName.Add(_T(""));
				}
				CLongArray nPassXHJ;
				CString  Name_PassXHJ=_T("");
				//GetBlockPosition_X(nHandleThisDC,pointx);
				//GetGuiDaoXHJ(nHandleNextLine,nPassXHJ);
				//所有道岔为定位时后继
				int b_toward=(bForword);
				GetGuiDaoDuanXHJ(nHandleNextLine,b_toward,nPassXHJ);
				for(int k=0;k<nPassXHJ.GetCount();k++)
				{
					CString name;
					GetEntName(nPassXHJ[k],name);
					if(name==_T("X3"))
					{
						name=name;
					}
					Name_PassXHJ=Name_PassXHJ+name+_T("，");
				}
				GuoXHJ.Add(Name_PassXHJ);
				GuoDaoCha.Add(DaochaD);
			}
			else
			{
				//可能为某一个道岔的反位线
				//还有可能当前线为某一个道岔的反位线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
				//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
				//反位线对应的道岔
				long nHandleDC=0;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
				if(nHandleDC!=0)
				{
					//查询道岔所在的线，该线为后继
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandle_dw=0;
					// long nHandle_fw=0;						
					int IsStart=-1;
					//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
					CString DCname;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
					if(bForword==true&&IsStart>0)
					{
						//定位所在线为后继
						nArrayHandleLine.Add(nHandle_dw);
						int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
						if(i!=-1)
						{
							strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
						}
						else
						{
							strCXGuiDaoName.Add(_T(""));
						}
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						CString Daocha=DaochaD+_T("，")+_T("(")+DCname+_T(")");
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							// Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

						}
						else
						{
							// Daocha=_T("(")+DCname+_T(")");

						}
						//CString Daocha=_T("(")+DCname+_T(")");
						// 						   //道岔反位时，需要考虑是否存在带动道岔
						GuoDaoCha.Add(Daocha);
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
					}
					else if(bForword==false&&IsStart==0)
					{
						nArrayHandleLine.Add(nHandle_dw);
						int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
						if(i!=-1)
						{
							strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
						}
						else
						{
							strCXGuiDaoName.Add(_T(""));
						}
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						CString Daocha=DaochaD+_T(",")+_T("(")+DCname+_T(")");
						//道岔反位时，需要考虑是否存在带动道岔
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						//CString Daocha;
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							//CString Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
						}
						else
						{
							//CString Daocha=_T("(")+DCname+_T(")");
						}
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
						GuoDaoCha.Add(Daocha);
					}
					else
					{
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
//该函数中添加记录上次访问过的道岔，主要用于在寻找后继的时候，只将属于进路的道岔写入GuoDaoCha,LastDaocha用于记录上次到nHandleLineStart的道岔，nArrayHandleThisDaocha,用于记录这次最后访问的道岔号
//在原基础上加入轨道区段上的信号机，包括同方向信号机和背向信号机，信号机可能为调车信号机，也可能为列车信号机
/*******************函数说明:LieCheFindNextLineAndXHJ*******************************************************************************************************************************************************************/
/**********功能：通过一条进路的起始轨道和终止轨道，找出起始轨道的后继轨道，并返回从起始轨道到下一条轨道中走过的道岔以及属于进路上的信号机，后继轨道可能有多条*******************************************************************/
/**********输入：nHandleLineStart,进路的起始轨道线；nHandLineEnd,设定进路的终止轨道线，用于终止进路寻找过程*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔；bForward,用于标记寻找后继防线，true为向右推进***************************************************************************/
/*****************Gudao，股道名称，可以用于终止继续寻找；JieJinQuDuan，接近区段名称;******************************************************************************************************/
/**********输出：GuoDaocha,用于记录在寻找进路的过程中走过的道岔,属于联锁表中的一项内容； nArrayHandleThisDaocha，到下一条进路时走过相应道岔*************************************/
/*****************nArrayHandleNextLine,返回所有的后继轨道区段;  GuoXHJ,到一条进路时走过的信号机，信号机属于进路内部*******************************************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
void CZnSxt::LieCheFindNextLineAndXHJ( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,long LastDaocha,CLongArray& nArrayHandleThisDaocha,CStringArray& GuoXHJ,CLongArray& nArrayHandleLine,CStringArray &strCXGuiDaoName,bool bForword/*=true*/ )
{
	try
	{
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			CLongArray nArrayPassXHJ;
			bool btoward=bForword;
			this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
			CString  Name_PassXHJ;
			for(int k=0;k<nArrayPassXHJ.GetCount();k++)
			{
				CString name_xhj;
				GetEntName(nArrayPassXHJ[k],name_xhj);
				if(name_xhj==_T("X3"))
				{
					name_xhj=name_xhj;
				}
				Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
			}
			GuoXHJ.Add(Name_PassXHJ);
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		//列车与调车的区别，调车遇到Gudao必须终止
// 		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
// 		{
// 			//如果起始位股道，则结束
// 			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
// 			return;
// 		}
// 		else
// 		{
// 			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
// 		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
		if(bForword==true)
		{
			//this->GetGuiDaoDaoChaOrderByXAsc(nHandleLineStart, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineDaoChaOrderByXAsc(nHandleLineStart,nArrayHandleDC);
		}
		else
		{
			//this->GetGuiDaoChaOrderByXDesc(nHandleLineStart,  nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineChaOrderByXDesc(nHandleLineStart,nArrayHandleDC);
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
	//	int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nHandleLineStart==nHandleLineEnd)
			{//找到，结束
				CLongArray nArrayPassXHJ;
				bool btoward=bForword;
				this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
				CString  Name_PassXHJ;
				for(int k=0;k<nArrayPassXHJ.GetCount();k++)
				{
					CString name_xhj;
					GetEntName(nArrayPassXHJ[k],name_xhj);
					if(name_xhj==_T("X3"))
					{
						name_xhj=name_xhj;
					}
					Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
				}
				return;
			}
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine);
					if(i!=-1)
					{
						strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
					}
					else
					{
						strCXGuiDaoName.Add(_T(""));
					}
					CLongArray nArrayPassXHJ;
					//this->GetGuiDaoXHJ(nHandleNextLine,nArrayPassXHJ);
					//获取轨道左端信号机
					bool btoward=bForword;
					this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
					CString  Name_PassXHJ;
					for(int k=0;k<nArrayPassXHJ.GetCount();k++)
					{
						CString name_xhj;
						GetEntName(nArrayPassXHJ[k],name_xhj);
						if(name_xhj==_T("X3"))
						{
							name_xhj=name_xhj;
						}
						Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
					}
					GuoXHJ.Add(Name_PassXHJ);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					long nHandleThisDC=0;
					nArrayHandleThisDaocha.Add(nHandleThisDC);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						//acutPrintf(_T("\n nHandNextLine为0"));
						//该线是否仍然为某道岔的反位线
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			//查找上次访问的道岔位置
			int index_lastDaocha=-1;
			double d_x=0;
			if(LastDaocha!=0)
			{
				index_lastDaocha=CBlkUtility::FindLongInArray(nArrayHandleDC,LastDaocha);
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), LastDaocha) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"),d_x) ;
			}
			for(int k=index_lastDaocha+1;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									CString strCXTemp;
									int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw2);
									if(i!=-1)
									{
										strCXTemp=this->strArrayGuiDaoCX.GetAt(i);
									}
									else
									{
										strCXTemp=_T("");
									}
									int j=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
									if(j!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(j);
									}
									else
									{
										strCXTemp+=_T("");
									}
									int k=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine2);
									if(k!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(k);
									}
									else
									{
										strCXTemp+=_T("");
									}
									strCXGuiDaoName.Add(strCXTemp);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线1"));
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{   //反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									CString strCXTemp;
									int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw2);
									if(i!=-1)
									{
										strCXTemp=this->strArrayGuiDaoCX.GetAt(i);
									}
									else
									{
										strCXTemp=_T("");
									}
									int j=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
									if(j!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(j);
									}
									else
									{
										strCXTemp+=_T("");
									}
									int k=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine2);
									if(k!=-1)
									{
										strCXTemp+=this->strArrayGuiDaoCX.GetAt(k);
									}
									else
									{
										strCXTemp+=_T("");
									}
									strCXGuiDaoName.Add(strCXTemp);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线2"));
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							//反位线不为渡线
							nArrayHandleLine.Add(nHandle_fw);
							int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_fw);
							if(i!=-1)
							{
								strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
							}
							else
							{
								strCXGuiDaoName.Add(_T(""));
							}
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
							//acutPrintf(_T("\n遇到交叉渡线3"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
							//acutPrintf(_T("\n遇到交叉渡线"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}//endfor
			//所有道岔为定位时
			if(nHandleNextLine!=0)
			{
				long nHandleThisDC=0;
				nArrayHandleThisDaocha.Add(nHandleThisDC);
				nArrayHandleLine.Add(nHandleNextLine);
				int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandleNextLine);
				if(i!=-1)
				{
					strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
				}
				else
				{
					strCXGuiDaoName.Add(_T(""));
				}
				CLongArray nPassXHJ;
				CString  Name_PassXHJ=_T("");
				//GetBlockPosition_X(nHandleThisDC,pointx);
				//GetGuiDaoXHJ(nHandleNextLine,nPassXHJ);
				//所有道岔为定位时后继
				int b_toward=(bForword);
				GetGuiDaoDuanXHJ(nHandleNextLine,b_toward,nPassXHJ);
				for(int k=0;k<nPassXHJ.GetCount();k++)
				{
					CString name;
					GetEntName(nPassXHJ[k],name);
					if(name==_T("X3"))
					{
						name=name;
					}
					Name_PassXHJ=Name_PassXHJ+name+_T("，");
				}
				GuoXHJ.Add(Name_PassXHJ);
				GuoDaoCha.Add(DaochaD);
			}
			else
			{
				//可能为某一个道岔的反位线
				//还有可能当前线为某一个道岔的反位线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
				//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
				//反位线对应的道岔
				long nHandleDC=0;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
				if(nHandleDC!=0)
				{
					//查询道岔所在的线，该线为后继
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandle_dw=0;
					// long nHandle_fw=0;						
					int IsStart=-1;
					//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
					CString DCname;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
					if(bForword==true&&IsStart>0)
					{
						//定位所在线为后继
						nArrayHandleLine.Add(nHandle_dw);
						int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
						if(i!=-1)
						{
							strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
						}
						else
						{
							strCXGuiDaoName.Add(_T(""));
						}
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						CString Daocha=DaochaD+_T("，")+_T("(")+DCname+_T(")");
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							// Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

						}
						else
						{
							// Daocha=_T("(")+DCname+_T(")");

						}
						//CString Daocha=_T("(")+DCname+_T(")");
						// 						   //道岔反位时，需要考虑是否存在带动道岔
						GuoDaoCha.Add(Daocha);
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
					}
					else if(bForword==false&&IsStart==0)
					{
						nArrayHandleLine.Add(nHandle_dw);
						int i=CBlkUtility::FindLongInArray(this->nArrayHandLineCX,nHandle_dw);
						if(i!=-1)
						{
							strCXGuiDaoName.Add(this->strArrayGuiDaoCX.GetAt(i));
						}
						else
						{
							strCXGuiDaoName.Add(_T(""));
						}
						CString  Name_PassXHJ=_T("");
						GuoXHJ.Add(Name_PassXHJ);
						CString Daocha=DaochaD+_T(",")+_T("(")+DCname+_T(")");
						//道岔反位时，需要考虑是否存在带动道岔
						long nHandleDaiDong_nMin=0;
						long nHandleDaiDong_nMax=0;
						CString DaiDong_MinName;
						CString DaiDong_MaxName;
						//CString Daocha;
						if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
						{
							//CString Daocha=_T("(")+DCname+_T(")");
							GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
							GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
							Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
						}
						else
						{
							//CString Daocha=_T("(")+DCname+_T(")");
						}
						long nHandleThisDC=nHandleDC;
						nArrayHandleThisDaocha.Add(nHandleThisDC);
						GuoDaoCha.Add(Daocha);
					}
					else
					{
					}
			}
		}
	}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
//该函数中添加记录上次访问过的道岔，主要用于在寻找后继的时候，只将属于进路的道岔写入GuoDaoCha,LastDaocha用于记录上次到nHandleLineStart的道岔，nArrayHandleThisDaocha,用于记录这次最后访问的道岔号
//在原基础上加入轨道区段上的信号机，包括同方向信号机和背向信号机，信号机可能为调车信号机，也可能为列车信号机
/*******************函数说明:FindNextLineAndXHJ*******************************************************************************************************************************************************************/
/**********功能：通过一条进路的起始轨道和终止轨道，找出起始轨道的后继轨道，并返回从起始轨道到下一条轨道中走过的道岔以及属于进路上的信号机，后继轨道可能有多条*******************************************************************/
/**********输入：nHandleLineStart,进路的起始轨道线；nHandLineEnd,设定进路的终止轨道线，用于终止进路寻找过程*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔；bForward,用于标记寻找后继防线，true为向右推进***************************************************************************/
/*****************Gudao，股道名称，可以用于终止继续寻找；JieJinQuDuan，接近区段名称;******************************************************************************************************/
/**********输出：GuoDaocha,用于记录在寻找进路的过程中走过的道岔,属于联锁表中的一项内容； nArrayHandleThisDaocha，到下一条进路时走过相应道岔*************************************/
/*****************nArrayHandleNextLine,返回所有的后继轨道区段;  GuoXHJ,到一条进路时走过的信号机，信号机属于进路内部*******************************************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
void CZnSxt::FindNextLineAndXHJ( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,long LastDaocha,CLongArray& nArrayHandleThisDaocha,CStringArray& GuoXHJ,CLongArray& nArrayHandleLine,bool bForword/*=true*/ )
{
	try
	{
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			CLongArray nArrayPassXHJ;
			bool btoward=bForword;
			this->GetGuiDaoDuanXHJ(nHandleLineEnd,btoward,nArrayPassXHJ);
			CString  Name_PassXHJ;
			for(int k=0;k<nArrayPassXHJ.GetCount();k++)
			{
				CString name_xhj;
				GetEntName(nArrayPassXHJ[k],name_xhj);
				if(name_xhj==_T("X3"))
				{
					name_xhj=name_xhj;
				}
				Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
			}
			GuoXHJ.Add(Name_PassXHJ);
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		//列车与调车的区别，调车遇到Gudao必须终止
		// 		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		// 		{
		// 			//如果起始位股道，则结束
		// 			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
		// 			return;
		// 		}
		// 		else
		// 		{
		// 			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		// 		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
		if(bForword==true)
		{
			this->GetGuiDaoDaoChaOrderByXAsc(nHandleLineStart,  nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		else
		{
			this->GetGuiDaoChaOrderByXDesc(nHandleLineStart,  nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nHandleLineStart==nHandleLineEnd)
			{//找到，结束
				CLongArray nArrayPassXHJ;
				bool btoward=bForword;
				this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
				CString  Name_PassXHJ;
				for(int k=0;k<nArrayPassXHJ.GetCount();k++)
				{
					CString name_xhj;
					GetEntName(nArrayPassXHJ[k],name_xhj);
					if(name_xhj==_T("X3"))
					{
						name_xhj=name_xhj;
					}
					Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
				}
				return;
			}
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					CLongArray nArrayPassXHJ;
					//this->GetGuiDaoXHJ(nHandleNextLine,nArrayPassXHJ);
					//获取轨道左端信号机
					bool btoward=bForword;
					this->GetGuiDaoDuanXHJ(nHandleNextLine,btoward,nArrayPassXHJ);
					CString  Name_PassXHJ;
					for(int k=0;k<nArrayPassXHJ.GetCount();k++)
					{
						CString name_xhj;
						GetEntName(nArrayPassXHJ[k],name_xhj);
						if(name_xhj==_T("X3"))
						{
							name_xhj=name_xhj;
						}
						Name_PassXHJ=Name_PassXHJ+name_xhj+_T("，");
					}
					// 					CString str_nametemp;
					// 					m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),str_nametemp);
					// 					acutPrintf(_T("\n %s轨道的端信号机为%s"),str_nametemp.GetString(),Name_PassXHJ.GetString());
					GuoXHJ.Add(Name_PassXHJ);
					//nArrayZhiXHJ.Add(Zhi_XHJ);
					//nArrayXiangXHJ.Add(Xiang_XHJ);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					long nHandleThisDC=0;
					nArrayHandleThisDaocha.Add(nHandleThisDC);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							CString Daocha=_T("(")+DCname+_T(")");
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							//CString Daocha=_T("(")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							GuoDaoCha.Add(Daocha);
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=_T("(")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//CString Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								//CString Daocha=_T("(")+DCname+_T(")");
							}
							long nHandleThisDC=nHandleDC;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						//acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			//查找上次访问的道岔位置
			int index_lastDaocha=-1;
			double d_x=0;
			if(LastDaocha!=0)
			{
				index_lastDaocha=CBlkUtility::FindLongInArray(nArrayHandleDC,LastDaocha);
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), LastDaocha) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"),d_x) ;
			}
			for(int k=index_lastDaocha+1;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线1"));
									//需要考虑是否有带动道岔存在
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									// 								//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									//	CString Daocha;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										//Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

									}
									else
									{
										// Daocha=_T("(")+DCname+_T(")");

									}
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{   //反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							// CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								//Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
							}
							else
							{
								// Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
								{
									nArrayHandleLine.Add(nHandle_dw2);
									long nHandleThisDC=nHandleDC2;
									nArrayHandleThisDaocha.Add(nHandleThisDC);
									double pointx;
									CLongArray nPassXHJ;
									CString  Name_PassXHJ=_T("");
									GuoXHJ.Add(Name_PassXHJ);
								}
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHandleDC2,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//acutPrintf(_T("\n遇到交叉渡线2"));
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									long nHandleDaiDong_nMin=0;
									long nHandleDaiDong_nMax=0;
									CString DaiDong_MinName;
									CString DaiDong_MaxName;
									if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
									{
										// Daocha=_T("(")+DCname+_T(")");
										GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
										GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
										Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");
									}
									else
									{
										//Daocha=_T("(")+DCname+_T(")");
									}
									GuoDaoCha.Add(Daocha);
								}
							}
						}
						else
						{
							//反位线不为渡线
							nArrayHandleLine.Add(nHandle_fw);
							long nHandleThisDC=0;
							nArrayHandleThisDaocha.Add(nHandleThisDC);
							double pointx;
							CLongArray nPassXHJ;
							CString  Name_PassXHJ=_T("");
							GuoXHJ.Add(Name_PassXHJ);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							long nHandleDaiDong_nMin=0;
							long nHandleDaiDong_nMax=0;
							CString DaiDong_MinName;
							CString DaiDong_MaxName;
							//CString Daocha;
							if(GetDaidongDaochas1(nHandleDC,nHandleDaiDong_nMin,nHandleDaiDong_nMax)==TRUE)
							{
								// Daocha=_T("(")+DCname+_T(")");
								GetEntName(nHandleDaiDong_nMin,DaiDong_MinName);
								GetEntName(nHandleDaiDong_nMax,DaiDong_MaxName);
								Daocha=Daocha+_T("，")+_T("{")+DaiDong_MinName+_T("/")+DaiDong_MaxName+_T("}");

							}
							else
							{
								//Daocha=_T("(")+DCname+_T(")");

							}
							GuoDaoCha.Add(Daocha);
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{
						DaochaD=DaochaD+DCname1;
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
							//acutPrintf(_T("\n遇到交叉渡线3"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
							//acutPrintf(_T("\n遇到交叉渡线"));
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
						}

					}
				}
			}
			//所有道岔为定位时
			long nHandleThisDC=0;
			nArrayHandleThisDaocha.Add(nHandleThisDC);
			nArrayHandleLine.Add(nHandleNextLine);
			CLongArray nPassXHJ;
			CString  Name_PassXHJ=_T("");
			//GetBlockPosition_X(nHandleThisDC,pointx);
			//GetGuiDaoXHJ(nHandleNextLine,nPassXHJ);
			//所有道岔为定位时后继
			int b_toward=(bForword);
			GetGuiDaoDuanXHJ(nHandleNextLine,b_toward,nPassXHJ);
			for(int k=0;k<nPassXHJ.GetCount();k++)
			{
				CString name;
				GetEntName(nPassXHJ[k],name);
				if(name==_T("X3"))
				{
					name=name;
				}
				Name_PassXHJ=Name_PassXHJ+name+_T("，");
			}
			GuoXHJ.Add(Name_PassXHJ);
			GuoDaoCha.Add(DaochaD);
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
//记录访问过的道岔，避免走回路，顺便记录走过道岔的定反位，用于联锁表
void CZnSxt::FindNextLine( long nHandleLineStart,long nHandleLineEnd,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	try
	{
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
		if(bForword==true)
		{
			//this->GetGuiDaoDaoChaOrderByXAsc(nHandleLineStart, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineDaoChaOrderByXAsc(nHandleLineStart,nArrayHandleDC);
		}
		else
		{
			//this->GetGuiDaoChaOrderByXDesc(nHandleLineStart, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			this->GetOnLineChaOrderByXDesc(nHandleLineStart,nArrayHandleDC);
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		//int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					// 					CString Daocha=_T("");
					// 					GuoDaoCha.Add(Daocha);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
						}
					}
					else
					{
						acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{
			//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			for(int k=0;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
									nArrayHandleLine.Add(nHandle_dw2);
							}
						}
						else
						{//反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
									nArrayHandleLine.Add(nHandle_dw2);
							}
						}
						//	acutPrintf(_T("Isstart=%d"),IsStart);
					}
				}
				else
				{

				}
				/*GuoDaoCha.Add(DaochaD);*/
			}
			nArrayHandleLine.Add(nHandleNextLine);
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
//用PassDaocha记录去往每条后继的道岔号，GuoDaocha还会详细记录走过道岔的定反位
void CZnSxt::FindNextLine4( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &PassDaoCha,CStringArray &Gudao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
{
	try
	{
		// static int stop =0;
		if(nHandleLineStart==nHandleLineEnd)
		{//找到，结束
			return;
		}
		CString GuidaoName;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
		{
			//如果起始位股道，则结束
			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
			return;
		}
		else
		{
			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//表示为尽头线
		if (nLineType==2) 
		{
			CString name;
			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
			return ;
		}
		//判断轨道上DC个数
		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
		//获取轨道信息，这个函数需要仔细看看
		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
		if(bForword==true)
		{
			this->GetGuiDaoInfoOrderByXAsc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		else
		{
			this->GetGuiDaoInfoOrderByXDesc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
		}
		//for test print DC
		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
		CString guiname;
		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(iNumDC<1)
		{
			//轨道不包含道岔时，后继只有一个
			if(nLineType==0)
			{//不为渡线时
				if(nHandleNextLine!=0)
				{
					nArrayHandleLine.Add(nHandleNextLine);
					CString Daocha=_T("");
					GuoDaoCha.Add(Daocha);
					PassDaoCha.Add(Daocha);
				}
				else
				{
					//还有可能当前线为某一个道岔的反位线
					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
					//反位线对应的道岔
					long nHandleDC=0;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
					if(nHandleDC!=0)
					{
						//查询道岔所在的线，该线为后继
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
						//反位线对应的道岔
						long nHandle_dw=0;
						// long nHandle_fw=0;						
						int IsStart=-1;
						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						CString DCname;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
						if(bForword==true&&IsStart>0)
						{
							//定位所在线为后继
							nArrayHandleLine.Add(nHandle_dw);
							CString Daocha=_T("（")+DCname+_T(")");
							// 						   //道岔反位时，需要考虑是否存在带动道岔
							//GuoDaoCha.Add(Daocha);	
							CString DaoChaNum=DCname+_T("_");
							PassDaoCha.Add(DaoChaNum);
							GuoDaoCha.Add(Daocha);

						}
						else if(bForword==false&&IsStart==0)
						{
							nArrayHandleLine.Add(nHandle_dw);
							CString Daocha=_T("（")+DCname+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							CString DaoChaNum=DCname+_T("_");
							PassDaoCha.Add(DaoChaNum);
							GuoDaoCha.Add(Daocha);
						}
					}
					else
					{
						acutPrintf(_T("\n nHandNextLine为0"));
					}
				}
			}
			else
			{
			}
			//return;
		}//endif NumDC
		else
		{//含有道岔时，可能存在多条后继
			//道岔为定位时后继
			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
			CString DaochaD;
			CString DaoChaDNum;
			for(int k=0;k<iNumDC;k++)
			{//道岔反位时后继,需要前面访问的道岔
				//取道岔handle
				long nHandleDC=nArrayHandleDC[k];
				//查询反位所在线
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				long nHandle_fw=0;
				long nHandle_dw=0;
				int IsStart=-1;
				CString DCname1;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
				long nHanderDC_another=0;
				//向右推进有后继时
				if(IsStart==0&&bForword==true)
				{
					//向右推进时起点
					if(nHandle_fw!=0)
					{
						//继续往下求一次后继，判断是否为渡线
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
									nArrayHandleLine.Add(nHandle_dw2);
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								//判断渡线道岔是否属于交叉渡线的道岔
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T(",")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//GuoDaoCha.Add(Daocha);
									CString DaoChaNum=DaoChaDNum+DCname_nMin+_T("_")+DCname_nMax+_T("_")+DC_Another_Min+_T("_")+DC_Another_Max+_T("_");
									PassDaoCha.Add(DaoChaNum);
									GuoDaoCha.Add(Daocha);						
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									//GuoDaoCha.Add(Daocha);
									CString DaoChaNum=DaoChaDNum+DCname_nMin+_T("_")+DCname_nMax+_T("_");
									PassDaoCha.Add(DaoChaNum);
									GuoDaoCha.Add(Daocha);
								}						
							}
						}
						else
						{//反位线不为渡线时
							nArrayHandleLine.Add(nHandle_fw);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							//道岔反位时，需要考虑是否存在带动道岔
							//GuoDaoCha.Add(Daocha);
							CString DaoChaNum=DaoChaDNum+DCname1+_T("_");
							PassDaoCha.Add(DaoChaNum);	
							GuoDaoCha.Add(Daocha);			
						}
					}
				}
				else if(IsStart>0&&bForword==false)
				{
					//向左推进时起点
					if(nHandle_fw!=0)
					{
						//nArrayHandleLine.Add(nHandle_fw);
						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
						long nLineType = 0 ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
						if(nLineType==1)
						{
							//为渡线时，求反位线的后继
							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
							//如果是向右寻找，则找右端绝缘节。
							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
							long nHandleNextLine2 = 0 ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//读取结果集
							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
							//再找该反位线所在道岔的定位线
							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
							//反位线对应的道岔
							long nHandleDC2=0;
							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
							if(nHandleDC2!=0)
							{
								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
								//查询道岔所在的线，该线为后继
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
								//反位线对应的道岔
								long nHandle_dw2=0;				
								//int IsStart=-1;
								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
								//nHandle_dw2即为渡线的后继
								if(nHandle_dw2!=0)
									nArrayHandleLine.Add(nHandle_dw2);
								//打印渡线道岔
								CString DCname_nMin;
								CString DCname_nMax;
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
								long nHandle_Anothe_Min=0;
								long nHandle_Anothe_Max=0;
								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
								{
									CString DC_Another_Min;
									CString DC_Another_Max;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									Daocha=Daocha+_T(",")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
									//GuoDaoCha.Add(Daocha);
									CString DaochaNum=DaoChaDNum+DCname_nMin+_T("_")+DCname_nMax+_T("_")+DC_Another_Min+_T("_")+DC_Another_Max+_T("_");
									PassDaoCha.Add(DaochaNum);
									GuoDaoCha.Add(Daocha);
								}
								else
								{
									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
									Daocha=Daocha+DCname_nMax+_T(")");
									//道岔反位时，需要考虑是否存在带动道岔
									//GuoDaoCha.Add(Daocha);
									CString DaoChaNum=DaoChaDNum+DCname_nMin+_T("_")+DCname_nMax+_T("_");
									PassDaoCha.Add(DaoChaNum);
									GuoDaoCha.Add(Daocha);			
								}
							}
						}
						else
						{
							nArrayHandleLine.Add(nHandle_fw);
							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
							CString DaoChaNum=DaoChaDNum+DCname1+_T("_");
							//GuoDaoCha.Add(Daocha);
							PassDaoCha.Add(DaoChaNum);
							GuoDaoCha.Add(Daocha);				
						}
					}
					//	acutPrintf(_T("Isstart=%d"),IsStart);
				}
				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
				if(b_dx==false)
				{
					if(k==iNumDC-1)
					{	
						DaochaD=DaochaD+DCname1;
						DaoChaDNum=DaoChaDNum+DCname1+_T("_");	
					}
					else
					{
						DaochaD=DaochaD+DCname1+_T("，");
						DaoChaDNum=DaoChaDNum+DCname1+_T("_");
					}
				}
				else
				{
					CString DCname_Min;
					CString DCname_Max;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
					long nHandle_Anothe_Min=0;
					long nHandle_Anothe_Max=0;
					if(k==iNumDC-1)
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;	
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;	
							DaoChaDNum=DaoChaDNum+DCname_Min+_T("_")+DCname_Max+_T("_")+DC_Another_Min+_T("_")+DC_Another_Max+_T("_");
						}
						else
						{

							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max;
							DaoChaDNum=DaoChaDNum+DCname_Min+_T("_")+DCname_Max+_T("_");

						}
					}
					else
					{
						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
						{
							CString DC_Another_Min;
							CString DC_Another_Max;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;		
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;	
							DaoChaDNum=DaoChaDNum+DCname_Min+_T("_")+DCname_Max+_T("_")+DC_Another_Min+_T("_")+DC_Another_Max+_T("_");

							//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
						}
						else
						{
							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
							DaoChaDNum=DaoChaDNum+DCname_Min+_T("_")+DCname_Max+_T("_");
						}

					}
				}
			}
			nArrayHandleLine.Add(nHandleNextLine);
			GuoDaoCha.Add(DaochaD);
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}	
}
// 记录访问过的道岔，避免走回路，顺便记录走过道岔的定反位，用于联锁表,加入带动道岔测试
// void CZnSxt::FindNextLine5( long nHandleLineStart,long nHandleLineEnd,CStringArray &GuoDaoCha,CStringArray &Gudao,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
// {
// 	try
// 	{
// 		// static int stop =0;
// 		if(nHandleLineStart==nHandleLineEnd)
// 		{//找到，结束
// 			return;
// 		}
// 		CString GuidaoName;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),GuidaoName);
// 		if(CBlkUtility::FindStrInArray(Gudao,GuidaoName.GetString())!=-1)
// 		{
// 			//如果起始位股道，则结束
// 			//acutPrintf(_T("股道名称=%s"),GuidaoName.GetString());
// 			return;
// 		}
// 		else
// 		{
// 			//acutPrintf(_T("轨道名称=%s"),GuidaoName.GetString());
// 		}
// 		CADORecordset cSet(&m_AdoDb) ;
// 		CString strSql ;
// 		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineStart) ;
// 		long nLineType = 0 ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 		//表示为尽头线
// 		if (nLineType==2) 
// 		{
// 			CString name;
// 			m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),name);
// 			acutPrintf(_T("\n 尽头线：%s"),name.GetString());
// 			return ;
// 		}
// 		//判断轨道上DC个数
// 		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
// 		//获取轨道信息，这个函数需要仔细看看
// 		//this->GetGuiDaoInfo(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
// 		if(bForword==true)
// 		{
// 			this->GetGuiDaoInfoOrderByXAsc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
// 		}
// 		else
// 		{
// 			this->GetGuiDaoInfoOrderByXDesc(nHandleLineStart, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
// 		}
// 		//for test print DC
// 		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
// 		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
// 		//int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
// 		CString guiname;
// 		m_mysys.GetXdata(nHandleLineStart,_T("GUIDAONAME"),guiname);
// 		//acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道名称=%d"),iNumDC,iNumXHJ,guiname.GetString());
// 		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
// 		//如果是向右寻找，则找右端绝缘节。
// 		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
// 		long nHandleNextLine = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 		//读取结果集
// 		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 		if(iNumDC<1)
// 		{
// 			//轨道不包含道岔时，后继只有一个
// 			if(nLineType==0)
// 			{//不为渡线时
// 				if(nHandleNextLine!=0)
// 				{
// 					nArrayHandleLine.Add(nHandleNextLine);
// 					CString Daocha=_T("");
// 					GuoDaoCha.Add(Daocha);
// 				}
// 				else
// 				{
// 					//还有可能当前线为某一个道岔的反位线
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 					//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 					//反位线对应的道岔
// 					long nHandleDC=0;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 					if(nHandleDC!=0)
// 					{
// 						//查询道岔所在的线，该线为后继
// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 						//反位线对应的道岔
// 						long nHandle_dw=0;
// 						// long nHandle_fw=0;						
// 						int IsStart=-1;
// 						//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 						CString DCname;
// 						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname) ;
// 						if(bForword==true&&IsStart>0)
// 						{
// 							//定位所在线为后继
// 							nArrayHandleLine.Add(nHandle_dw);
// 							CString Daocha=_T("（")+DCname+_T(")");
// 							// 						   //道岔反位时，需要考虑是否存在带动道岔
// 							GuoDaoCha.Add(Daocha);
// 						}
// 						else if(bForword==false&&IsStart==0)
// 						{
// 							nArrayHandleLine.Add(nHandle_dw);
// 							CString Daocha=_T("（")+DCname+_T(")");
// 							//道岔反位时，需要考虑是否存在带动道岔
// 							GuoDaoCha.Add(Daocha);
// 						}
// 					}
// 					else
// 					{
// 						acutPrintf(_T("\n nHandNextLine为0"));
// 					}
// 				}
// 			}
// 			// 			else if(nLineType==1)
// 			// 			{
// 			// 				//为渡线时
// 			// 				acutPrintf(_T("\n该线为渡线"));
// 			// 				strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 			// 				CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 			// 				//读取结果集
// 			// 				//	m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 			// 				//渡线绝缘节在右侧时
// 			// 				if(nHandleLeftJyj==0&&nHandleRightJyj!=0)
// 			// 				{
// 			// 					//找渡线绝缘节在左侧的渡线
// 			// 					if(bForword==true)
// 			// 					{
// 			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"), nHandleNextLine);
// 			// 						if(nHandleNextLine!=0)
// 			// 						{
// 			// 							nArrayHandleLine.Add(nHandleNextLine);
// 			// 						}
// 			// 
// 			// 						else
// 			// 						{
// 			// 							acutPrintf(_T("\n nHandNextLine为0"));
// 			// 						}
// 			// 					}
// 			// 					else 
// 			// 					{
// 			// 						//后继为道岔定位所在轨道
// 			// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 			// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 			// 						//反位线对应的道岔
// 			// 						long nHandleDC=0;
// 			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 			// 						//道岔所在轨道即为后继轨道
// 			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
// 			// 						if(nHandleNextLine!=0)
// 			// 						{
// 			// 							nArrayHandleLine.Add(nHandleNextLine);
// 			// 						}
// 			// 						else
// 			// 						{
// 			// 							acutPrintf(_T("\n nHandNextLine为0"));
// 			// 						}
// 			// 					}
// 			// 				}
// 			// 				//渡线绝缘节在做左侧时
// 			// 				else if(nHandleLeftJyj!=0&&nHandleRightJyj==0)
// 			// 				{
// 			// 					if(bForword==false)
// 			// 					{
// 			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"), nHandleNextLine);
// 			// 						if(nHandleNextLine!=0)
// 			// 						{
// 			// 							nArrayHandleLine.Add(nHandleNextLine);
// 			// 						}
// 			// 					}
// 			// 					else
// 			// 					{
// 			// 						////后继为道岔定位所在轨道
// 			// 						strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineStart) ;
// 			// 						//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 			// 						//反位线对应的道岔
// 			// 						long nHandleDC=0;
// 			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC);
// 			// 						//道岔所在轨道即为后继轨道
// 			// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleNextLine);
// 			// 						if(nHandleNextLine!=0)
// 			// 						{
// 			// 							nArrayHandleLine.Add(nHandleNextLine);
// 			// 						}
// 			// 						else
// 			// 						{
// 			// 							acutPrintf(_T("\n nHandNextLine为0"));
// 			// 						}
// 			// 					}
// 			// 
// 			// 				}
// 			// 			}
// 			else
// 			{
// 			}
// 			//return;
// 		}//endif NumDC
// 		else
// 		{//含有道岔时，可能存在多条后继
// 			//道岔为定位时后继
// 			//只要有一个道岔为反位，就是一条新的后继，这个结论通常应该是没问题的
// 			CString DaochaD;
// 			for(int k=0;k<iNumDC;k++)
// 			{//道岔反位时后继,需要前面访问的道岔
// 				//取道岔handle
// 				long nHandleDC=nArrayHandleDC[k];
// 				//查询反位所在线
// 				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 				long nHandle_fw=0;
// 				long nHandle_dw=0;
// 				int IsStart=-1;
// 				CString DCname1;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname1) ;
// 				long nHanderDC_another=0;
// 				//向右推进有后继时
// 				if(IsStart==0&&bForword==true)
// 				{
// 					//向右推进时起点
// 					if(nHandle_fw!=0)
// 					{
// 						//继续往下求一次后继，判断是否为渡线
// 						//nArrayHandleLine.Add(nHandle_fw);
// 						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
// 						long nLineType = 0 ;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 						if(nLineType==1)
// 						{
// 							//为渡线时，求反位线的后继
// 							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
// 							//如果是向右寻找，则找右端绝缘节。
// 							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
// 							long nHandleNextLine2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//读取结果集
// 							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
// 							//再找该反位线所在道岔的定位线
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
// 							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//反位线对应的道岔
// 							long nHandleDC2=0;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
// 							if(nHandleDC2!=0)
// 							{
// 								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
// 								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
// 								//查询道岔所在的线，该线为后继
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
// 								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 								//反位线对应的道岔
// 								long nHandle_dw2=0;				
// 								//int IsStart=-1;
// 								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
// 								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 								//nHandle_dw2即为渡线的后继
// 								if(nHandle_dw2!=0)
// 									nArrayHandleLine.Add(nHandle_dw2);
// 								//打印渡线道岔
// 								CString DCname_nMin;
// 								CString DCname_nMax;
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
// 								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
// 								long nHandle_Anothe_Min=0;
// 								long nHandle_Anothe_Max=0;
// 								//判断渡线道岔是否属于交叉渡线的道岔
// 								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 								{
// 									CString DC_Another_Min;
// 									CString DC_Another_Max;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
// 									GuoDaoCha.Add(Daocha);
// 								}
// 								else
// 								{
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									//道岔反位时，需要考虑是否存在带动道岔
// 									GuoDaoCha.Add(Daocha);
// 								}						
// 							}
// 						}
// 						else
// 						{//反位线不为渡线时
// 							nArrayHandleLine.Add(nHandle_fw);
// 							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
// 							//道岔反位时，需要考虑是否存在带动道岔
// 							GuoDaoCha.Add(Daocha);
// 						}
// 					}
// 				}
// 				else if(IsStart>0&&bForword==false)
// 				{
// 					//向左推进时起点
// 					if(nHandle_fw!=0)
// 					{
// 						//nArrayHandleLine.Add(nHandle_fw);
// 						strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandle_fw) ;
// 						long nLineType = 0 ;
// 						m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 						if(nLineType==1)
// 						{
// 							//为渡线时，求反位线的后继
// 							long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
// 							//如果是向右寻找，则找右端绝缘节。
// 							int nHandleEndConJyj = (bForword?nHandleRightJyj2:nHandleLeftJyj2) ; //线末端连接的绝缘节handle
// 							long nHandleNextLine2 = 0 ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 							CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//读取结果集
// 							m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine2);
// 							//再找该反位线所在道岔的定位线
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine2) ;
// 							//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 							//反位线对应的道岔
// 							long nHandleDC2=0;
// 							m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleDC2);
// 							if(nHandleDC2!=0)
// 							{
// 								long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHandleDC2);
// 								long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHandleDC2);	
// 								//查询道岔所在的线，该线为后继
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC2) ;
// 								//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 								//反位线对应的道岔
// 								long nHandle_dw2=0;				
// 								//int IsStart=-1;
// 								//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw2) ;
// 								//m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 								//nHandle_dw2即为渡线的后继
// 								if(nHandle_dw2!=0)
// 									nArrayHandleLine.Add(nHandle_dw2);
// 								//打印渡线道岔
// 								CString DCname_nMin;
// 								CString DCname_nMax;
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMin);
// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
// 								m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"), DCname_nMax);
// 								//acutPrintf(_T("\n渡线道岔反位：(%s/%s)"),Daocha1.GetString(),Daocha2.GetString());
// 								long nHandle_Anothe_Min=0;
// 								long nHandle_Anothe_Max=0;
// 								if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 								{
// 									CString DC_Another_Min;
// 									CString DC_Another_Max;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 									strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 									m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 									//DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									Daocha=Daocha+_T("，")+_T("[")+DC_Another_Min+_T("/")+DC_Another_Max+_T("]");
// 									GuoDaoCha.Add(Daocha);
// 								}
// 								else
// 								{
// 									CString Daocha=DaochaD+_T("(")+DCname_nMin+_T("/");
// 									Daocha=Daocha+DCname_nMax+_T(")");
// 									//道岔反位时，需要考虑是否存在带动道岔
// 									GuoDaoCha.Add(Daocha);
// 								}
// 							}
// 						}
// 						else
// 						{
// 							nArrayHandleLine.Add(nHandle_fw);
// 							CString Daocha=DaochaD+_T("(")+DCname1+_T(")");
// 							// 						long nHandle_DdMin=0;
// 							// 						long nHandle_DdMax=0;
// 							// 						long nHandle_DdAno=0;
// 							// 						if(this->GetDaidongDaochas(nHandleDC,nHandle_DdMin,nHandle_DdMax)==TRUE)
// 							// 						{
// 							// 							CString DDname1; 
// 							// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_DdMin) ;
// 							// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DDname1) ;
// 							// 							CString DDname2; 
// 							// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_DdMin) ;
// 							// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DDname2) ;
// 							// 							//Daocha=Daocha+_T("，")+_T("{")+DDname1+_T("/")+DDname2+_T("}");
// 							// 							 acutPrintf(_T("\n{%s/%s}"),DDname1.GetString(),DDname2.GetString());
// 							// 						}
// 							// 						else if(this->GetAnotherDuXianDaoCha(nHandleDC,nHandle_DdAno)==TRUE)
// 							// 						{
// 							// 							if(this->GetDaidongDaochas(nHandle_DdAno,nHandle_DdMin,nHandle_DdMax)==TRUE)
// 							// 							{
// 							// 								CString DDname1; 
// 							// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_DdMin) ;
// 							// 								m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DDname1) ;
// 							// 								CString DDname2; 
// 							// 								strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_DdMin) ;
// 							// 								m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DDname2) ;
// 							// 								//Daocha=Daocha+_T("，")+_T("{")+DDname1+_T("/")+DDname2+_T("}");
// 							// 								 acutPrintf(_T("\n{%s/%s}"),DDname1.GetString(),DDname2.GetString());
// 							// 							}			   
// 							// 						}
// 							// 						else
// 							// 						{
// 							// 
// 							// 						}
// 							GuoDaoCha.Add(Daocha);
// 						}
// 					}
// 					//	acutPrintf(_T("Isstart=%d"),IsStart);
// 				}
// 				//strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 				BOOL b_dx=GetAnotherDuXianDaoCha(nHandleDC,nHanderDC_another);
// 				long nMinDc=GetDuXianMinDaoCha(nHandleDC,nHanderDC_another);
// 				long nMaxDc=GetDuXianMaxDaoCha(nHandleDC,nHanderDC_another);		
// 				if(b_dx==false)
// 				{
// 					if(k==iNumDC-1)
// 					{
// 						DaochaD=DaochaD+DCname1;
// 					}
// 					else
// 					{
// 						DaochaD=DaochaD+DCname1+_T("，");
// 					}
// 				}
// 				else
// 				{
// 					CString DCname_Min;
// 					CString DCname_Max;
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMinDc) ;
// 					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Min) ;
// 					strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nMaxDc) ;
// 					m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DCname_Max) ;
// 					//acutPrintf(_T("\n%s另一个道岔为%s %ld"),DCname1.GetString(),DCname_Anthor.GetString(),nHanderDC_another);
// 					long nHandle_Anothe_Min=0;
// 					long nHandle_Anothe_Max=0;
// 					if(k==iNumDC-1)
// 					{
// 						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 						{
// 							CString DC_Another_Min;
// 							CString DC_Another_Max;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max;
// 
// 						}
// 						else
// 						{
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
// 						}
// 					}
// 					else
// 					{
// 						if(GetJiaoChaDuXianAnotherDaoChas(nHandleDC,nHanderDC_another,nHandle_Anothe_Min,nHandle_Anothe_Max)==TRUE)
// 						{
// 							CString DC_Another_Min;
// 							CString DC_Another_Max;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Min) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Min) ;
// 							strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_Anothe_Max) ;
// 							m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_name"),DC_Another_Max) ;
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，")+DC_Another_Min+_T("/")+DC_Another_Max+_T("，");
// 						}
// 						else
// 						{
// 							DaochaD =DaochaD+DCname_Min+_T("/")+DCname_Max+_T("，");
// 						}
// 
// 					}
// 				}
// 			}
// 			nArrayHandleLine.Add(nHandleNextLine);
// 			GuoDaoCha.Add(DaochaD);
// 		}
// 	}
// 	catch(_com_error& e)
// 	{
// 		CString sBuff = CBlkUtility::GetErrorDescription(e);
// 		AfxMessageBox(sBuff);        
// 	}
// 	catch(...)
// 	{	
// 		AfxMessageBox(_T("未知的错误!in FindNextLine"));
// 	}	
// }
// void CZnSxt::FindNextLine( long nHandleLine,CLongArray&nArrayHandleLine,bool bForword/*=true*/ )
// {
// 	try
// 	{
// 		CADORecordset cSet(&m_AdoDb) ;
// 		CString strSql ;
// 		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLine) ;
// 		long nLineType = 0 ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 		if (nLineType==2) 
// 		{
// 			return ;
// 		}
// 		//判断轨道上DC个数
// 		CLongArray nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType ;
// 		//获取轨道信息，这个函数需要仔细看看
// 		this->GetGuiDaoInfo(nHandleLine, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;	
// 		int iNumDC = nArrayHandleDC.GetCount() ;//当前轨道电路包含几个道岔
// 		int iNumXHJ = nArrayHandleXHJ.GetCount() ; //当前轨道电路连接有几架信号机
// 		int iNumLine = nArrayLineDoneCur.GetCount() ; //当前轨道电路由几段组成
// 		acutPrintf(_T("\n 道岔个数=%d,信号机个数=%d,轨道区段=%d"),iNumDC,iNumXHJ,iNumLine);
// 		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLine) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLine) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
// 		//如果是向右寻找，则找右端绝缘节。
// 		int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
// 		long nHandleNextLine = 0 ;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
// 		CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
// 		//读取结果集
// 		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
// 		if(iNumDC<1)
// 		{
// 			//股道不包含道岔时，后继只有一个
// 			nArrayHandleLine.Add(nHandleNextLine);
// 		    //return;
// 		}
// 		else
// 		{
// 			nArrayHandleLine.Add(nHandleNextLine);
// 			//判断道岔类型，渡线，交叉渡线，单动道岔
// 			for(int k=0;k<iNumDC;k++)
// 			{
// 				//取道岔handle
// 				long nHandleDC=nArrayHandleDC[k];
// 				//查询定位所在线
// 				//查询反位所在线
// 				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
// 				long nHandle_fw;
// 				long nHandle_dw;
// 				int IsStart=-1;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
// 				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandle_dw) ;
// 				m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
// 				if(IsStart==0&&bForword==true)
// 				{
// 					//向有推进时起点
// 					nArrayHandleLine.Add(nHandle_fw);
// 					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLine) ;
// 					long nLineType = 0 ;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 					acutPrintf(_T("\n nlineType=%d"),nLineType);
// 				}
// 				else if(IsStart>0&&bForword==false)
// 				{
// 					//向左推进时起点
// 					nArrayHandleLine.Add(nHandle_fw);
// 					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLine) ;
// 					long nLineType = 0 ;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 					acutPrintf(_T("\n nlineType=%d"),nLineType);
// 				}
// 				acutPrintf(_T("Isstart=%d"),IsStart);
// 			}
// 
// 
// 		}
// 	}
// 	catch(_com_error& e)
// 	{
// 		CString sBuff = CBlkUtility::GetErrorDescription(e);
// 		AfxMessageBox(sBuff);        
// 	}
// 	catch(...)
// 	{	
// 		AfxMessageBox(_T("未知的错误!in FindNextLine"));
// 	}	
// }

int CZnSxt::GetAll_LJ_XHJ( CLongArray& nArrayHandleDc )
{
	long t1=GetTickCount();
	int iRet = 0 ;
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);
	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();
	AcDbEntity * pEnt = NULL ;
	CString strSql ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;

				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;				
				if (strBlkName.Left(6)==_T("XHJ_LJ"))
				{
					UINT nHandle = m_mysys.GetHandle(pEnt) ;
					nArrayHandleDc.Add(nHandle) ;
					iRet++ ;
				}
			}

			pEnt->close() ;
		}	
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;
	long t2=GetTickCount();
	CString str;
	str.Format("GetAll_LJ_XHJ:%d ms",t2-t1);
	acutPrintf(_T("\n%s"),str);
	return iRet ;

}
BOOL CZnSxt::GetBlockToward( long nHandleXHJ ,int &iToward)
{
	if(nHandleXHJ==0)
	{
		return FALSE;
	}
	long t1=GetTickCount();
	BOOL bRet = FALSE ;
	AcDbEntity* pEnt = NULL ;
	iToward =-1;
	if (m_mysys.OpenAcDbEntity(nHandleXHJ, pEnt, AcDb::kForRead))
	{
		if (pEnt->isKindOf(AcDbBlockReference::desc()))
		{
			AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
			//bRet= GetBlockName(pRef, strBlockName) ;
			double rota=pRef->rotation();
			//acutPrintf(_T("\n %6f"),rota);
			int cnt=0;
			while((rota-PI)>1.0E-6)
			{
				rota-=PI;
				cnt++;
			}
			while((rota+PI)<1.0E-6)
			{
				rota+=PI;
				cnt++;
			}
 			double res=rota-PI/2;
			//acutPrintf("rota=%6f",rota);
			if(res<1.0E-6&&cnt%2==0)
			{
				//朝右
				iToward=1;
			}
			else if(res<1.0E-6&&cnt%2==1)
			{
				iToward=2;
			}
			else if(res>1.0E-6&&cnt%2==0)
			{
				//朝左
				iToward=2;
			}
			else if(res>1.0E-6&&cnt%2==1)
			{
				iToward=1;
			}
			else
			{
				iToward=-1;
			}
		   
		}
		pEnt->close() ;
		bRet =TRUE;
	}
	long t2=GetTickCount();
	CString str;
	str.Format("GetBlockToward:%d ms",t2-t1);
	//acutPrintf(_T("\n%s"),str);
	return bRet ;


}
BOOL CZnSxt::GetBlockPosition( long nHandleBlk ,AcGePoint3d& Ptpost)
{
	if(nHandleBlk==0)
	{
		return FALSE;
	}
	BOOL bRet = FALSE ;
	AcDbEntity* pEnt = NULL ;
//	iToward =-1;
	if (m_mysys.OpenAcDbEntity(nHandleBlk, pEnt, AcDb::kForRead))
	{
		if (pEnt->isKindOf(AcDbBlockReference::desc()))
		{
			AcDbBlockReference* pRef = AcDbBlockReference::cast(pEnt) ;
			//bRet= GetBlockName(pRef, strBlockName) ;
			Ptpost=pRef->position();
		}
		pEnt->close() ;
		bRet =TRUE;
	}
	//acutPrintf(_T("\n%s"),str);
	return bRet ;


}
int CZnSxt::GetSomeBlocks( CString name_left2,CLongArray& nArrayHandleDc )
{
	int iRet = 0 ;
	AcDbBlockTable * pBlkTbl = NULL ;
	m_pDb->getBlockTable(pBlkTbl,AcDb::kForRead);
	AcDbBlockTableRecord * pBlkTblRec = NULL ;
	pBlkTbl->getAt ( ACDB_MODEL_SPACE, pBlkTblRec,AcDb::kForRead )  ;
	pBlkTbl->close() ;
	AcDbBlockTableRecordIterator *pBlkTblRecIter = NULL ;
	pBlkTblRec->newIterator( pBlkTblRecIter );
	pBlkTblRec->close();
	AcDbEntity * pEnt = NULL ;
	CString strSql ;
	for(pBlkTblRecIter->start();!pBlkTblRecIter->done();pBlkTblRecIter->step())
	{
		//遍历并打开实体 ;	
		if (Acad::eOk == pBlkTblRecIter->getEntity(pEnt, AcDb::kForRead))
		{
			if (pEnt->isKindOf(AcDbBlockReference::desc()))
			{
				AcDbBlockReference *pRef = AcDbBlockReference::cast(pEnt) ;

				CString strBlkName ;
				m_mysys.GetBlockName(pRef, strBlkName) ;	
				//pRef->rotation();
				if (strBlkName.Left(6)==name_left2.GetString())
				{
					UINT nHandle = m_mysys.GetHandle(pEnt) ;
					nArrayHandleDc.Add(nHandle) ;
					iRet++ ;
				}
			}

			pEnt->close() ;
		}	
	}
	delete pBlkTblRecIter ;
	pBlkTblRecIter = NULL ;
	return iRet ;


}
void CZnSxt::LsbTest2()
{
	CADORecordset cSet(&m_AdoDb) ;
	CString strSql ;
	CLongArray nArrayHandle_LJ_XHJ;
	int iRet =GetAll_LJ_XHJ(nArrayHandle_LJ_XHJ);
	CLongArray nArrayHandle_LF_XHJ;
	//获取所有出站信号机
	CString name_xhj=_T("XHJ_LF");
	int iRet2 =GetSomeBlocks(name_xhj,nArrayHandle_LF_XHJ);
	long nHandleLinetemp=0;
	long nHandleLinetemp2=0;
	CTime  time_beg=CTime::GetCurrentTime();
	CString str_Time=time_beg.Format("%Y-%m-%d %H:%M:%S");
	acutPrintf(_T("\n程序开始时间%s"),str_Time);
	acutPrintf(_T("\n 出站信号机个数=%d"),iRet2);
	oper_excel.OpenExcel(_T("C:\\辅助开发\\平面图联锁表生成1.xls"));
	//清空excel表
	oper_excel.ClearAllCells(1);
	this->iJLnum=1;
	//获取股道所在轨道
	CLongArray nAarryHandleGuDaoS;
	CLongArray nAarryHandleGuDaoX;
	//下行进站区段
	CLongArray nAarryHandleXJC;
	//下行接近进站区段
	CLongArray nAarryHandleXJJC;
	CLongArray nAarryHandleSJC;
	CLongArray nAarryHandleSJJC;
	CStringArray sXJCGuiDaoName;
	CStringArray sSJCGuiDaoName;
	//上行股道名称
	CStringArray sSGuDaoName;
	//下行股道名称
	CStringArray sXGuDaoName;
	//求超限绝缘
	FindALLChaoXianGuiDao(this->nArrayHandLineCX,this->strArrayGuiDaoCX);
	int length =nArrayHandle_LJ_XHJ.GetCount();
	if(length<1)
	{
		//acutPrintf(_T("\n 信号机个数为%d"),length);
		return;
	}
	//打印进站信号机名称
	for(int i=0;i<length;i++)
	{
		CString entname;
		long nHandleLine =nArrayHandle_LJ_XHJ[i];
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),entname) ;
		acutPrintf(_T("\n 进站信号机名称为%s"),entname.GetString());
		//查询进站信号机右侧直线
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine);
		//寻找后一条轨道
		CLongArray nArrayHandle_GD_Next;
		//上下行接近区段为最外方进站轨道
		//获取下行进站信号机左侧轨道
		if(entname.Left(1)==_T("X"))
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLinetemp) ;
			CString name;
			m_mysys.GetXdata(nHandleLinetemp,_T("GUIDAONAME"),name);
			sXJCGuiDaoName.Add(name);
			acutPrintf(_T("X进站轨道为：%s"),name.GetString());
			nAarryHandleXJC.Add(nHandleLinetemp);
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLinetemp) ;
			nAarryHandleXJJC.Add(nHandleLinetemp);
		}
		else
		{
			//获取上行进站信号机右侧轨道
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLinetemp) ;
			CString name;
			m_mysys.GetXdata(nHandleLinetemp,_T("GUIDAONAME"),name);
			sSJCGuiDaoName.Add(name);
			acutPrintf(_T("S进站轨道为：%s"),name.GetString());
			nAarryHandleSJC.Add(nHandleLinetemp);
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLinetemp) ;
			nAarryHandleSJJC.Add(nHandleLinetemp);
		}
	}
	//打印出站信号机名称
	//CLongArray nArrayHandleLineGuDao;
	for(int i=0;i<iRet2;i++)
	{
		CString entname;
		long nHandleLine =nArrayHandle_LF_XHJ[i];
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),entname) ;
		acutPrintf(_T("\n 出站信号机名称为%s"),entname.GetString());
		//查询进站信号机右侧直线
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine);
		//获取信号机右侧轨道,即为股道
		if(entname.Left(1)==_T("S"))
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLinetemp2) ;
			nAarryHandleGuDaoS.Add(nHandleLinetemp2);
			//打印股道名称
			if(nHandleLinetemp2!=0)
			{
				CString na;
 				m_mysys.GetXdata(nHandleLinetemp2,_T("GUIDAONAME"),na);
				sSGuDaoName.Add(na);
				long zhixhj=0;
				long xiangxhj=0;
				CString str_ent_name;
				CLongArray nArrayHandleXHJ;
				GetGuiDaoDuanXHJ(nHandleLinetemp2,false,nArrayHandleXHJ);
				for(int i=0;i<nArrayHandleXHJ.GetCount();i++)
				{
					zhixhj=nArrayHandleXHJ.GetAt(i);
					GetEntBlkNameByHandle(zhixhj,str_ent_name);
					if(str_ent_name.Left(6)==_T("XHJ_LF"))
					{
						break;
					}
					else
						zhixhj=0;
				}
				while(zhixhj==0)
				{
					long nHandleLineNext=0;
					FindNextLineByJYJ(nHandleLinetemp2,nHandleLineNext,true);
					m_mysys.GetXdata(nHandleLineNext,_T("GUIDAONAME"),na);
					nHandleLinetemp2=nHandleLineNext;
					CLongArray nArrayHandleXHJTemp;
					if(nHandleLineNext!=0)
					{
						GetGuiDaoDuanXHJ(nHandleLineNext,false,nArrayHandleXHJTemp);
					}
				    else
					{
						break;
					}
					for(int i=0;i<nArrayHandleXHJTemp.GetCount();i++)
					{
						zhixhj=nArrayHandleXHJTemp.GetAt(i);
						GetEntBlkNameByHandle(zhixhj,str_ent_name);
						if(str_ent_name.Left(6)==_T("XHJ_LF"))
						{
							break;
						}
						else
						{
							zhixhj=0;
						}

					}
					//break;
				}
				if(nHandleLinetemp2!=0)
				{
					nAarryHandleGuDaoX.Add(nHandleLinetemp2);
				  m_mysys.GetXdata(nHandleLinetemp2,_T("GUIDAONAME"),na);
				  //acutPrintf(_T("gudao:%s"),na.GetString());
				  sXGuDaoName.Add(na);
				}
			}
		}
	}
	for(int i=0;i<sXGuDaoName.GetCount();i++)
	{
		acutPrintf(_T("\n 下行股道包括：%s\t"),sXGuDaoName.GetAt(i).GetString());
	}
	for(int i=0;i<sSGuDaoName.GetCount();i++)
	{
		acutPrintf(_T("\n 上行股道包括：%s\t"),sSGuDaoName.GetAt(i).GetString());
	}
	for(int i=0;i<sXJCGuiDaoName.GetCount();i++)
	{
		acutPrintf(_T("\n 下行接近区段包括：%s\t"),sXJCGuiDaoName.GetAt(i).GetString());
	}
	for(int i=0;i<sSJCGuiDaoName.GetCount();i++)
	{
		acutPrintf(_T("\n 上行接近区段包括：%s\t"),sSJCGuiDaoName.GetAt(i).GetString());
	}
	// 		输出所有下行接车进路
	acutPrintf(_T("\n开始输出下行接车进路\n"));
	for(int i=0;i<nAarryHandleXJC.GetCount();i++)
	{
		long nHandleStart=nAarryHandleXJC[i];
		CString Start_Gd_Name;
		//m_mysys.GetXdata(nHandleStart,Start_Gd_Name);
		m_mysys.GetXdata(nHandleStart,_T("GUIDAONAME"),Start_Gd_Name);
		int i_excel_row_current=this->num;
		CString str_fx;
		for(int k=0;k<nAarryHandleGuDaoX.GetCount();k++)
		{
				long nHandleEnd=nAarryHandleGuDaoX[k];
				vector<CString> path;
				vector<CString>daocha;
				vector<CString>xhj;
				vector<CString>vec_cx_gd;
				CLongArray  nArrayHandle;
				CStringArray DaochaNum;
				long LastDaocha=0;
				long nHandleStartXHJ=0;
				long nHandleEndXHJ=0;
				CLongArray nArrayJinZhanXHJ;
				CLongArray nArrayChuZhanXHJ;
				bool btoward=true;
				//获取终止轨道信号机
				long nHandleLineXHJEnd=nAarryHandleGuDaoS[k];
				this->GetGuiDaoDuanXHJ(nHandleStart,btoward,nArrayJinZhanXHJ);
				if(nArrayJinZhanXHJ.GetCount()>0)
				nHandleStartXHJ=nArrayJinZhanXHJ[0];
				//获取起始信号机名称，作为运行方面的方向
				GetEntName(nHandleStartXHJ,str_fx);
				this->GetGuiDaoDuanXHJ(nHandleLineXHJEnd,btoward,nArrayChuZhanXHJ);
				if(nArrayChuZhanXHJ.GetCount()>0)
				nHandleEndXHJ =nArrayChuZhanXHJ[0];
				int iJL_Cnt_temp=0;
				GetJieChePathGuiDaoAndXHJ(Start_Gd_Name,nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sXGuDaoName,nArrayHandle,vec_cx_gd,iJL_Cnt_temp,btoward);
				//写确定运行方向道岔
				if(iJL_Cnt_temp>=2)
				{
					int row_num=this->num-iJL_Cnt_temp;
					CString strDaocha1;
					CString strDaocha2;
					CString str_diff1;
					CString str_diff2;
					vector<CString>vec_str_Daocha1;
					vector<CString>vec_str_Daocha2;
					oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
					TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
					oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
					TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
					 FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
					 oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
					 oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
				}
				this->num=this->num-iJL_Cnt_temp;
				for(int j=0;j<iJL_Cnt_temp;j++)
				{
					oper_excel.WriteDatatoExcel(1,this->num,6,(j+1));
					this->num++;
				}
		}
		int i_excel_row_current2=this->num;
		oper_excel.SetColumnCombandCells(1,i_excel_row_current,3,i_excel_row_current2-i_excel_row_current);
		oper_excel.WriteDatatoExcel(1,i_excel_row_current,3,_T("接车"));
		//发车进路
		long nHandleEnd=nAarryHandleXJJC[i];
		for(int k=0;k<nAarryHandleGuDaoX.GetCount();k++)
		{
			long nHandleStart=nAarryHandleGuDaoX[k];
			CString Start_Gd_Name;
			m_mysys.GetXdata(nHandleStart,_T("GUIDAONAME"),Start_Gd_Name);
			vector<CString> path;
			vector<CString>daocha;
			vector<CString>xhj;
			vector<CString>vec_cx_gd;
			CLongArray  nArrayHandle;
			CStringArray DaochaNum;
			long LastDaocha=0;
			long nHandleStartXHJ=0;
			long nHandleEndXHJ=0;
			CLongArray nArrayStartXHJ;
			CLongArray nArrayEndXHJ;
			bool btoward=false;
			//获取终止轨道信号机
			long nHandleLineXHJStart=nAarryHandleGuDaoS[k];
			this->GetGuiDaoDuanXHJ(nHandleLineXHJStart,true,nArrayStartXHJ);
			if(nArrayStartXHJ.GetCount()>0)
				nHandleStartXHJ=nArrayStartXHJ[0];
			this->GetGuiDaoDuanXHJ(nHandleEnd,false,nArrayEndXHJ);
			if(nArrayEndXHJ.GetCount()>0)
				nHandleEndXHJ =nArrayEndXHJ[0];
			int iJL_Cnt_temp=0;
			GetFaChePathGuiDaoAndXHJ(Start_Gd_Name,nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sXGuDaoName,nArrayHandle,vec_cx_gd,iJL_Cnt_temp,false);
			if(iJL_Cnt_temp>=2)
			{
				int row_num=this->num-iJL_Cnt_temp;
				CString strDaocha1;
				CString strDaocha2;
				CString str_diff1;
				CString str_diff2;
				vector<CString>vec_str_Daocha1;
				vector<CString>vec_str_Daocha2;
				oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
				TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
				oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
				TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
				FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
				oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
				oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
			}
			this->num=this->num-iJL_Cnt_temp;
			for(int j=0;j<iJL_Cnt_temp;j++)
			{
				oper_excel.WriteDatatoExcel(1,this->num,6,(j+1));
				this->num++;
			}
		}
		int i_excel_row_current3=this->num;
		oper_excel.SetColumnCombandCells(1,i_excel_row_current2,3,i_excel_row_current3-i_excel_row_current2);
		oper_excel.WriteDatatoExcel(1,i_excel_row_current2,3,_T("发车"));
		//通过进路，且为正线通过
		for(int i_col=3;i_col<=17;i_col++)
		{
			oper_excel.SetColumnCombandCells(1,this->num,i_col,2);
			if(i_col==3)
			{
				oper_excel.WriteDatatoExcel(1,this->num,3,_T("通过"));
			}
		}
		//查询通过进路
		nHandleStart=nAarryHandleXJC[i];
		for(int m=0;m<nAarryHandleSJJC.GetCount();m++)
		{
			long nHandleTjEnd=nAarryHandleSJJC[m];
			long nxhj_start=0;
			long nxhj_end=0;
			long nlastdaocha=0;
			vector<CString>vec_xhj;
			vector<CString>vec_path;
			vector<CString>vec_daocha;
			vector<CString>vec_cxgd;
			CLongArray nArrayHandleLineTJ;
			CString str_GdStartname;
			CString str_xhj_start;
			CString str_xhj_end;
			int i_CntTJ=0;
			CLongArray nArrayHandleStartXHJ;
			CLongArray nArrayHandleEndXHJ;
			this->GetGuiDaoDuanXHJ(nHandleStart,true,nArrayHandleStartXHJ);
			if(nArrayHandleStartXHJ.GetCount()>0)
				nxhj_start=nArrayHandleStartXHJ[0];
			this->GetGuiDaoDuanXHJ(nHandleTjEnd,true,nArrayHandleEndXHJ);
			if(nArrayHandleEndXHJ.GetCount()>0)
				nxhj_end=nArrayHandleEndXHJ[0];
			m_mysys.GetXdata(nHandleStart,_T("GUIDAONAME"),str_GdStartname);
			GetTongGuoPathGuiDaoAndXHJ(str_GdStartname,nxhj_start,nxhj_end,nHandleStart,nHandleStart,nHandleTjEnd,nlastdaocha,vec_path,vec_daocha,vec_xhj,sXGuDaoName,nArrayHandleLineTJ,vec_cxgd,i_CntTJ,true);
			this->num=this->num-i_CntTJ*2;
			for(int j=0;j<i_CntTJ;j++)
			{
				oper_excel.WriteDatatoExcel(1,this->num,6,(j+1));
				this->num=this->num+2;
			}
		}
		
		//this->num=this->num+2;
		int i_excel_row_current4=this->num;
		//写列车方面
		oper_excel.SetColumnCombandCells(1,i_excel_row_current,2,i_excel_row_current4-i_excel_row_current);
		//CString str_T=_T("北京方面");
		//str_T+=_T(" ");
		str_fx=_T("北京方面 ")+str_fx;

		oper_excel.WriteDatatoExcel(1,i_excel_row_current,2,str_fx);
	}
				//输出上行通过进路
// 				acutPrintf(_T("\n开始上行通过进路\n"));
// 				for(int k=0;k<nAarryHandleXJC.GetCount();k++)
// 				{
// 					long nHandleEnd=nAarryHandleXJC[k];
// 					long nHandleStart=nAarryHandleSJC[k];
// 					CString Gd_name1;
// 					m_mysys.GetXdata(nHandleStart,_T("GUIDAONAME"),Gd_name1);
// 					CString Gd_name2;
// 					m_mysys.GetXdata(nHandleEnd,_T("GUIDAONAME"),Gd_name2);
// 					if(Gd_name1==_T("4DG")&&Gd_name2==_T("1AG"))
// 					{
// 						Gd_name1=Gd_name1;
// 					}
// 					vector<CString> path;
// 					vector<CString>daocha;
// 					vector<CString>xhj;
// 					CStringArray sSJCGuiDaoName;
// 					CLongArray  nArrayHandle;
// 					CStringArray DaochaNum;
// 					long LastDaocha=0;
// 					long nHandleStartXHJ=0;
// 					long nHandleEndXHJ=0;
// 					CLongArray nArrayStartXHJ;
// 					CLongArray nArrayEndXHJ;
// 					bool btoward=false;
// 					//获取终止轨道信号机
// 					this->GetGuiDaoDuanXHJ(nHandleStart,btoward,nArrayStartXHJ);
// 					if(nArrayStartXHJ.GetCount()>0)
// 						nHandleStartXHJ=nArrayStartXHJ[0];
// 					btoward=false;
// 					this->GetGuiDaoDuanXHJ(nHandleEnd,btoward,nArrayEndXHJ);
// 					if(nArrayEndXHJ.GetCount()>0)
// 						nHandleEndXHJ =nArrayEndXHJ[0];
// 					//GetPathGuiDao4(nHandleStart,nHandleEnd,path,daocha,DaochaNum,sXJCGuiDaoName,nArrayHandle,false);
// 					//GetPathGuiDao3(nHandleStart,nHandleEnd,LastDaocha,path,daocha,sXJCGuiDaoName,nArrayHandle,false);
// 					GetLieChePathGuiDaoAndXHJ(nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sGuDaoName,nArrayHandle,false);
// 				}
	// 	输出所有上行接车进路
	acutPrintf(_T("\n开始输出上行接车进路\n"));
	for(int i=0;i<nAarryHandleSJC.GetCount();i++)
	{
		long nHandleStart=nAarryHandleSJC[i];
		CString Start_Gd_Name;
		m_mysys.GetXdata(nHandleStart,_T("GUIDAONAME"),Start_Gd_Name);
		int i_excel_row_current=this->num;
		CString str_fx;
		for(int k=0;k<nAarryHandleGuDaoS.GetCount();k++)
		{
			long nHandleEnd=nAarryHandleGuDaoS[k];
			vector<CString> path;
			vector<CString>daocha;
			vector<CString>xhj;
			vector<CString>vec_cx_gd;
			CLongArray  nArrayHandle;
			CStringArray DaochaNum;
			long LastDaocha=0;
			long nHandleStartXHJ=0;
			long nHandleEndXHJ=0;
			CLongArray nArrayStartXHJ;
			CLongArray nArrayEndXHJ;
			bool btoward=false;
			//获取终止轨道信号机
			this->GetGuiDaoDuanXHJ(nHandleStart,false,nArrayStartXHJ);
			if(nArrayStartXHJ.GetCount()>0)
				nHandleStartXHJ=nArrayStartXHJ[0];
			GetEntName(nHandleStartXHJ,str_fx);
			long nHandleLineXHJEnd=nAarryHandleGuDaoX[k];
			this->GetGuiDaoDuanXHJ(nHandleLineXHJEnd,false,nArrayEndXHJ);
			if(nArrayEndXHJ.GetCount()>0)
				nHandleEndXHJ =nArrayEndXHJ[0];
			//GetPathGuiDao4(nHandleStart,nHandleEnd,path,daocha,DaochaNum,sXJCGuiDaoName,nArrayHandle,false);
			//GetPathGuiDao(nHandleStart,nHandleEnd,path,sGuDaoName,nArrayHandle,false);
			//GetPathGuiDao3(nHandleStart,nHandleEnd,LastDaocha,path,daocha,sXJCGuiDaoName,nArrayHandle,false);
			int iJL_Cnt_temp=0;
			GetJieChePathGuiDaoAndXHJ(Start_Gd_Name,nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sSGuDaoName,nArrayHandle,vec_cx_gd,iJL_Cnt_temp,false);
			//int iJL_Cnt_temp=0;
			//GetPathGuiDao4(nHandleStart,nHandleEnd,path,daocha,DaochaNum,sXJCGuiDaoName,nArrayHandle,false);
			//GetPathGuiDao3(nHandleStart,nHandleEnd,LastDaocha,path,daocha,sXJCGuiDaoName,nArrayHandle,false);
			//GetLieChePathGuiDaoAndXHJ(Start_Gd_Name,nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sXGuDaoName,nArrayHandle,iJL_Cnt_temp,false);
			//写确定运行方向道岔
			if(iJL_Cnt_temp>=2)
			{
				int row_num=this->num-iJL_Cnt_temp;
				CString strDaocha1;
				CString strDaocha2;
				CString str_diff1;
				CString str_diff2;
				vector<CString>vec_str_Daocha1;
				vector<CString>vec_str_Daocha2;
				oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
				TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
				oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
				TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
				FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
				oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
				oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
			}
			this->num=this->num-iJL_Cnt_temp;
			for(int j=0;j<iJL_Cnt_temp;j++)
			{
				oper_excel.WriteDatatoExcel(1,this->num,6,(j+1));
				this->num++;
			}
		}
		int i_excel_row_current2=this->num;
		oper_excel.SetColumnCombandCells(1,i_excel_row_current,3,i_excel_row_current2-i_excel_row_current);
		oper_excel.WriteDatatoExcel(1,i_excel_row_current,3,_T("接车"));
		//发车
		long nHandleEnd=nAarryHandleSJJC[i];
		for(int k=0;k<nAarryHandleGuDaoS.GetCount();k++)
		{
			//long nHandleEnd=nAarryHandleSJJC[i];
			long nHandleStart=nAarryHandleGuDaoS[k];
			CString Start_Gd_Name;
			m_mysys.GetXdata(nHandleStart,_T("GUIDAONAME"),Start_Gd_Name);
			vector<CString> path;
			vector<CString>daocha;
			vector<CString>xhj;
			vector<CString>vec_cx_gd;
			CLongArray  nArrayHandle;
			//GetPathGuiDao(nHandleStart,nHandleEnd,path,sSJCGuiDaoName,nArrayHandle,true);
			CStringArray DaochaNum;
			long LastDaocha=0;
			long nHandleStartXHJ=0;
			long nHandleEndXHJ=0;
			CLongArray nArrayStartXHJ;
			CLongArray nArrayEndXHJ;
			bool btoward=true;
			//获取终止轨道信号机
			long nHandlineXHJStart=nAarryHandleGuDaoX[k];
			this->GetGuiDaoDuanXHJ(nHandlineXHJStart,false,nArrayStartXHJ);
			if(nArrayStartXHJ.GetCount()>0)
				nHandleStartXHJ=nArrayStartXHJ[0];
			this->GetGuiDaoDuanXHJ(nHandleEnd,true,nArrayEndXHJ);
			if(nArrayEndXHJ.GetCount()>0)
				nHandleEndXHJ =nArrayEndXHJ[0];
			int iJL_Cnt_temp=0;
			//GetPathGuiDao4(nHandleStart,nHandleEnd,path,daocha,DaochaNum,sXJCGuiDaoName,nArrayHandle,true);
			//GetPathGuiDao3(nHandleStart,nHandleEnd,LastDaocha,path,daocha,sXJCGuiDaoName,nArrayHandle,true);
			GetFaChePathGuiDaoAndXHJ(Start_Gd_Name,nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sSGuDaoName,nArrayHandle,vec_cx_gd,iJL_Cnt_temp,true);
			//GetLieChePathGuiDaoAndXHJ(Start_Gd_Name,nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sSGuDaoName,nArrayHandle,iJL_Cnt_temp,false);
			if(iJL_Cnt_temp>=2)
			{
				int row_num=this->num-iJL_Cnt_temp;
				CString strDaocha1;
				CString strDaocha2;
				CString str_diff1;
				CString str_diff2;
				vector<CString>vec_str_Daocha1;
				vector<CString>vec_str_Daocha2;
				oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
				TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
				oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
				TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
				FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
				oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
				oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
			}
			this->num=this->num-iJL_Cnt_temp;
			for(int j=0;j<iJL_Cnt_temp;j++)
			{
				oper_excel.WriteDatatoExcel(1,this->num,6,(j+1));
				this->num++;
			}
		}
		int i_excel_row_current3=this->num;
		oper_excel.SetColumnCombandCells(1,i_excel_row_current2,3,i_excel_row_current3-i_excel_row_current2);
		oper_excel.WriteDatatoExcel(1,i_excel_row_current2,3,_T("发车"));
		//通过进路，且为正线通过
		for(int i_col=3;i_col<=17;i_col++)
		{
			oper_excel.SetColumnCombandCells(1,this->num,i_col,2);
			if(i_col==3)
			{
				oper_excel.WriteDatatoExcel(1,this->num,3,_T("通过"));
			}
		}
		//查询通过进路
		nHandleStart=nAarryHandleSJC[i];
		for(int m=0;m<nAarryHandleXJJC.GetCount();m++)
		{
			long nHandleTjEnd=nAarryHandleXJJC[m];
			long nxhj_start=0;
			long nxhj_end=0;
			long nlastdaocha=0;
			vector<CString>vec_xhj;
			vector<CString>vec_path;
			vector<CString>vec_daocha;
			vector<CString>vec_cxgd;
			CLongArray nArrayHandleLineTJ;
			CString str_GdStartname;
			CString str_xhj_start;
			CString str_xhj_end;
			int i_CntTJ=0;
			CLongArray nArrayHandleStartXHJ;
			CLongArray nArrayHandleEndXHJ;
			this->GetGuiDaoDuanXHJ(nHandleStart,false,nArrayHandleStartXHJ);
			if(nArrayHandleStartXHJ.GetCount()>0)
				nxhj_start=nArrayHandleStartXHJ[0];
			this->GetGuiDaoDuanXHJ(nHandleTjEnd,false,nArrayHandleEndXHJ);
			if(nArrayHandleEndXHJ.GetCount()>0)
				nxhj_end=nArrayHandleEndXHJ[0];
			m_mysys.GetXdata(nHandleStart,_T("GUIDAONAME"),str_GdStartname);
			GetTongGuoPathGuiDaoAndXHJ(str_GdStartname,nxhj_start,nxhj_end,nHandleStart,nHandleStart,nHandleTjEnd,nlastdaocha,vec_path,vec_daocha,vec_xhj,sXGuDaoName,nArrayHandleLineTJ,vec_cxgd,i_CntTJ,false);
			this->num=this->num-i_CntTJ*2;
			for(int j=0;j<i_CntTJ;j++)
			{
				oper_excel.WriteDatatoExcel(1,this->num,6,(j+1));
				this->num=this->num+2;
			}
		}

		//this->num=this->num+2;
		int i_excel_row_current4=this->num;
		//写方面
		//CString str_T=_T("广州方面");
		//str_T+=_T(" ");
		str_fx=_T("广州方面 ")+str_fx;
		oper_excel.SetColumnCombandCells(1,i_excel_row_current,2,i_excel_row_current4-i_excel_row_current);
		oper_excel.WriteDatatoExcel(1,i_excel_row_current,2,str_fx);

	}
	//列车进路结束
	int i_excel_row_lieche=this->num;
	oper_excel.SetColumnCombandCells(1,3,1,i_excel_row_lieche-3);
	oper_excel.WriteDatatoExcel(1,3,1,_T("列车进路"));
// 				acutPrintf(_T("\n开始输出下行通过进路\n"));
// 				for(int k=0;k<nAarryHandleXJC.GetCount();k++)
// 				{
// 					long nHandleStart=nAarryHandleXJC[k];
// 					long nHandleEnd=nAarryHandleSJC[k];
// 					vector<CString> path;
// 					vector<CString>daocha;
// 					vector<CString>xhj;
// 					CStringArray sSJCGuiDaoName;
// 					CLongArray  nArrayHandle;
// 					CStringArray DaochaNum;
// 					long LastDaocha=0;
// 					long nHandleStartXHJ=0;
// 					long nHandleEndXHJ=0;
// 					CLongArray nArrayStartXHJ;
// 					CLongArray nArrayEndXHJ;
// 					bool btoward=true;
// 					//获取终止轨道信号机
// 					this->GetGuiDaoDuanXHJ(nHandleStart,btoward,nArrayStartXHJ);
// 					if(nArrayStartXHJ.GetCount()>0)
// 						nHandleStartXHJ=nArrayStartXHJ[0];
// 					btoward=true;
// 					this->GetGuiDaoDuanXHJ(nHandleEnd,btoward,nArrayEndXHJ);
// 					if(nArrayEndXHJ.GetCount()>0)
// 						nHandleEndXHJ =nArrayEndXHJ[0];
// 					//GetPathGuiDao4(nHandleStart,nHandleEnd,path,daocha,DaochaNum,sXJCGuiDaoName,nArrayHandle,true);
// 					//GetPathGuiDao3(nHandleStart,nHandleEnd,LastDaocha,path,daocha,sXJCGuiDaoName,nArrayHandle,true);
// 					GetLieChePathGuiDaoAndXHJ(nHandleStartXHJ,nHandleEndXHJ,nHandleStart,nHandleEnd,LastDaocha,path,daocha,xhj,sGuDaoName,nArrayHandle,true);
// 				}
	//获取所有的调车信号机
	CLongArray nArrayHandle_DCXHJ;
	CStringArray JieJinQuDuan;
	JieJinQuDuan.Copy(sSJCGuiDaoName);
	//JieJinQuDuan.Copy(sXJCGuiDaoName);
	for(int i=0;i<sXJCGuiDaoName.GetCount();i++)
	{
		//acutPrintf(_T("\t接近区段:%s"),JieJinQuDuan.GetAt(i));
		JieJinQuDuan.Add(sXJCGuiDaoName.GetAt(i));
	}
	CString name_DCXHJ=_T("XHJ_DC");
	int iRet3 =GetSomeBlocks(name_DCXHJ,nArrayHandle_DCXHJ);
	int iNum_DC=nArrayHandle_DCXHJ.GetCount();
	acutPrintf(_T("\n 一共有%d个调车信号机"),iNum_DC);
	CStringArray strArrayDcName;
	for(int i=0;i<iNum_DC;i++)
	{
		long nHandleDCXHJ=nArrayHandle_DCXHJ[i];
		CString name;
		CString fangxiang;
		CStringArray strNextDC;
		CLongArray nArrayHandleNext;
		long nHandleStartLine=0;
		bool bforward=true;
		int iTo=1;
		GetBlockToward(nHandleDCXHJ,iTo);
		if(iTo==1)
		{
			fangxiang=_T("右");
		}
		else
		{
			fangxiang=_T("左");
		}
		//long LastDaocha=0;
		GetEntName(nHandleDCXHJ,name);
		acutPrintf(_T("\n信号机%s:%s"),name,fangxiang);
		strArrayDcName.Add(name);
	}
	//排序后输出
	TCHAR del_char=_T('D');
	long  t31=GetTickCount();
	CBlkUtility::SortStringArray(strArrayDcName,del_char);
	long t32=GetTickCount();
	CString str32;
	str32.Format("SortArray time:%d ms",t32-t31);
	acutPrintf(_T("\n %s"),str32);
	long nHandleStartLine=0;
	bool bforward=true;
	//分上下行咽喉
	CStringArray strArrayOdd;
	CStringArray strArrayEven;
	CBlkUtility::SortandDistinguishStringArray(strArrayDcName,strArrayOdd,strArrayEven,del_char);
	acutPrintf(_T("\n下行调车信号机："));
	for(int i=0;i<strArrayOdd.GetCount();i++)
	{
		acutPrintf(_T(" %s\t"),strArrayOdd.GetAt(i));
	}
	acutPrintf(_T("\n上行调车信号机："));
	for(int i=0;i<strArrayEven.GetCount();i++)
	{
		acutPrintf(_T(" %s\t"),strArrayEven.GetAt(i));
	}
	//输出下行咽喉调车进路
	for(int i=0;i<strArrayOdd.GetCount();i++)
	{
		CStringArray strNextDC;
		CLongArray nArrayHandleNext;
		//long LastDaocha=0;
		long nHandleDCXHJ=0;
		CString temp=strArrayOdd.GetAt(i);
		GetHandleByName(temp,nHandleDCXHJ);
		if(GetXHJ_YouCe_GdLine(nHandleDCXHJ,nHandleStartLine,bforward)!=0)
		{
			nHandleStartLine=0;
		}
		//获取调车信号机的调车终端
		this->GetNextDCXHJByDCXHJ(nHandleDCXHJ,sXGuDaoName,JieJinQuDuan,nArrayHandleNext,strNextDC);
		CString xhj;
		GetEntName(nHandleDCXHJ,xhj);
		acutPrintf(_T("\n调车始端：%s"),xhj);
		acutPrintf("\n调车终端：\n");
 		for(int k=0;k<strNextDC.GetCount();k++)
		 {
			
			CString strGuiname;
			m_mysys.GetXdata(nArrayHandleNext.GetAt(k),_T("GUIDAONAME"),strGuiname);
			acutPrintf(_T("\t%s--%s"),strNextDC.GetAt(k),strGuiname);
		
		}
		 int i_row_diaochecurrent=this->num;
		if(nHandleStartLine!=0)
		{
			//输出调车进路
			for(int i=0;i<nArrayHandleNext.GetCount();i++)
			{
				long nHandEndXHJ=0;
				long nHandleEndLine=nArrayHandleNext.GetAt(i);
				CString Gd_name;
				m_mysys.GetXdata(nHandleEndLine,_T("GUIDAONAME"),Gd_name);
				acutPrintf(_T("\t 终端:%s"),Gd_name);
				long LastDaocha=0;
				long nHandleEndXHJ=0;
				vector<CString>vec_path;
				vector<CString>vec_daocha;
				vector<CString>vec_xhj;
				vector<CString>vec_cx_gd;
				CLongArray nArrayHandleNextLine;
				CString str_xhj_start;
				CString str_xhj_end=strNextDC.GetAt(i);
				GetEntName(nHandleDCXHJ,str_xhj_start);
				if(str_xhj_start==_T("D11")&&str_xhj_end==_T("D23"))
				{
					str_xhj_end=str_xhj_end;
				}
				int iDCJL_Cnt=0;
				GetDiaoChePathGuiDaoAndXHJ2(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleStartLine,nHandleEndLine,LastDaocha,JieJinQuDuan,vec_path,vec_daocha,vec_xhj,sSGuDaoName,nArrayHandleNextLine,vec_cx_gd,iDCJL_Cnt,bforward);	
				//GetDiaoChePathGuiDaoAndXHJ(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleEndLine,LastDaocha,vec_path,vec_daocha,vec_xhj,sXGuDaoName,nArrayHandleNextLine,iDCJL_Cnt,bforward);
				if(iDCJL_Cnt>=2)
				{
					int row_num=this->num-iDCJL_Cnt;
					CString strDaocha1;
					CString strDaocha2;
					CString str_diff1;
					CString str_diff2;
					vector<CString>vec_str_Daocha1;
					vector<CString>vec_str_Daocha2;
					oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
					TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
					oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
					TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
					FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
					oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
					oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
				}
			    this->num=this->num-iDCJL_Cnt;
				//int i_row_diaocheCurrent=this->num-iDCJL_Cnt;
				for(int i=0;i<iDCJL_Cnt;i++)
				{
					oper_excel.WriteDatatoExcel(1,this->num,6,(i+1));
					this->num++;
				}
			}
			int i_row_diaochecurrent2=this->num;
			oper_excel.SetColumnCombandCells(1,i_row_diaochecurrent,3,i_row_diaochecurrent2-i_row_diaochecurrent);
			oper_excel.WriteDatatoExcel(1,i_row_diaochecurrent,3,xhj);
		}
	}	
	//获取下行出站信号机作调车信号机
	CLongArray nArrayXXHJ;
	for(int i=0;i<nAarryHandleGuDaoS.GetCount();i++)
	{
		long nHandleXgd=nAarryHandleGuDaoS.GetAt(i);
		CLongArray nArrayHandleXHJ;
		long zhixhj=0;
		long xiangxhj=0;
		CString strgdname;
		GetGuiDaoDuanXHJ(nHandleXgd,true,nArrayHandleXHJ);
		m_mysys.GetXdata(nHandleXgd,_T("GUIDAONAME"),strgdname);
		//GetGuiDaoDuanXHJ(true,)
		if(nArrayHandleXHJ.GetCount()>0)
			nArrayXXHJ.Add(nArrayHandleXHJ[0]);
		CString strname;
		GetEntName(nArrayHandleXHJ[0],strname);
		acutPrintf(_T("下行出站信号机:%s  %s\t"),strgdname,strname);
	}
	for(int i=0;i<nArrayXXHJ.GetCount();i++)
	{
		CStringArray strNextDC;
		CLongArray nArrayHandleNext;
		long  nHandleStartLine=0;
		long nHandleDCXHJ=nArrayXXHJ.GetAt(i);
		if(GetXHJ_YouCe_GdLine(nHandleDCXHJ,nHandleStartLine,bforward)!=0)
		{
			nHandleStartLine=0;
		}
		CString xhj;
		GetEntName(nHandleDCXHJ,xhj);
		acutPrintf(_T("\n调车始端：%s"),xhj);
		this->GetNextDCXHJByDCXHJ(nHandleDCXHJ,sSGuDaoName,JieJinQuDuan,nArrayHandleNext,strNextDC);
		int i_row_diaochecurrent=this->num;
		if(nHandleStartLine!=0)
		{
			//输出调车进路
			for(int i=0;i<nArrayHandleNext.GetCount();i++)
			{
				long nHandleEndLine=nArrayHandleNext.GetAt(i);
				long LastDaocha=0;
				long nHandleEndXHJ=0;
				vector<CString>vec_path;
				vector<CString>vec_daocha;
				vector<CString>vec_xhj;
				vector<CString>vec_cx_gd;
				CLongArray nArrayHandleNextLine;
				CString str_xhj_start;
				CString str_xhj_end=strNextDC.GetAt(i);
				GetEntName(nHandleDCXHJ,str_xhj_start);
				str_xhj_start+=_T("D");
				int iDCJL_Cnt=0;
				//GetDiaoChePathGuiDaoAndXHJ(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleEndLine,LastDaocha,vec_path,vec_daocha,vec_xhj,sGuDaoName,nArrayHandleNextLine,bforward);	
				GetDiaoChePathGuiDaoAndXHJ2(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleStartLine,nHandleEndLine,LastDaocha,JieJinQuDuan,vec_path,vec_daocha,vec_xhj,sSGuDaoName,nArrayHandleNextLine,vec_cx_gd,iDCJL_Cnt,bforward);
				if(iDCJL_Cnt>=2)
				{
					int row_num=this->num-iDCJL_Cnt;
					CString strDaocha1;
					CString strDaocha2;
					CString str_diff1;
					CString str_diff2;
					vector<CString>vec_str_Daocha1;
					vector<CString>vec_str_Daocha2;
					oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
					TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
					oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
					TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
					FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
					oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
					oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
				}
				this->num=this->num-iDCJL_Cnt;
				//int i_row_diaocheCurrent=this->num-iDCJL_Cnt;
				for(int i=0;i<iDCJL_Cnt;i++)
				{
					oper_excel.WriteDatatoExcel(1,this->num,6,(i+1));
					this->num++;
				}
				int i_row_diaochecurrent2=this->num;
				oper_excel.SetColumnCombandCells(1,i_row_diaochecurrent,3,i_row_diaochecurrent2-i_row_diaochecurrent);
				oper_excel.WriteDatatoExcel(1,i_row_diaochecurrent,3,str_xhj_start);
			}

		}

	}
	//输出上行咽喉调车进路
	for(int i=0;i<strArrayEven.GetCount();i++)
	{
		CStringArray strNextDC;
		CLongArray nArrayHandleNext;
		//int i_row_current=this->num;
		//long LastDaocha=0;
		long nHandleDCXHJ=0;
		CString temp=strArrayEven.GetAt(i);
		if(temp==_T("D20"))
		{
			temp=temp;
		}
		GetHandleByName(temp,nHandleDCXHJ);
		if(GetXHJ_YouCe_GdLine(nHandleDCXHJ,nHandleStartLine,bforward)!=0)
		{
			nHandleStartLine=0;
		}
		this->GetNextDCXHJByDCXHJ(nHandleDCXHJ,sSGuDaoName,JieJinQuDuan,nArrayHandleNext,strNextDC);
		CString xhj;
		GetEntName(nHandleDCXHJ,xhj);
		acutPrintf(_T("\n调车始端：%s"),xhj);
		acutPrintf("\n调车终端：\n");
		for(int k=0;k<strNextDC.GetCount();k++)
		{
			//acutPrintf(_T("\t%s"),strNextDC.GetAt(k));
			CString strGuiname;
			m_mysys.GetXdata(nArrayHandleNext.GetAt(k),_T("GUIDAONAME"),strGuiname);
			acutPrintf(_T("\t%s--%s"),strNextDC.GetAt(k),strGuiname);
		}
		int i_row_diaochecurrent=this->num;
		if(nHandleStartLine!=0)
		{
			//输出调车进路
			for(int i=0;i<nArrayHandleNext.GetCount();i++)
			{
				long nHandleEndLine=nArrayHandleNext.GetAt(i);
// 				if(nHandEndTem!=0)
// 					nHandleEndLine=nHandEndTem;
				//long nHandleEndLine=nArrayHandleNext.GetAt(i);
				CString Gd_name;
				m_mysys.GetXdata(nHandleEndLine,_T("GUIDAONAME"),Gd_name);
				long LastDaocha=0;
				long nHandleEndXHJ=0;
				vector<CString>vec_path;
				vector<CString>vec_daocha;
				vector<CString>vec_xhj;
				vector<CString>vec_cx_gd;
				CLongArray nArrayHandleNextLine;
				CString str_xhj_start;
				CString str_xhj_end=strNextDC.GetAt(i);
				GetEntName(nHandleDCXHJ,str_xhj_start);
				int iDCJL_Cnt=0;
				GetDiaoChePathGuiDaoAndXHJ2(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleStartLine,nHandleEndLine,LastDaocha,JieJinQuDuan,vec_path,vec_daocha,vec_xhj,sSGuDaoName,nArrayHandleNextLine,vec_cx_gd,iDCJL_Cnt,bforward);
				//GetDiaoChePathGuiDaoAndXHJ2(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleStartLine,nHandleEndLine,LastDaocha,JieJinQuDuan,vec_path,vec_daocha,vec_xhj,sSGuDaoName,nArrayHandleNextLine,vec_cx_gd,iDCJL_Cnt,bforward);	
				if(iDCJL_Cnt>=2)
				{
					int row_num=this->num-iDCJL_Cnt;
					CString strDaocha1;
					CString strDaocha2;
					CString str_diff1;
					CString str_diff2;
					vector<CString>vec_str_Daocha1;
					vector<CString>vec_str_Daocha2;
					oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
					TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
					oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
					TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
					FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
					oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
					oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
				}
				this->num=this->num-iDCJL_Cnt;
				for(int i=0;i<iDCJL_Cnt;i++)
				{
					oper_excel.WriteDatatoExcel(1,this->num,6,(i+1));
					this->num++;
				}
			}
			int i_row_diaochecurrent2=this->num;
			oper_excel.SetColumnCombandCells(1,i_row_diaochecurrent,3,i_row_diaochecurrent2-i_row_diaochecurrent);
			oper_excel.WriteDatatoExcel(1,i_row_diaochecurrent,3,xhj);
		}
	}	
// 	出站信号机兼调车信号机作为调车始端
	//获取上行出站信号机兼做调车信号机
	CLongArray nArraySXHJ;
	for(int i=0;i<nAarryHandleGuDaoX.GetCount();i++)
	{
		long nHandleXgd=nAarryHandleGuDaoX.GetAt(i);
		CLongArray nArrayHandleXHJ;
		long zhixhj=0;
		long xiangxhj=0;
		CString strgdname;
		GetGuiDaoDuanXHJ(nHandleXgd,false,nArrayHandleXHJ);
		m_mysys.GetXdata(nHandleXgd,_T("GUIDAONAME"),strgdname);
		//GetGuiDaoDuanXHJ(true,)
		if(nArrayHandleXHJ.GetCount()>0)
			nArraySXHJ.Add(nArrayHandleXHJ[0]);
		CString strname;
		GetEntName(nArrayHandleXHJ[0],strname);
		acutPrintf(_T("下行出站信号机:%s  %s\t"),strgdname,strname);
	}
    for(int i=0;i<nArraySXHJ.GetCount();i++)
    {
		CStringArray strNextDC;
		CLongArray nArrayHandleNext;
		long  nHandleStartLine=0;
		long nHandleDCXHJ=nArraySXHJ.GetAt(i);
		if(GetXHJ_YouCe_GdLine(nHandleDCXHJ,nHandleStartLine,bforward)!=0)
		{
   			nHandleStartLine=0;
		}
		CString xhj;
		GetEntName(nHandleDCXHJ,xhj);
		acutPrintf(_T("\n调车始端：%s"),xhj);
		this->GetNextDCXHJByDCXHJ(nHandleDCXHJ,sSGuDaoName,JieJinQuDuan,nArrayHandleNext,strNextDC);
		int i_row_diaochecurrent=this->num;
		if(nHandleStartLine!=0)
		{
   			//输出调车进路
   			for(int i=0;i<nArrayHandleNext.GetCount();i++)
   			{
   				long nHandleEndLine=nArrayHandleNext.GetAt(i);
   				long LastDaocha=0;
   				long nHandleEndXHJ=0;
   				vector<CString>vec_path;
   				vector<CString>vec_daocha;
   				vector<CString>vec_xhj;
				vector<CString>vec_cx_gd;
   				CLongArray nArrayHandleNextLine;
   				CString str_xhj_start;
   				CString str_xhj_end=strNextDC.GetAt(i);
   				GetEntName(nHandleDCXHJ,str_xhj_start);
   				str_xhj_start+=_T("D");
				int iDCJL_Cnt=0;
   				//GetDiaoChePathGuiDaoAndXHJ(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleEndLine,LastDaocha,vec_path,vec_daocha,vec_xhj,sGuDaoName,nArrayHandleNextLine,bforward);	
				GetDiaoChePathGuiDaoAndXHJ2(str_xhj_start,str_xhj_end,nHandleStartLine,nHandleStartLine,nHandleEndLine,LastDaocha,JieJinQuDuan,vec_path,vec_daocha,vec_xhj,sSGuDaoName,nArrayHandleNextLine,vec_cx_gd,iDCJL_Cnt,bforward);
				if(iDCJL_Cnt>=2)
				{
					int row_num=this->num-iDCJL_Cnt;
					CString strDaocha1;
					CString strDaocha2;
					CString str_diff1;
					CString str_diff2;
					vector<CString>vec_str_Daocha1;
					vector<CString>vec_str_Daocha2;
					oper_excel.ReadDatafromExcel(1,row_num,12,strDaocha1);
					TranslateCStringtoVector(strDaocha1,vec_str_Daocha1);
					oper_excel.ReadDatafromExcel(1,row_num+1,12,strDaocha2);
					TranslateCStringtoVector(strDaocha2,vec_str_Daocha2);
					FindFirstDiffString(vec_str_Daocha1,vec_str_Daocha2,str_diff1,str_diff2);
					oper_excel.WriteDatatoExcel(1,row_num,8,str_diff1);
					oper_excel.WriteDatatoExcel(1,row_num+1,8,str_diff2);
				}
				this->num=this->num-iDCJL_Cnt;
				//int i_row_diaocheCurrent=this->num-iDCJL_Cnt;
				for(int i=0;i<iDCJL_Cnt;i++)
				{
					oper_excel.WriteDatatoExcel(1,this->num,6,(i+1));
					this->num++;
				}
				int i_row_diaochecurrent2=this->num;
				oper_excel.SetColumnCombandCells(1,i_row_diaochecurrent,3,i_row_diaochecurrent2-i_row_diaochecurrent);
				oper_excel.WriteDatatoExcel(1,i_row_diaochecurrent,3,str_xhj_start);
   			}

		} 	
    }
	int i_row_diaochecurrent3=this->num;
	oper_excel.SetColumnCombandCells(1,i_excel_row_lieche,1,i_row_diaochecurrent3-i_excel_row_lieche);
	oper_excel.WriteDatatoExcel(1,i_excel_row_lieche,1,_T("调车进路"));
	oper_excel.SetColumnCombandCells(1,i_excel_row_lieche,2,i_row_diaochecurrent3-i_excel_row_lieche);
	oper_excel.WriteDatatoExcel(1,i_excel_row_lieche,2,_T("由"));
	oper_excel.SaveExcel();
	oper_excel.RealseExcel();
	CTime  time_end=CTime::GetCurrentTime();
	 //CTime time_take=time_end-time_beg;
     str_Time=time_end.Format("%Y-%m-%d %H:%M:%S");
	acutPrintf(_T("\n程序结束时间%s"),str_Time);
}
long CZnSxt::GetDuXianMinDaoCha( long nHandleDc_One,long  nHandleDc_Another )
{
	try
	{
		//if(nHandleDc_Another!=GetAnotherDuXianDaoCha())
		if(nHandleDc_One==0||nHandleDc_Another==0)
		{
			return 0;
		}
		long nHandle=0;
		if(GetAnotherDuXianDaoCha(nHandleDc_One,nHandle)==TRUE)
		{
			//是渡线道岔
			CADORecordset cSet(&m_AdoDb) ;
			CString strSql ;
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc_One) ;
			//long nHandle_fw=0;
			CString name_one;
			//取道岔反位线
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),name_one);
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc_Another) ;
			//long nHandle_fw=0;
			CString name_another;
			//取道岔反位线
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),name_another);
			int iDCNum1 = _ttoi(name_one.GetString()) ;
			int iDcNum2=_ttoi(name_another.GetString());
			return iDCNum1<iDcNum2?nHandleDc_One:nHandleDc_Another;
		}
		else
		{
			return 0;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}
	return 0;

}
long CZnSxt::GetDuXianMaxDaoCha( long nHandleDc_One,long  nHandleDc_Another )
{
	try
	{
		//if(nHandleDc_Another!=GetAnotherDuXianDaoCha())
		if(nHandleDc_One==0||nHandleDc_Another==0)
		{
			return 0;
		}
		long nHandle=0;
		if(GetAnotherDuXianDaoCha(nHandleDc_One,nHandle)==TRUE)
		{
			//是渡线道岔
			CADORecordset cSet(&m_AdoDb) ;
			CString strSql ;
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc_One) ;
			//long nHandle_fw=0;
			CString name_one;
			//取道岔反位线
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),name_one);
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc_Another) ;
			//long nHandle_fw=0;
			CString name_another;
			//取道岔反位线
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),name_another);
			int iDCNum1 = _ttoi(name_one.GetString()) ;
			int iDcNum2=_ttoi(name_another.GetString());
			return iDCNum1>iDcNum2?nHandleDc_One:nHandleDc_Another;
		}
		else
		{
			return 0;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}
	return 0;

}


BOOL CZnSxt::GetAnotherDuXianDaoCha( long nHandleDc_One,long & nHandleDc_Another )
{
	try
	{

		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc_One) ;
		long nHandle_fw=0;
		//取道岔反位线
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw);
		if(nHandle_fw==0)
		{
			nHandleDc_Another =0;
			return FALSE;
		}
		//向左或者向右找一后继
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandle_fw) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandle_fw) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		//int nHandleEndConJyj = (bForword?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		long nHandleNextLine_left =0;
		long nHandleNextLine_right=0;
		long linetype1=-1;
		long linetype2=-1;
		if(nHandleLeftJyj!=0)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleLeftJyj) ;
			//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"), nHandleNextLine_left);
			strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleNextLine_left) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), linetype1) ;
		}
		if(nHandleRightJyj!=0)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleRightJyj) ;
			//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"), nHandleNextLine_right);
			strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleNextLine_right) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), linetype2) ;
		}
		//判断后继是否有一条为渡线
		if(nHandleNextLine_left==0&&nHandleNextLine_right==0)
		{
			nHandleDc_Another =0;
			return FALSE;
		}
		if(linetype1==1)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine_left) ;
			//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			long nHandle_DC1=0;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandle_DC1);
			if(nHandle_DC1!=0)
			{
				nHandleDc_Another =nHandle_DC1;
				return TRUE;	
			}
		}
		if(linetype2==1)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleNextLine_right) ;
			//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			long nHandle_DC2=0;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandle_DC2);	
			if(nHandle_DC2!=0)
			{
				nHandleDc_Another =nHandle_DC2;
				return TRUE;	
			}
		}
		nHandleDc_Another=0;
		return FALSE;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}
	return FALSE;
}
//由一条渡线的两个道岔，如果交叉渡线，则返回另一条渡线的另外两个道岔
BOOL CZnSxt::GetJiaoChaDuXianAnotherDaoChas( long nHandleDc_One,long nHandleDc_Another,long &nHandleDc_Min,long &nHandleDc_Max )
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		//输入的两个道岔必须是渡线
		long nHandleDc_One2=0;
		if(GetAnotherDuXianDaoCha(nHandleDc_One,nHandleDc_One2)==TRUE)
		{
			if(nHandleDc_Another==nHandleDc_One2)
			{//输入为渡线
				long nHandleline1=0;
				long nHandleline2=0;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc_One) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"),nHandleline1) ;
				strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDc_Another) ;
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"),nHandleline2) ;
				//找online1上的其他道岔是否为渡线道岔
				CLongArray nArrayHandleDC;
				CLongArray nArrayHandleXHJ;
				CLongArray nArrayHandleLineCur;
				CLongArray nArrayHandleLineType;
				int  iNumDC=0;
				this->GetGuiDaoDaoChaOrderByXAsc(nHandleline1,nArrayHandleDC,nArrayHandleLineCur,nArrayHandleLineType);
				//this->GetGuiDaoDaoChaOrderByXAsc()
				iNumDC =nArrayHandleDC.GetCount();
				CLongArray nArrayHandleDC2;
				CLongArray nArrayHandleXHJ2;
				CLongArray nArrayHandleLineCur2;
				CLongArray nArrayHandleLineType2;
				int iNumDC2=0;
				this->GetGuiDaoDaoChaOrderByXAsc(nHandleline2, nArrayHandleDC2,nArrayHandleLineCur2,nArrayHandleLineType2);
				iNumDC2 =nArrayHandleDC2.GetCount();
				if(iNumDC2<2||iNumDC<2)
				{
					return FALSE;
				}
				for(int i=0;i<iNumDC;i++)
				{
					long nHandleDC =nArrayHandleDC[i];
					if(nHandleDC!=nHandleDc_One)
					{
						//是否是渡线
						long nHandleDC_A=0;
						if(this->GetAnotherDuXianDaoCha(nHandleDC,nHandleDC_A)==TRUE)
						{
							//是渡线道岔，并且另一道岔位于line2。此时的两个轨道区段共同组成两条渡线，则很可能为交叉渡线
							if(CBlkUtility::FindLongInArray(nArrayHandleDC2,nHandleDC_A)!=-1)
							{
								//是否还需要加额外条件来区分交叉渡线
								nHandleDc_Min =this->GetDuXianMinDaoCha(nHandleDC,nHandleDC_A);
								nHandleDc_Max =this->GetDuXianMaxDaoCha(nHandleDC,nHandleDC_A);
								return TRUE;
							}
						}
					}
				}

			}
			else
			{
				return FALSE;
			}

		}
		else
		{
			return FALSE;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLine"));
	}
	return FALSE;
}
BOOL CZnSxt::GetDaidongDaochas1( long nHandleDC,long &nHandleDc_DdMin,long &nHandleDc_DdMax )
{
	long t1=GetTickCount();
	long nHandleDc_DdMinT=0;
	long nHandleDc_DdMaxT=0;
	if(GetDaidongDaochas(nHandleDC,nHandleDc_DdMinT,nHandleDc_DdMaxT)==TRUE)
	{
		nHandleDc_DdMin =nHandleDc_DdMinT;
		nHandleDc_DdMax=nHandleDc_DdMaxT;
		long t2=GetTickCount();
		CString str;
		str.Format("GetDaidongDaochas1 time:%d ms",t2-t1);
		//acutPrintf(_T("\n %s"),str);
		return TRUE;
	}
	long nHandleDC_Ano=0;
	if(GetAnotherDuXianDaoCha(nHandleDC,nHandleDC_Ano)==TRUE)
	{
		if(GetDaidongDaochas(nHandleDC_Ano,nHandleDc_DdMinT,nHandleDc_DdMaxT)==TRUE)
		{
			nHandleDc_DdMin =nHandleDc_DdMinT;
			nHandleDc_DdMax=nHandleDc_DdMaxT;
			long t2=GetTickCount();
			CString str;
			str.Format("GetDaidongDaochas1 time:%d ms",t2-t1);
			//acutPrintf(_T("\n %s"),str);
			return true;
		}
	}
	return FALSE;
}
//某道岔反位时，需要将某道岔带至定位时，函数返回TRUE,带动道岔以DdMin和DdMax带回
BOOL CZnSxt::GetDaidongDaochas( long nHandleDC,long &nHandleDc_DdMin,long &nHandleDc_DdMax )
{
	try
	{
		//获取道岔所在定位线
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
		//long nHandle_fw=0;
		long nHandle_dw=0;
		long nHandle_fw=0;
		long iStart1=-1;
		nHandleDc_DdMin=0;
		nHandleDc_DdMax=0;
		//取道岔定位线
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"),nHandle_dw);
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"),nHandle_fw);
		m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),iStart1) ;
		if(nHandle_dw==0||nHandle_fw==0)
		{
			return FALSE;
		}
		//获取定位线道岔个数，并以X坐标升序排列
		//CLongArray nArrayHandleXHJ;
		CLongArray nArrayHandleDC;
		CLongArray nArrayHandleLineType;
		CLongArray nArrayHandleLineCur;
		//this->GetGuiDaoDaoChaOrderByXAsc(nHandle_dw,nArrayHandleDC,nArrayHandleLineCur,nArrayHandleLineType);
		this->GetOnLineDaoChaOrderByXAsc(nHandle_dw,nArrayHandleDC);
		int iNum_DC=0;
		iNum_DC =nArrayHandleDC.GetCount();
		//acutPrintf(_T("\n 轨道上包含 %d个道岔"),iNum_DC);
		if(iNum_DC<2)
		{
			return FALSE;
		}
		//判断道岔是否位于轨道最顶端
		int index=0;
		index=CBlkUtility::FindLongInArray(nArrayHandleDC,nHandleDC);
		//acutPrintf(_T("\n 道岔位置；%d"),index);
		if(index==-1)
		{
			return FALSE;
		}
		//向右推进时,有多条后继
		CLongArray nArrayHandleNext;
		long nHandleLineEnd=0;
		CStringArray sGuodaocha;
		CStringArray sGudao;
		//bool foword=true;
		if(iStart1==0)
		{
			//向右推进
			this->FindNextLine(nHandle_dw,nHandleLineEnd,nArrayHandleNext,true);
			int iNum_Next=nArrayHandleNext.GetCount();
			//acutPrintf(_T("\n 往右轨道上包含 %d个后继"),iNum_Next);
			if(iNum_Next>=3)
			{
				for(int i=index+1;i<iNum_DC;i++)
				{
					long nHandle_DXDC=nArrayHandleDC[i];
					//带动道岔一定是渡线道岔
					long nHandle_DXAno=0;
					if(this->GetAnotherDuXianDaoCha(nHandle_DXDC,nHandle_DXAno)==TRUE)
					{
						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_DXDC) ;
						long nHandle_fw=0;
						int IsStart=-1;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						if(IsStart==0&&nHandle_fw!=0)
						{
							nHandleDc_DdMin=this->GetDuXianMinDaoCha(nHandle_DXDC,nHandle_DXAno);
							nHandleDc_DdMax=this->GetDuXianMaxDaoCha(nHandle_DXDC,nHandle_DXAno);
							return TRUE;
						}	
					}
				}
			}	
		}
		else
		{
			//向左推进
			CLongArray nArrayHandleNext2;
			long nHandleLineEnd2=0;
			//bool foword2=false;
			this->FindNextLine(nHandle_dw,nHandleLineEnd2,nArrayHandleNext2,false);
			int iNum_Next2=nArrayHandleNext2.GetCount();
			//acutPrintf(_T("\n 往左轨道上包含 %d个后继"),iNum_Next2);
			if(iNum_Next2>=3)
			{
				for(int i=index-1;i>=0;i--)
				{
					long nHandle_DXDC=nArrayHandleDC[i];
					//long nHandle_DXMin=0;
					long nHandle_DXAno=0;
					//未考虑交叉渡线存在的情况
					if(this->GetAnotherDuXianDaoCha(nHandle_DXDC,nHandle_DXAno)==TRUE)
					{

						strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle_DXDC) ;
						long nHandle_fw=0;
						int IsStart=-1;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"),nHandle_fw) ;
						m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
						if(IsStart>0&&nHandle_fw!=0)
						{
							nHandleDc_DdMin=this->GetDuXianMinDaoCha(nHandle_DXDC,nHandle_DXAno);
							nHandleDc_DdMax=this->GetDuXianMaxDaoCha(nHandle_DXDC,nHandle_DXAno);
							return TRUE;
						}		
					}
				}
			}

		}	
		return FALSE;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetdaidongDaoChas"));
	}
	return FALSE;
}
// 循环查询轨道线连接的信号机及道岔，并按照块的基点x坐标升序排列
void CZnSxt::GetGuiDaoInfoOrderByXAsc(UINT nLineHandle, CLongArray& nArrayHandleXHJ, CLongArray& nArrayHandleDC, CLongArray& nArrayLineDoneCur, CLongArray& nArrayLineCurType)
{
	long t1=GetTickCount();
	nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nLineHandle) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		nArrayLineCurType.Add(nLineType) ;

		CLongArray nArrayHandleXHJTmp, nArrayHandleDCTmp ;
		strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d or sxt_ent_conline_right=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x asc"), nLineHandle, nLineHandle, nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleXHJTmp) ;
		nArrayHandleXHJ.Append(nArrayHandleXHJTmp) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type>-1 and sxt_ent_type<100 order by sxt_ent_x asc"), nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDCTmp) ;
		nArrayHandleDC.Append(nArrayHandleDCTmp) ;
		for (int i=0; i<nArrayHandleDCTmp.GetCount(); i++)
		{
			UINT nHandleDc = nArrayHandleDCTmp.GetAt(i) ;
			strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
			long nHandleFwLine = 0 ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
			if (nHandleFwLine>0)
			{
				this->GetGuiDaoInfoOrderByXAsc(nHandleFwLine, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			}
		}
		long t2=GetTickCount();
		CString str;
		str.Format("GetGuiDaoInfoOrderByX time:%d ms",t2-t1);
		acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGuiDaoInfoOrderByX"));
	}
}
// 循环查询轨道线连接的信号机及道岔，并按照块的基点x坐标升序排列
void CZnSxt::GetGuiDaoDaoChaOrderByXAsc(UINT nLineHandle, CLongArray& nArrayHandleDC, CLongArray& nArrayLineDoneCur, CLongArray& nArrayLineCurType)
{
	long t1=GetTickCount();
	nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nLineHandle) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		nArrayLineCurType.Add(nLineType) ;
		CLongArray nArrayHandleDCTmp ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type>-1 and sxt_ent_type<100 order by sxt_ent_x asc"), nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDCTmp) ;
		nArrayHandleDC.Append(nArrayHandleDCTmp) ;
		for (int i=0; i<nArrayHandleDCTmp.GetCount(); i++)
		{
			UINT nHandleDc = nArrayHandleDCTmp.GetAt(i) ;
			strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
			long nHandleFwLine = 0 ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
			if (nHandleFwLine>0)
			{
				//this->GetGuiDaoInfo(nHandleFwLine, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
				this->GetGuiDaoDaoChaOrderByXAsc(nHandleFwLine,nArrayHandleDC,nArrayLineDoneCur,nArrayLineCurType);
			}
		}
		long t2=GetTickCount();
		CString str;
		str.Format("GetGuiDaoDaoChaOrderByXAsc time:%d ms",t2-t1);
		//acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGuiDaoInfoOrderByX"));
	}
}
// 循环查询轨道线连接的信号机及道岔，并按照块的基点x坐标升序排列
void CZnSxt::GetOnLineDaoChaOrderByXAsc(UINT nLineHandle, CLongArray& nArrayHandleDC)
{
	long t1=GetTickCount();
	//nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
// 		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nLineHandle) ;
// 		long nLineType = 0 ;
		//m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		//nArrayLineCurType.Add(nLineType) ;
		CLongArray nArrayHandleDCTmp ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type>-1 and sxt_ent_type<100 order by sxt_ent_x asc"), nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDCTmp) ;
		nArrayHandleDC.Append(nArrayHandleDCTmp) ;
		long t2=GetTickCount();
		CString str;
		str.Format("GetOnLineDaoChaOrderByXAsc time:%d ms",t2-t1);
		//acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGuiDaoInfoOrderByX"));
	}
}
//向右推进时，获取轨道左侧信号机，向左推进时，获取轨道右侧信号机
void CZnSxt::GetGuiDaoDuanXHJ(UINT nLineHandle, bool bToward,CLongArray& nArrayXHJ)
{
	//nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		long t1=GetTickCount();
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		CLongArray nArrayHandleXHJTmp;
		if(nLineHandle==0)
		{
			return;
		}
		if(bToward==false)
		{
			//获取轨道右端信号机
			strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d ) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x asc"), nLineHandle) ;
		}
		else
		{
			//获取轨道左端信号机
			strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_right=%d ) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x desc"), nLineHandle) ;
		}
		//strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d or sxt_ent_conline_right=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x asc"), nLineHandle, nLineHandle,nLineHandle ) ;
		/*		strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x asc"), nLineHandle, nLineHandle ) ;*/
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleXHJTmp) ;
		nArrayXHJ.Append(nArrayHandleXHJTmp);
		long t2=GetTickCount();
		CString str;
		str.Format("GetGuiDaoDuanXHJ time:%d ms",t2-t1);
		//acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGuiDaoInfoOrderByX"));
	}
}
// 查询轨道区段右侧的信号机，并按照块的基点x坐标升序排列
//conline_left=true时，轨道区段的右侧的信号机
void CZnSxt::GetGuiDaoDuanXHJ(bool bforward,UINT nLineHandle, long& ZhiXHJ,long& XiangXHJ)
{
	//nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		long t1=GetTickCount();
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		CLongArray nArrayHandleXHJTmp;
		//注意：nLineHandle一定不能取0，否则可能查到错误的结果
		if(nLineHandle==0)
		{
			ZhiXHJ=0;
			XiangXHJ=0;
			return;
		}
		if(bforward==false)
		{
			//轨道右端信号机
			strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x asc"), nLineHandle,nLineHandle ) ;

		}
		else
		{
			strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_right=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x desc"),nLineHandle,nLineHandle ) ;
		}
		/*		strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x asc"), nLineHandle, nLineHandle ) ;*/
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleXHJTmp) ;
		for(int i=0;i<nArrayHandleXHJTmp.GetCount();i++)
		{
			if(bforward==true)
			{
				int toward=-1;
				if(GetBlockToward(nArrayHandleXHJTmp[i],toward)==TRUE)
				{
					if(toward==1)
					{
						ZhiXHJ=nArrayHandleXHJTmp[i];
						//找到同向信号机即可结束
						break;
					}
					else if(toward==2)
					{
						XiangXHJ=nArrayHandleXHJTmp[i];
					}
				}

			}
			else
			{
				//轨道左端信号机
				int toward=-1;
				if(GetBlockToward(nArrayHandleXHJTmp[i],toward)==TRUE)
				{
					if(toward==2)
					{
						ZhiXHJ=nArrayHandleXHJTmp[i]; 
						break;
					}
					else if(toward==1)
					{
						XiangXHJ=nArrayHandleXHJTmp[i];
					}
				}
			}
		}
		long t2=GetTickCount();
		CString str;
		str.Format("GetGuiDaoDuanXHJzhiAndXiang time:%d ms",t2-t1);
		//acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGuiDaoInfoOrderByX"));
	}
}
// 循环查询轨道线连接的信号机及道岔，并按照块的基点x坐标升序排列
void CZnSxt::GetGuiDaoInfoOrderByXDesc(UINT nLineHandle, CLongArray& nArrayHandleXHJ, CLongArray& nArrayHandleDC, CLongArray& nArrayLineDoneCur, CLongArray& nArrayLineCurType)
{
	nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nLineHandle) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		nArrayLineCurType.Add(nLineType) ;

		CLongArray nArrayHandleXHJTmp, nArrayHandleDCTmp ;
		strSql.Format(_T("select * from sxt_ent where (sxt_ent_conline_left=%d or sxt_ent_conline_right=%d or sxt_ent_online_handle=%d) and sxt_ent_type>99 and sxt_ent_type<200 order by sxt_ent_x desc"), nLineHandle, nLineHandle, nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleXHJTmp) ;
		nArrayHandleXHJ.Append(nArrayHandleXHJTmp) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type>-1 and sxt_ent_type<100 order by sxt_ent_x desc"), nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDCTmp) ;
		nArrayHandleDC.Append(nArrayHandleDCTmp) ;

		for (int i=0; i<nArrayHandleDCTmp.GetCount(); i++)
		{
			UINT nHandleDc = nArrayHandleDCTmp.GetAt(i) ;
			strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
			long nHandleFwLine = 0 ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
			if (nHandleFwLine>0)
			{
				this->GetGuiDaoInfoOrderByXDesc(nHandleFwLine, nArrayHandleXHJ, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			}
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetGuiDaoInfoOrderByX"));
	}
}
// 循环查询轨道线连接的信号机及道岔，并按照块的基点x坐标升序排列
void CZnSxt::GetGuiDaoChaOrderByXDesc(UINT nLineHandle, CLongArray& nArrayHandleDC, CLongArray& nArrayLineDoneCur, CLongArray& nArrayLineCurType)
{
	nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		long t1=GetTickCount();
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nLineHandle) ;
		long nLineType = 0 ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
		nArrayLineCurType.Add(nLineType) ;

		CLongArray nArrayHandleDCTmp ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type>-1 and sxt_ent_type<100 order by sxt_ent_x desc"), nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDCTmp) ;
		nArrayHandleDC.Append(nArrayHandleDCTmp) ;
		for (int i=0; i<nArrayHandleDCTmp.GetCount(); i++)
		{
			UINT nHandleDc = nArrayHandleDCTmp.GetAt(i) ;
			strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
			long nHandleFwLine = 0 ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
			if (nHandleFwLine>0)
			{
				this->GetGuiDaoChaOrderByXDesc(nHandleFwLine, nArrayHandleDC, nArrayLineDoneCur, nArrayLineCurType) ;
			}
		}
		long t2=GetTickCount();
		CString str;
		str.Format(_T("GetGuiDaoChaOrderByXDesc time:%d ms"),t2-t1);
		//acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!inGetGuiDaoChaOrderByXDesc"));
	}
}
// 循环查询轨道线连接的信号机及道岔，并按照块的基点x坐标升序排列
void CZnSxt::GetOnLineChaOrderByXDesc(UINT nLineHandle, CLongArray& nArrayHandleDC)
{
	//nArrayLineDoneCur.Add(nLineHandle) ;
	try
	{
		long t1=GetTickCount();
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		CLongArray nArrayHandleDCTmp ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_online_handle=%d and sxt_ent_type>-1 and sxt_ent_type<100 order by sxt_ent_x desc"), nLineHandle ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nArrayHandleDCTmp) ;
		nArrayHandleDC.Append(nArrayHandleDCTmp) ;
		long t2=GetTickCount();
		CString str;
		str.Format(_T("GetGuiDaoChaOrderByXDesc time:%d ms"),t2-t1);
		//acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!inGetGuiDaoChaOrderByXDesc"));
	}
}


void CZnSxt::PrintGuoDaocha( vector<CString>PathDaocha )
{
	int count =PathDaocha.size();
	CStringArray JiLuDaocha;
	acutPrintf(_T("\n经过："));
	for(int i=0;i<count;i++)
	{
		//获取道岔
		CString temp=PathDaocha[i];
		CString Ptemp=temp;
		//TCHAR a=_T('(');
		TCHAR a='(';
		TCHAR b=')';
		TCHAR c='{';
		TCHAR d='}';
		TCHAR e='[';
		TCHAR f=']';
		//对temp去掉_T("("),_T(")"),_T("{"),_T("}"),_T("["),_T("]")
		temp.Remove(a);
		temp.Remove(b);
		temp.Remove(c);
		temp.Remove(d);
		temp.Remove(e);
		temp.Remove(f);
		//acutPrintf(_T("\n temp=%s"),temp.GetString());
		CStringArray Daochas;
		CStringArray DaochasP;
		CBlkUtility::DivideString(temp,_T("，"),Daochas);
		CBlkUtility::DivideString(Ptemp,_T("，"),DaochasP);
		for(int k=0;k<Daochas.GetCount();k++)
		{
			if(CBlkUtility::FindStrInArray(JiLuDaocha,Daochas[k])==-1)
			{
				JiLuDaocha.Add(Daochas[k]);
				if(k!=Daochas.GetCount()-1)
				{
					if(DaochasP[k]!=_T(""))
					{
						acutPrintf(_T("%s \t"),DaochasP[k].GetString());
					}
				}
				else
				{
					if(DaochasP[k]!=_T(""))
					{
						acutPrintf(_T("%s \t"),DaochasP[k].GetString());
					}
				}
			}
		}
	}
}
void CZnSxt::TiquGuoDaocha( vector<CString>PathDaocha, vector<CString>& vec_Daocha)
{
	int count =PathDaocha.size();
	CStringArray JiLuDaocha;
	//acutPrintf(_T("\n经过："));
	for(int i=0;i<count;i++)
	{
		//获取道岔
		CString temp=PathDaocha[i];
		CString Ptemp=temp;
		//TCHAR a=_T('(');
		TCHAR a='(';
		TCHAR b=')';
		TCHAR c='{';
		TCHAR d='}';
		TCHAR e='[';
		TCHAR f=']';
		//对temp去掉_T("("),_T(")"),_T("{"),_T("}"),_T("["),_T("]")
		temp.Remove(a);
		temp.Remove(b);
		temp.Remove(c);
		temp.Remove(d);
		temp.Remove(e);
		temp.Remove(f);
		//acutPrintf(_T("\n temp=%s"),temp.GetString());
		CStringArray Daochas;
		CStringArray DaochasP;
		CBlkUtility::DivideString(temp,_T("，"),Daochas);
		CBlkUtility::DivideString(Ptemp,_T("，"),DaochasP);
		for(int k=0;k<Daochas.GetCount();k++)
		{
			if(CBlkUtility::FindStrInArray(JiLuDaocha,Daochas[k])==-1)
			{
				JiLuDaocha.Add(Daochas[k]);
				if((i==count-1)&&k==Daochas.GetCount()-1)
				{
					if(DaochasP[k]!=_T(""))
					{
						//acutPrintf(_T("%s \t"),DaochasP[k].GetString());
						CString str_tem=DaochasP[k];
						vec_Daocha.push_back(str_tem);
					}
				}
				else
				{
					if(DaochasP[k]!=_T(""))
					{
						//acutPrintf(_T("%s \t"),DaochasP[k].GetString());
						//vec_Daocha.push_back(DaochasP[k]+T("\t"));
						CString str_tem=DaochasP[k]+_T(",");
						vec_Daocha.push_back(str_tem);
					}
				}
			}
		}
	}
}
//主要功能：提取一条轨道上的道岔的第一个道岔
void CZnSxt::TiquFirstDaocha( CString strDaochas, CString &Daocha)
{
	//int count =PathDaocha.size();
	//获取道岔
	//CString temp=strDaochas;
	CString Ptemp=strDaochas;
	//acutPrintf(_T("\n temp=%s"),temp.GetString());
	CStringArray DaochasP;
	CBlkUtility::DivideString(Ptemp,_T(","),DaochasP);
	//int i_cnt=DaochasP.GetCount();
	for(int k=0;k<DaochasP.GetCount();k++)
	{
		Daocha=DaochasP[k];
		if(Daocha!=_T(""))
		{
			break;
		}
	}
}
//主要功能：提取一条轨道上的道岔的第一个道岔
void CZnSxt::TiquFirstDaocha2( CString strDaochas, CString &Daocha)
{
	//int count =PathDaocha.size();
	//获取道岔
	//CString temp=strDaochas;
	CString Ptemp=strDaochas;
	//acutPrintf(_T("\n temp=%s"),temp.GetString());
	CStringArray DaochasP;
	CBlkUtility::DivideString(Ptemp,_T("，"),DaochasP);
	//int i_cnt=DaochasP.GetCount();
	for(int k=0;k<DaochasP.GetCount();k++)
	{
		Daocha=DaochasP[k];
		if(Daocha!=_T(""))
		{
			break;
		}
	}
}
//主要功能：将String中按照"，"分割符号提取有效信息存入vector中
void CZnSxt::TranslateCStringtoVector( CString strDaocha, vector<CString> &vec_strData)
{
	CString Ptemp=strDaocha;
	CStringArray DaochasP;
	CBlkUtility::DivideString(Ptemp,_T(","),DaochasP);
	for(int k=0;k<DaochasP.GetCount();k++)
	{
		if(DaochasP.GetAt(k)!=_T(""))
			vec_strData.push_back(DaochasP.GetAt(k));
	}
}
void CZnSxt::TiquEffectiveData( vector<CString>& vec_SourceData, CStringArray& strArray_Data)
{
	int count =vec_SourceData.size();
	CStringArray JiLuDaocha;
	//acutPrintf(_T("\n经过："));
	for(int i=0;i<count;i++)
	{
		//获取道岔
		CString temp=vec_SourceData[i];
		CString Ptemp=temp;
		//TCHAR a=_T('(');
		TCHAR a='(';
		TCHAR b=')';
		TCHAR c='{';
		TCHAR d='}';
		TCHAR e='[';
		TCHAR f=']';
		//TCHAR g=',';
		//对temp去掉_T("("),_T(")"),_T("{"),_T("}"),_T("["),_T("]")
		temp.Remove(a);
		temp.Remove(b);
		temp.Remove(c);
		temp.Remove(d);
		temp.Remove(e);
		temp.Remove(f);
		//temp.Remove(g);
		//acutPrintf(_T("\n temp=%s"),temp.GetString());
		CStringArray Daochas;
		CStringArray DaochasP;
		CBlkUtility::DivideString(temp,_T("，"),Daochas);
		CBlkUtility::DivideString(Ptemp,_T("，"),DaochasP);
		for(int k=0;k<Daochas.GetCount();k++)
		{
			if(CBlkUtility::FindStrInArray(JiLuDaocha,Daochas[k])==-1)
			{
				JiLuDaocha.Add(Daochas[k]);
				if((i==count-1)&&k==Daochas.GetCount()-1)
				{
					if(DaochasP[k]!=_T(""))
					{
						//acutPrintf(_T("%s \t"),DaochasP[k].GetString());
						CString str_tem=DaochasP[k];
					    //vec_SourceData.push_back(str_tem);
						strArray_Data.Add(str_tem);
					}
				}
				else
				{
					if(DaochasP[k]!=_T(""))
					{
						//acutPrintf(_T("%s \t"),DaochasP[k].GetString());
						//vec_Daocha.push_back(DaochasP[k]+T("\t"));
						CString str_tem=DaochasP[k];
						strArray_Data.Add(str_tem);
						//vec_Daocha.push_back(str_tem);
					}
				}
			}
		}
	}
}

void CZnSxt::GetEntName( long nHandle,CString &Entname )
{
	try
	{
		if(nHandle==0)
		{
			return;
		}
		//long t1=GetTickCount();
		CString name;
		//CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		if(nHandle!=0)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),name) ;
		}
		Entname =name;
// 		long t2=GetTickCount();
// 		CString str;
// 		str.Format("GetEntName time:%d ms",t2-t1);
// 		acutPrintf(_T("\n%s"),str);
		return ;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetEntName"));
	}	
}
BOOL CZnSxt::GetBlockPosition_X( long nHandle,double &point_x )
{
	try
	{
		//CString name;
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		if(nHandle!=0)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_x"),point_x) ;
			return TRUE;
		}
		//Entname =name;
		return FALSE;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);       
		return FALSE;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetEntName"));
		return FALSE;
	}
	
}

void CZnSxt::FindNextDiaoCheXHJ( long nHandleDC_XHJ,CLongArray& nArrayHandleNext_DC_XHJ )
{
	//检查调车信号机是否在数据库，并求出信号机所在的轨道区段
	try
	{
		CString name;
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		long nHandleLineRight=0;
		long nHandleLineLeft=0;
		if(nHandleDC_XHJ!=0)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC_XHJ) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLineLeft) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLineRight) ;
		}
		//Entname =name;
		//获取调车信号机的朝向
		int toward=0;
		if(this->GetBlockToward(nHandleDC_XHJ,toward)==FALSE)
		{
			return;
		}
		long nHandleLineEnd=0;
		CLongArray nHandleNextLine;
		CStringArray Guodaocha;
		CStringArray Guodao;
		CLongArray  Zhi_XHJ;
		CLongArray Xiang_XHJ;
		bool forward;
		long lastdaocha=0;
		CLongArray ThisDaocha;
		if(toward==1)
		{
			//朝右
			forward=true;
			this->FindNextLine3(nHandleLineRight,nHandleLineEnd,Guodaocha,Guodao,lastdaocha,ThisDaocha,Zhi_XHJ,Xiang_XHJ,nHandleNextLine,forward);
			if(Zhi_XHJ.GetCount()==nHandleNextLine.GetCount())
			{
				nArrayHandleNext_DC_XHJ.Append(Zhi_XHJ);
			}
			else
			{
				for(int i=0;i<nHandleNextLine.GetCount();i++)
				{
					long zhi=0,xiang=0;
					this->GetGuiDaoDuanXHJ(true,nHandleNextLine[i],zhi,xiang);
					if(zhi!=0)
					{
						nArrayHandleNext_DC_XHJ.Add(zhi);
					}
				}

			}


		}
		else if(toward==2)
		{
			//朝左
			forward=false;
			this->FindNextLine3(nHandleLineLeft,nHandleLineEnd,Guodaocha,Guodao,lastdaocha,ThisDaocha,Zhi_XHJ,Xiang_XHJ,nHandleNextLine,forward);
			if(Zhi_XHJ.GetCount()==nHandleNextLine.GetCount())
			{
				nArrayHandleNext_DC_XHJ.Append(Zhi_XHJ);
			}
			else
			{
				for(int i=0;i<nHandleNextLine.GetCount();i++)
				{
					long zhi=0,xiang=0;
					this->GetGuiDaoDuanXHJ(true,nHandleNextLine[i],zhi,xiang);
					if(zhi!=0)
					{
						nArrayHandleNext_DC_XHJ.Add(zhi);
					}
				}

			}
		}

		return ;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextDiaoCheXHJ"));
	}	


}


int CZnSxt::WriteDataToExcel(int iNum_Sheet,int iNum_Row,int iNum_Column,vector<CString>vec_str)
{
	long t1=GetTickCount();
	_ApplicationPtr m_pExcel = NULL ;
	WorkbooksPtr pWorkBooks = NULL ;
	_WorkbookPtr pWorkBook = NULL ;
	SheetsPtr pWorksheets = NULL ; 
	RangePtr pRange = NULL ;
	_WorksheetPtr pSheet = NULL ;
	try
	{
		if (bFirst)
		{
			::AfxOleInit() ;
			bFirst = FALSE ;
		}
		HRESULT hr = m_pExcel.CreateInstance ( "Excel.Application" ) ;
		if(FAILED(hr))
		{
			AfxMessageBox( _T("初始化Excel失败,可能是没有安装Excel") ) ;
			//return FALSE ;
		}
		pWorkBooks = m_pExcel->GetWorkbooks() ;
		CString strXlsFileName=_T("C:\\辅助开发\\平面图联锁表生成1.xls");
		pWorkBook = pWorkBooks->Open( (_bstr_t)strXlsFileName ) ;
		VARIANT vt_index ;
		vt_index.vt = VT_I2 ;
		vt_index.iVal = iNum_Sheet;		
		pWorksheets  = pWorkBook->GetSheets() ;
		pSheet = pWorksheets ->GetItem( vt_index ) ;
		CString strCellContent;
		for(int i=0;i<vec_str.size();i++)
		{
			strCellContent+=vec_str[i];
		}
		CString strCellName ;
		CString strCellText ;
		CString strColName = CBlkUtility::GetExcelFieldName(iNum_Column) ;
		strCellName.Format(_T("%s%d"),strColName, iNum_Row) ;
		//acutPrintf(_T("\n提示信息：%s: %s"),strCellName,strCellContent);
		pRange = NULL ;
		pRange = pSheet->GetRange((_variant_t)strCellName, vtMissing) ;
		//pRange->PutNumberFormat((_variant_t)_T("@")) ;//20101110 modified
		acutPrintf(_T("\n%s"),strCellContent.GetString());
		//pRange->FormulaR1C1 = (_variant_t)strCellContent ;	
		pRange->PutFormula((_variant_t)strCellContent) ;//20101110 modified
		MSExcel::FontPtr pFont = pRange->GetFont();
		pFont->PutSize((_variant_t)((long)10)) ;
		pWorkBook->Save() ;
		///关闭打开的各个资源
		pWorkBooks->Close( ) ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;		
		//m_pExcel->Release() ;
		m_pExcel = NULL ;
		long t2=GetTickCount();
		CString str;
		str.Format("WriteDatatoExcel time:%d ms",t2-t1);
		acutPrintf(_T("\n%s"),str);
	}
	catch(_com_error &e)
	{
		//iFound = 0 ;
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);  
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;
		m_pExcel = NULL ;		
		acutPrintf(_T("\n提示信息2："));
	}
	catch(...)
	{	
		//iFound = 0 ;
		AfxMessageBox(_T("未知的错误!"));		
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;
		m_pExcel = NULL ;		
		acutPrintf(_T("\n提示信息3："));
	}	
	return 0;
}
// SheetsPtr CZnSxt::OpenExcel(CString name)
// {
// 	try
// 	{
// 		_ApplicationPtr m_pExcel = NULL ;
// 		WorkbooksPtr pWorkBooks = NULL ;
// 		_WorkbookPtr pWorkBook = NULL ;
// 		SheetsPtr pWorksheets = NULL ; 
// 		if (bFirst)
// 		{
// 			::AfxOleInit() ;
// 			bFirst = FALSE ;
// 		}
// 		HRESULT hr = m_pExcel.CreateInstance ( "Excel.Application" ) ;
// 		if(FAILED(hr))
// 		{
// 			AfxMessageBox( _T("初始化Excel失败,可能是没有安装Excel") ) ;
// 			return NULL ;
// 		}
// 		pWorkBooks = m_pExcel->GetWorkbooks() ;
// 		CString strXlsFileName=name;
// 		pWorkBook = pWorkBooks->Open( (_bstr_t)strXlsFileName ) ;
// 		pWorksheets  = pWorkBook->GetSheets() ;
// 		return pWorksheets;
//     }
// 	catch(_com_error &e)
// 	{
// 		//iFound = 0 ;
// 		CString sBuff = CBlkUtility::GetErrorDescription(e);
// 		AfxMessageBox(sBuff);  
// 		return NULL;
// 	}
// 	catch(...)
// 	{	
// 		//iFound = 0 ;
// 		AfxMessageBox(_T("未知的错误!"));			
// 		return NULL;
// 	}	
// 	return NULL;
// }
// CZnSxt::CloseExcel()
// {
// // 	pWorkBook->Save() ;
// // 	long t4=GetTickCount();
// // 	str.Format(_T("save time:%d ms"),t4-t3);
// // 	acutPrintf(_T("\n %s"),str);
// // 	///关闭打开的各个资源
// // 	pWorkBooks->Close( ) ;
// // 	pWorkBooks = NULL ;
// // 	m_pExcel->Quit() ;		
// // 	m_pExcel = NULL ;
// }
int CZnSxt::WriteDataToExcel(int iNum_Sheet,int iNum_Row,int iNum_Column,CString str_Data)
{
	long t1=GetTickCount();
	_ApplicationPtr m_pExcel = NULL ;
	 WorkbooksPtr pWorkBooks = NULL ;
	_WorkbookPtr pWorkBook = NULL ;
	SheetsPtr pWorksheets = NULL ; 
	RangePtr pRange = NULL ;
	_WorksheetPtr pSheet = NULL ;
	try
	{
		if (bFirst)
		{
			::AfxOleInit() ;
			bFirst = FALSE ;
		}
		HRESULT hr = m_pExcel.CreateInstance ( "Excel.Application" ) ;
		if(FAILED(hr))
		{
			AfxMessageBox( _T("初始化Excel失败,可能是没有安装Excel") ) ;
			//return FALSE ;
		}
		pWorkBooks = m_pExcel->GetWorkbooks() ;
		CString strXlsFileName=_T("C:\\辅助开发\\平面图联锁表生成1.xls");
		pWorkBook = pWorkBooks->Open( (_bstr_t)strXlsFileName ) ;
		VARIANT vt_index ;
		vt_index.vt = VT_I2 ;
		vt_index.iVal = iNum_Sheet;		
		pWorksheets  = pWorkBook->GetSheets() ;
		long t2=GetTickCount();
		CString str;
		str.Format(_T("GetSheets time:%d ms"),t2-t1);
		acutPrintf(_T("\n %s"),str);
		pSheet = pWorksheets ->GetItem( vt_index ) ;
		CString strCellContent=str_Data;
		CString strCellName ;
		CString strColName = CBlkUtility::GetExcelFieldName(iNum_Column) ;
		strCellName.Format(_T("%s%d"),strColName, iNum_Row) ;
		pRange = NULL ;
		pRange = pSheet->GetRange((_variant_t)strCellName, vtMissing) ;
		pRange->PutNumberFormat((_variant_t)_T("@")) ;//20101110 modified
		pRange->FormulaR1C1 = (_variant_t)strCellContent ;	
// 		pRange->PutNumberFormat((_variant_t)_T("@")) ;//20101110 modified
// 		//acutPrintf(_T("\n%s"),strCellContent.GetString());
// 		//pRange->FormulaR1C1 = (_variant_t)strCellContent ;	
// 		pRange->PutFormula((_variant_t)strCellContent) ;//20101110 modified
		MSExcel::FontPtr pFont = pRange->GetFont();
		pFont->PutSize((_variant_t)((long)10)) ;
		long t3=GetTickCount();
		str.Format(_T("write time %d ms"),t3-t2);
		acutPrintf(_T("\n %s"),str);
		pWorkBook->Save() ;
		long t4=GetTickCount();
		str.Format(_T("save time:%d ms"),t4-t3);
		acutPrintf(_T("\n %s"),str);
		///关闭打开的各个资源
		pWorkBooks->Close( ) ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;		
		m_pExcel = NULL ;
		long t5=GetTickCount();
		str.Format(_T("quit time:%d"),t5-t4);
		acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error &e)
	{
		//iFound = 0 ;
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);  
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;
		m_pExcel = NULL ;		
		acutPrintf(_T("\n提示信息2："));
	}
	catch(...)
	{	
		//iFound = 0 ;
		AfxMessageBox(_T("未知的错误!"));		
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;
		m_pExcel = NULL ;		
		acutPrintf(_T("\n提示信息3："));
	}	
	return 0;
}
int CZnSxt::WriteDataToExcel(int iNum_Sheet,int iNum_Row,int iNum_Column,int iData)
{
	long t1=GetTickCount();
	_ApplicationPtr m_pExcel = NULL ;
	WorkbooksPtr pWorkBooks = NULL ;
	_WorkbookPtr pWorkBook = NULL ;
	SheetsPtr pWorksheets = NULL ; 
	RangePtr pRange = NULL ;
	_WorksheetPtr pSheet = NULL ;
	try
	{
		if (bFirst)
		{
			::AfxOleInit() ;
			bFirst = FALSE ;
		}
		HRESULT hr = m_pExcel.CreateInstance ( "Excel.Application" ) ;
		if(FAILED(hr))
		{
			AfxMessageBox( _T("初始化Excel失败,可能是没有安装Excel") ) ;
			//return FALSE ;
		}
		pWorkBooks = m_pExcel->GetWorkbooks() ;
		CString strXlsFileName=_T("C:\\辅助开发\\平面图联锁表生成1.xls");
		pWorkBook = pWorkBooks->Open( (_bstr_t)strXlsFileName ) ;
		VARIANT vt_index ;
		vt_index.vt = VT_I2 ;
		vt_index.iVal = iNum_Sheet;		
		pWorksheets  = pWorkBook->GetSheets() ;
		pSheet = pWorksheets ->GetItem( vt_index ) ;
		int iCellContent=iData;
		CString strCellName ;
		CString strColName = CBlkUtility::GetExcelFieldName(iNum_Column) ;
		strCellName.Format(_T("%s%d"),strColName, iNum_Row) ;
		pRange = NULL ;
		pRange = pSheet->GetRange((_variant_t)strCellName, vtMissing) ;
		//acutPrintf(_T("\n%s"),strCellContent.GetString());
		//pRange->FormulaR1C1 = (_variant_t)strCellContent ;	
		pRange->PutFormula((_variant_t)iData) ;//20101110 modified
		MSExcel::FontPtr pFont = pRange->GetFont();
		pFont->PutSize((_variant_t)((long)10)) ;
		pWorkBook->Save() ;
		///关闭打开的各个资源
		pWorkBooks->Close( ) ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;		
		m_pExcel = NULL ;
		long t2=GetTickCount();
		CString str;
		str.Format(_T("writedatatoexcel time:%d ms"),t2-t1);
		acutPrintf(_T("\n %s"),str);
	}
	catch(_com_error &e)
	{
		//iFound = 0 ;
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);  
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;
		m_pExcel = NULL ;		
		acutPrintf(_T("\n提示信息2："));
	}
	catch(...)
	{	
		//iFound = 0 ;
		AfxMessageBox(_T("未知的错误!"));		
		pWorkBooks->Close() ;
		pWorkBooks = NULL ;
		m_pExcel->Quit() ;
		m_pExcel = NULL ;		
		acutPrintf(_T("\n提示信息3："));
	}	
	return 0;
}
//递归找到从某条轨道线开始的后继调车进路，该轨道线为调车起始信号机所在的轨道线
/*******************函数说明:FindNextDCByLine*****************************************************************************************************************/
/**********功能：通过一个调车起始信号机所在的轨道，返回调车基本进路的下一个调车信号机*******************************************************************/
/**********输入：nHandleLine,调车起始信号机所在的轨道线,轨道线在调车进路内侧;*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔，用于去掉轨道线上不属于进路内的信号机；**********************************************/
/*****************Gudao，股道名称；JieJinQuDuan，接近区段名称;bforward,寻找调车进路方向，其由调车起始信号机方向决定********************************/
/**********输出：nArrayHandleNextLine,下一个调车信号机所在的轨道区段; nArrayDCZhong,返回调车进路终端信号机*****************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
int CZnSxt::FindNextDCByLine( long nHandleLine,long LastDaocha,CStringArray& Gudao,CStringArray& JieJinQuDuan,CLongArray& nArrayHandleNextLine,CStringArray& nArrayDCZhong,bool bfoward )
{

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		if(nHandleLine==0)
		{
			return -1;		
		}
		//求后继轨道线
		CLongArray nArrayHandleNextLineTemp;
		long nHandleLineEnd=0;
		//long Lastdaocha=0;
        CLongArray nArrayHandleThisDaocha;
		CStringArray GuoDaocha;
		CStringArray GuoXHJ;
		//FindNextLine3(nHandleLine,nHandleLineEnd,GuoDaocha,Gudao,Lastdaocha,nArrayHandleThisDaocha,nArrayHandleNextLineTemp,bfoward);
	    DiaoCheFindNextLineAndXHJ( nHandleLine,nHandleLineEnd,GuoDaocha,Gudao,LastDaocha,nArrayHandleThisDaocha,GuoXHJ,nArrayHandleNextLineTemp,bfoward);
		for(int i=0;i<nArrayHandleNextLineTemp.GetCount();i++)
		{
			//向右推进时，寻找轨道左端信号机，向左推进时寻找轨道右端信号机
			bool iToward =bfoward;
			long zhixhj=0;
			long xiangxhj=0;
			long HandleDC=nArrayHandleThisDaocha[i];
			double pt_DC_x=0;
			double pt_xhj_x=0;
			CString strDCname;
			GetEntName(HandleDC,strDCname);
			GetGuiDaoDuanXHJ(iToward,nArrayHandleNextLineTemp[i],zhixhj,xiangxhj);
			if(bfoward==true)
			{
				if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
				{
					if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x>pt_DC_x)
						{
							zhixhj=zhixhj;
						}
						else
						{
							zhixhj=0;
						}

					}
					if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x>pt_DC_x)
						{
							xiangxhj=xiangxhj;
						}
						else
						{
							xiangxhj=0;
						}

					}
				}
				else
				{
						zhixhj=zhixhj;
						xiangxhj=xiangxhj;
				}
			}
			else
			{
				if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
				{
					if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x<pt_DC_x)
						{
							zhixhj=zhixhj;
						}
						else
						{
							zhixhj=0;
						}

					}
					if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x<pt_DC_x)
						{
							xiangxhj=xiangxhj;
						}
						else
						{
							xiangxhj=0;
						}

					}
				}
				else
				{
					zhixhj=zhixhj;
					xiangxhj=xiangxhj;
				}
			}
			if(zhixhj!=0)
			{
				nArrayHandleNextLine.Add(nArrayHandleNextLineTemp[i]);
				CString DCname;
				GetEntName(zhixhj,DCname);
				CString EntName;
				GetEntBlkNameByHandle(zhixhj,EntName);
				if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
				{
					DCname+=_T("D");
				}
				//DCname=_T("至")+DCname;
				nArrayDCZhong.Add(DCname);
			}
			else
			{
				//没有找到同方向调车信号机时
				//1.是否是尽头线
				//找尽头式绝缘节
				//long nHandleEnt=0;
				CString EntName;
				int type=200;
				if(bfoward==true)
				{
					//轨道右端信号机
					strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_left=%d and sxt_ent_type=%d"),nArrayHandleNextLineTemp[i],type) ;
				}
				else
				{
					strSql.Format(_T("select * from sxt_ent where sxt_ent_conline_right=%d and sxt_ent_type=%d"),nArrayHandleNextLineTemp[i],type);
				}
				//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"),nHandleEnt);
				m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_block"),EntName);
				CString GuidaoName;
				m_mysys.GetXdata(nArrayHandleNextLineTemp[i],_T("GUIDAONAME"),GuidaoName);
				//表示为尽头线
				if((xiangxhj!=0)&&(EntName.Left(6)==_T("JYJ_DT")))
				{
					CString DCname;
					GetEntName(xiangxhj,DCname);
					//DCname=_T("向")+DCname;
					//acutPrintf(_T("\n 尽头线信号机：%s"),DCname);
					CString EntName;
					GetEntBlkNameByHandle(xiangxhj,EntName);
				    if(EntName.Left(6)==_T("XHJ_LF")&&EntName.Left(6)==_T("XHJ_LJ"))
					{
						//向信号机为出站信号机时
						DCname+=_T("D");
						}
						nArrayDCZhong.Add(DCname);
						nArrayHandleNextLine.Add(nArrayHandleNextLineTemp[i]);			
				
				}
				else
				{
					//为股道线时
					CString GuidaoName;
					m_mysys.GetXdata(nArrayHandleNextLineTemp[i],_T("GUIDAONAME"),GuidaoName);
					if(CBlkUtility::FindStrInArray(Gudao,GuidaoName)!=-1)
					{
						//为股道时
						CString DCname;
						DCname=GuidaoName;
						nArrayDCZhong.Add(DCname);
						//acutPrintf(_T("\n 股道信号机：%s"),DCname);
						nArrayHandleNextLine.Add(nArrayHandleNextLineTemp[i]);
					}
					else if(CBlkUtility::FindStrInArray(JieJinQuDuan,GuidaoName)!=-1)
					{
						//为接近区段
						if(xiangxhj!=0)
						{
							CString DCname;
							GetEntName(xiangxhj,DCname);
							//acutPrintf(_T("\n 接近区段信号机：%s"),DCname);
							//DCname=_T("向")+DCname;
							CString EntName;
							GetEntBlkNameByHandle(xiangxhj,EntName);
							if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
							{
								DCname+=_T("D");
							}
							nArrayDCZhong.Add(DCname);
							nArrayHandleNextLine.Add(nArrayHandleNextLineTemp[i]);
						}
						else
						{
							FindNextDCByLine(nArrayHandleNextLineTemp[i],nArrayHandleThisDaocha[i],Gudao,JieJinQuDuan,nArrayHandleNextLine,nArrayDCZhong,bfoward);
						}

					}
					else
					{
						FindNextDCByLine(nArrayHandleNextLineTemp[i],nArrayHandleThisDaocha[i],Gudao,JieJinQuDuan,nArrayHandleNextLine,nArrayDCZhong,bfoward);

					}

				}

			}
		}
		return 1;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!inFindNextDCByLine"));
		return -2;
	}	
}
//递归找到从某条轨道线开始的后继列车信号机，该轨道线为调车终端或始端所在的轨道线
/*******************函数说明:FindNextLieCheXHJByLine*****************************************************************************************************************/
/**********功能：通过一个调车起始信号机所在的轨道，返回调车基本进路的下一个调车信号机*******************************************************************/
/**********输入：nHandleLine,调车起始信号机所在的轨道线,轨道线在调车进路内侧;*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔，用于去掉轨道线上不属于进路内的信号机；**********************************************/
/*****************Gudao，股道名称；bforward,寻找列车信号机的方向，**************************************************************************************************/
/**********输出：nArrayHandleNextLine,下一个列车信号机所在的轨道区段; nArraylieche,返回列车信号机名称*****************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
int CZnSxt::FindNextLieCheXHJByLine( long nHandleLine,long LastDaocha,CStringArray& Gudao,CLongArray& nArrayHandleNextLine,CStringArray& nArrayLieChe,bool bfoward )
{

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		if(nHandleLine==0)
		{
			return -1;		
		}
// 		//获取起始轨道背向信号机
// 		bool iToward=!bfoward;
// 		CLongArray nArrayPassXHJ;
// 		CString Gd_name;
// 		m_mysys.GetXdata(nHandleLine,_T("GUIDAONAME"),Gd_name);
// 		GetGuiDaoDuanXHJ(nHandleLine,iToward,nArrayPassXHJ);
// 		for(int i=0;i<nArrayPassXHJ.GetCount();i++)
// 		{
// 			//判断是否是列车信号机
// 			CString EntName;
// 			long nhandleXHJ=nArrayPassXHJ[i];
// 			CString blkname;
// 			GetEntName(nhandleXHJ,blkname);
// 			GetEntBlkNameByHandle(nhandleXHJ,EntName);
// 			if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
// 			{
// 			    CString blkname;
// 				GetEntName(nhandleXHJ,blkname);
//                 nArrayLieChe.Add(blkname);
// 				return 1;
// 			}
// 		}
		bool iToward=bfoward;
		long zhixhj=0;
		long xiangxhj=0;
		GetGuiDaoDuanXHJ(iToward,nHandleLine,zhixhj,xiangxhj);
		if(xiangxhj!=0)
		{
			CString blkname;
			CString EntName;
			GetEntBlkNameByHandle(xiangxhj,EntName);
			if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
			{
				CString blkname;
				GetEntName(xiangxhj,blkname);
				if(EntName.Left(6)==_T("XHJ_LF"))
				{
					//进站信号机无需加_T("L")
					blkname=blkname+_T("L");
				}
				nArrayLieChe.Add(blkname);
				return 1;
			}
		}
		//求后继轨道线
		CLongArray nArrayHandleNextLineTemp;
		long nHandleLineEnd=0;
		//long Lastdaocha=0;
		CLongArray nArrayHandleThisDaocha;
		CStringArray GuoDaocha;
		CStringArray GuoXHJ;
		//FindNextLine3(nHandleLine,nHandleLineEnd,GuoDaocha,Gudao,Lastdaocha,nArrayHandleThisDaocha,nArrayHandleNextLineTemp,bfoward);
		DiaoCheFindNextLineAndXHJ( nHandleLine,nHandleLineEnd,GuoDaocha,Gudao,LastDaocha,nArrayHandleThisDaocha,GuoXHJ,nArrayHandleNextLineTemp,bfoward);
		for(int i=0;i<nArrayHandleNextLineTemp.GetCount();i++)
		{
			//向右推进时，寻找轨道左端信号机，向左推进时寻找轨道右端信号机
			int iTag_Find=0;
			bool iToward=bfoward;
			long zhixhj=0;
			long xiangxhj=0;
			GetGuiDaoDuanXHJ(iToward,nHandleLine,zhixhj,xiangxhj);
		    if(xiangxhj!=0)
			{
				//判断是否是列车信号机
				CString EntName;
				long nhandleXHJ=xiangxhj;
				CString blkname;
				GetEntName(nhandleXHJ,blkname);
				long HandleDC=nArrayHandleThisDaocha[i];
				double pt_DC_x=0;
				double pt_xhj_x=0;
				if(bfoward==true)
				{
					if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
					{
						if((GetBlockPosition_X(nhandleXHJ,pt_xhj_x)==TRUE))
						{
							if(pt_xhj_x<pt_DC_x)
							{
							   nhandleXHJ=0;
							}
						}
					}
				}
				else
				{
					if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
					{
						if((GetBlockPosition_X(nhandleXHJ,pt_xhj_x)==TRUE))
						{
							if(pt_xhj_x>pt_DC_x)
							{
								nhandleXHJ=0;
							}
						}
					}
				}
				GetEntBlkNameByHandle(nhandleXHJ,EntName);
				if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
				{
					CString blkname;
					GetEntName(nhandleXHJ,blkname);
					if(EntName.Left(6)==_T("XHJ_LF"))
					{
						//进站信号机无需加_T("L")
						blkname=blkname+_T("L");
					}
					nArrayHandleNextLine.Add(nArrayHandleNextLineTemp[i]);
					nArrayLieChe.Add(blkname);
					iTag_Find =1;
					break;
				}
			}
			if(iTag_Find==0)
			{
				FindNextLieCheXHJByLine(nArrayHandleNextLineTemp.GetAt(i),nArrayHandleThisDaocha.GetAt(i),Gudao,nArrayHandleNextLine,nArrayLieChe,bfoward);
			}
		}
		return 1;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!inFindNextLieCheXHJByLine"));
		return -2;
	}	
}
//递归找到从某条轨道线开始的后继调车进路，该轨道线为调车起始信号机所在的轨道线
/*******************函数说明:FindNextDuiXiangDCByLine*****************************************************************************************************************/
/**********功能：通过一个调车起始信号机所在的轨道，返回调车基本进路的下一个调车信号机*******************************************************************/
/**********输入：nHandleLine,调车起始信号机所在的轨道线,轨道线在调车进路内侧;*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔，用于去掉轨道线上不属于进路内的信号机；**********************************************/
/*****************Gudao，股道名称；JieJinQuDuan，接近区段名称;bforward,寻找调车进路方向，其由调车起始信号机方向决定********************************/
/**********输出：nArrayHandleNextLine,下一个调车信号机所在的轨道区段; nArrayDCZhong,返回调车进路终端信号机*****************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
int CZnSxt::FindNextDuiXiangDCByLine( long nHandleLine,long LastDaocha,CStringArray& Gudao,CLongArray& nArrayHandleNextLine,CStringArray& nArrayDiDuiDC,bool bfoward )
{

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		if(nHandleLine==0)
		{
			return -1;		
		}
		static int callcnt=0;
		//获取起始轨道背向信号机
		bool iToward=bfoward;
		long zhixhj=0;
		long xiangxhj=0;
		double pt_DC_x=0;
		double pt_xhj_x=0;
		GetGuiDaoDuanXHJ(iToward,nHandleLine,zhixhj,xiangxhj);
		if(bfoward==true)
		{
			if(GetBlockPosition_X(LastDaocha,pt_DC_x)==TRUE)
			{
				if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x>pt_DC_x)
					{
						zhixhj=zhixhj;
					}
					else
					{
						zhixhj=0;
					}

				}
				if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x>pt_DC_x)
					{
						xiangxhj=xiangxhj;
					}
					else
					{
						xiangxhj=0;
					}

				}
			}
			else
			{
				zhixhj=zhixhj;
				xiangxhj=xiangxhj;
			}
		}
		else
		{
			if(GetBlockPosition_X(LastDaocha,pt_DC_x)==TRUE)
			{
				if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x<pt_DC_x)
					{
						zhixhj=zhixhj;
					}
					else
					{
						zhixhj=0;
					}

				}
				if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x<pt_DC_x)
					{
						xiangxhj=xiangxhj;
					}
					else
					{
						xiangxhj=0;
					}

				}
			}
			else
			{
				zhixhj=zhixhj;
				xiangxhj=xiangxhj;
			}
		}
		if(xiangxhj!=0)
		{
			nArrayHandleNextLine.Add(nHandleLine);
			CString DCname;
			GetEntName(xiangxhj,DCname);
			CString EntName;
			GetEntBlkNameByHandle(xiangxhj,EntName);
			if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
			{
				DCname+=_T("D");
			}
			return 1;
		}
// 		callcnt++;
		CString strGuidaoName;
		m_mysys.GetXdata(nHandleLine,_T("GUIDAONAME"),strGuidaoName);
// 		if(xiangxhj!=0)
// 		{
// 			//该敌对信号机在调车进路内已经包括，无需再次加入，可以直接返回
// 			return 1;
// 		}
		//求后继轨道线
		CLongArray nArrayHandleNextLineTemp;
		long nHandleLineEnd=0;
		//long Lastdaocha=0;
		CLongArray nArrayHandleThisDaocha;
		CStringArray GuoDaocha;
		CStringArray GuoXHJ;
		DiaoCheFindNextLineAndXHJ( nHandleLine,nHandleLineEnd,GuoDaocha,Gudao,LastDaocha,nArrayHandleThisDaocha,GuoXHJ,nArrayHandleNextLineTemp,bfoward);
		int cnt=nArrayHandleNextLineTemp.GetCount();
		CString strGuidaoName2;
		for(int i=0;i<cnt;i++)
		{
			m_mysys.GetXdata(nArrayHandleNextLineTemp.GetAt(i),_T("GUIDAONAME"),strGuidaoName2);
		}
		for(int i=0;i<nArrayHandleNextLineTemp.GetCount();i++)
		{
			//向右推进时，寻找轨道左端信号机，向左推进时寻找轨道右端信号机
			m_mysys.GetXdata(nArrayHandleNextLineTemp.GetAt(i),_T("GUIDAONAME"),strGuidaoName2);
			if(strGuidaoName2==_T("16DG"))
			{
				i=i;
			}
			if(i==0)
			{
				i=i;
			}
			if(i==1)
			{
				i=i;
			}
			if(i==2)
			{
				i=i;
			}
			if(i==3)
			{
				i=i;
			}
			iToward =bfoward;
			long zhixhj=0;
			long xiangxhj=0;
			long HandleDC=nArrayHandleThisDaocha[i];
			double pt_DC_x=0;
			double pt_xhj_x=0;
			CString strDCname;
			GetEntName(HandleDC,strDCname);
			GetGuiDaoDuanXHJ(iToward,nArrayHandleNextLineTemp[i],zhixhj,xiangxhj);
			if(bfoward==true)
			{
				if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
				{
					if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x>pt_DC_x)
						{
							zhixhj=zhixhj;
						}
						else
						{
							zhixhj=0;
						}

					}
					if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x>pt_DC_x)
						{
							xiangxhj=xiangxhj;
						}
						else
						{
							xiangxhj=0;
						}

					}
				}
				else
				{
					zhixhj=zhixhj;
					xiangxhj=xiangxhj;
				}
			}
			else
			{
				if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
				{
					if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x<pt_DC_x)
						{
							zhixhj=zhixhj;
						}
						else
						{
							zhixhj=0;
						}

					}
					if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x<pt_DC_x)
						{
							xiangxhj=xiangxhj;
						}
						else
						{
							xiangxhj=0;
						}

					}
				}
				else
				{
					zhixhj=zhixhj;
					xiangxhj=xiangxhj;
				}
			}
			if(xiangxhj!=0)
			{
				nArrayHandleNextLine.Add(nArrayHandleNextLineTemp[i]);
				CString DCname;
				GetEntName(xiangxhj,DCname);
				CString EntName;
				GetEntBlkNameByHandle(xiangxhj,EntName);
				if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
				{
					DCname+=_T("D");
				}
				//DCname+=_T("D");
				//DCname=_T("至")+DCname;
				nArrayDiDuiDC.Add(DCname);
			}
			else
			{			
				FindNextDuiXiangDCByLine(nArrayHandleNextLineTemp[i],nArrayHandleThisDaocha[i],Gudao,nArrayHandleNextLine,nArrayDiDuiDC,bfoward);
			}
		}
		return 1;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!inFindNextDCByLine"));
		return -2;
	}	
}
//递归找到从某条轨道线开始的后继调车进路，该轨道线为调车起始信号机所在的轨道线
/*******************函数说明:FindNextDuiXiangDCByLine2*****************************************************************************************************************/
/**********功能：通过一个调车起始信号机所在的轨道，返回调车基本进路的下一个调车信号机*******************************************************************/
/**********输入：nHandleLine,调车起始信号机所在的轨道线,轨道线在调车进路内侧;*******************************************************************************/
/******************LastDaocha,记录上一次访问到轨道线时走过的道岔，用于去掉轨道线上不属于进路内的信号机；**********************************************/
/*****************Gudao，股道名称；JieJinQuDuan，接近区段名称;bforward,寻找调车进路方向，其由调车起始信号机方向决定********************************/
/**********输出：nArrayHandleNextLine,下一个调车信号机所在的轨道区段; nArrayDCZhong,返回调车进路终端信号机*****************************************/
/****************strArrayDaocha，找到对应的调车信号机走过的道岔，用于作为敌对条件********************************************************************************************************************************************/
/**********************************2015-06-03 am 11:06 by luo*************************************************************************************************/
int CZnSxt::FindNextDuiXiangDCByLine2( long nHandleLine,long LastDaocha,CStringArray& Gudao,CLongArray& nArrayHandleNextLine,CStringArray& nArrayDiDuiDC,CStringArray &strArrayDaocha,bool bfoward )
{

	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		if(nHandleLine==0)
		{
			return -1;		
		}
		static int callcnt=0;
		//获取起始轨道背向信号机
		bool iToward=bfoward;
		long zhixhj=0;
		long xiangxhj=0;
		double pt_DC_x=0;
		double pt_xhj_x=0;
		GetGuiDaoDuanXHJ(iToward,nHandleLine,zhixhj,xiangxhj);
		if(bfoward==true)
		{
			if(GetBlockPosition_X(LastDaocha,pt_DC_x)==TRUE)
			{
				if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x>pt_DC_x)
					{
						zhixhj=zhixhj;
					}
					else
					{
						zhixhj=0;
					}

				}
				if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x>pt_DC_x)
					{
						xiangxhj=xiangxhj;
					}
					else
					{
						xiangxhj=0;
					}

				}
			}
			else
			{
				zhixhj=zhixhj;
				xiangxhj=xiangxhj;
			}
		}
		else
		{
			if(GetBlockPosition_X(LastDaocha,pt_DC_x)==TRUE)
			{
				if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x<pt_DC_x)
					{
						zhixhj=zhixhj;
					}
					else
					{
						zhixhj=0;
					}

				}
				if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
				{
					if(pt_xhj_x<pt_DC_x)
					{
						xiangxhj=xiangxhj;
					}
					else
					{
						xiangxhj=0;
					}

				}
			}
			else
			{
				zhixhj=zhixhj;
				xiangxhj=xiangxhj;
			}
		}
		if(xiangxhj!=0)
		{
			nArrayHandleNextLine.Add(nHandleLine);
			CString DCname;
			GetEntName(xiangxhj,DCname);
			CString EntName;
			GetEntBlkNameByHandle(xiangxhj,EntName);
			if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
			{
				DCname+=_T("D");
			}
			return 1;
		}
		// 		callcnt++;
		CString strGuidaoName;
		m_mysys.GetXdata(nHandleLine,_T("GUIDAONAME"),strGuidaoName);
		// 		if(xiangxhj!=0)
		// 		{
		// 			//该敌对信号机在调车进路内已经包括，无需再次加入，可以直接返回
		// 			return 1;
		// 		}
		//求后继轨道线
		CLongArray nArrayHandleNextLineTemp;
		long nHandleLineEnd=0;
		//long Lastdaocha=0;
		CLongArray nArrayHandleThisDaocha;
		CStringArray GuoDaocha;
		CStringArray GuoXHJ;
		DiaoCheFindNextLineAndXHJ( nHandleLine,nHandleLineEnd,GuoDaocha,Gudao,LastDaocha,nArrayHandleThisDaocha,GuoXHJ,nArrayHandleNextLineTemp,bfoward);
		int cnt=nArrayHandleNextLineTemp.GetCount();
		CString strGuidaoName2;
		for(int i=0;i<cnt;i++)
		{
			m_mysys.GetXdata(nArrayHandleNextLineTemp.GetAt(i),_T("GUIDAONAME"),strGuidaoName2);
		}
		for(int i=0;i<nArrayHandleNextLineTemp.GetCount();i++)
		{
			//向右推进时，寻找轨道左端信号机，向左推进时寻找轨道右端信号机
			m_mysys.GetXdata(nArrayHandleNextLineTemp.GetAt(i),_T("GUIDAONAME"),strGuidaoName2);
			if(strGuidaoName2==_T("16DG"))
			{
				i=i;
			}
			if(i==0)
			{
				i=i;
			}
			if(i==1)
			{
				i=i;
			}
			if(i==2)
			{
				i=i;
			}
			if(i==3)
			{
				i=i;
			}
			iToward =bfoward;
			long zhixhj=0;
			long xiangxhj=0;
			long HandleDC=nArrayHandleThisDaocha[i];
			double pt_DC_x=0;
			double pt_xhj_x=0;
			CString strDCname;
			GetEntName(HandleDC,strDCname);
			GetGuiDaoDuanXHJ(iToward,nArrayHandleNextLineTemp[i],zhixhj,xiangxhj);
			if(bfoward==true)
			{
				if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
				{
					if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x>pt_DC_x)
						{
							zhixhj=zhixhj;
						}
						else
						{
							zhixhj=0;
						}

					}
					if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x>pt_DC_x)
						{
							xiangxhj=xiangxhj;
						}
						else
						{
							xiangxhj=0;
						}

					}
				}
				else
				{
					zhixhj=zhixhj;
					xiangxhj=xiangxhj;
				}
			}
			else
			{
				if(GetBlockPosition_X(HandleDC,pt_DC_x)==TRUE)
				{
					if((GetBlockPosition_X(zhixhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x<pt_DC_x)
						{
							zhixhj=zhixhj;
						}
						else
						{
							zhixhj=0;
						}

					}
					if((GetBlockPosition_X(xiangxhj,pt_xhj_x)==TRUE))
					{
						if(pt_xhj_x<pt_DC_x)
						{
							xiangxhj=xiangxhj;
						}
						else
						{
							xiangxhj=0;
						}

					}
				}
				else
				{
					zhixhj=zhixhj;
					xiangxhj=xiangxhj;
				}
			}
			if(xiangxhj!=0)
			{
				nArrayHandleNextLine.Add(nArrayHandleNextLineTemp[i]);
				CString DCname;
				GetEntName(xiangxhj,DCname);
				CString EntName;
				GetEntBlkNameByHandle(xiangxhj,EntName);
				if(EntName.Left(6)==_T("XHJ_LJ")||EntName.Left(6)==_T("XHJ_LF"))
				{
					DCname+=_T("D");
				}
				//DCname+=_T("D");
				//DCname=_T("至")+DCname;
				nArrayDiDuiDC.Add(DCname);
				strArrayDaocha.Add(GuoDaocha[i]);
			}
			else
			{			
				FindNextDuiXiangDCByLine2(nArrayHandleNextLineTemp[i],nArrayHandleThisDaocha[i],Gudao,nArrayHandleNextLine,nArrayDiDuiDC,strArrayDaocha,bfoward);
			}
		}
		return 1;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!FindNextDuiXiangDCByLine2"));
		return -2;
	}	
}
/*******************函数说明:GetNextDCXHJByDCXHJ***********************************************************************************/
/**********功能：通过一个调车起始信号机，返回调车基本进路的下一个调车信号机******************************************************/
/**********输入：nHandleDC,调车起始信号机；Gudao，股道名称；JieJinQuDuan，接近区段名称*************************************/
/**********输出：nArrayHandleNextLine,下一个调车信号机所在的轨道区段; strArrayDC,下一个调车信号机的名称**********************/
/*****************nArrayHandleNextLine,为调车进路的终端轨道，为终端信号机的前一个轨道区段*******************************************************************************************************************/
/**********************************2015-06-03 am 10:58 by luo********************************************************************/
/**********************************2015-07-10 am 9:48 modified by luo*************************************************************************************************/
int CZnSxt::GetNextDCXHJByDCXHJ( const long nHandleDC,CStringArray& Gudao,CStringArray& JieJinQuDuan,CLongArray& nArrayHandleNextLine,CStringArray& strArrayDC )
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		int iXHJ_Count=0;
		if(nHandleDC==0)
		{
			return -1;
		}
		//获取信号机方向
		int iToward =-1;
		if(this->GetBlockToward(nHandleDC,iToward)!=TRUE)
		{
			return -1;
		}
		bool bfoward=false;
		if(iToward==1)
		{
			bfoward=true;
		}
		long nHandleLine=0;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
		if(bfoward==false)
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLine) ;
		}
		else
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLine) ;
		}
		//根据当前线获取后继线上的信号机
		long LastDaocha=0;
		FindNextDCByLine(nHandleLine,LastDaocha,Gudao,JieJinQuDuan,nArrayHandleNextLine,strArrayDC,bfoward);
		return 0;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetNextDCXHJByDCXHJ"));
		return -2;
	}		
}
int CZnSxt::GetXHJ_YouCe_GdLine(  long nHandleDC,long &nHandleLine,bool &foward)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		int iXHJ_Count=0;
		if(nHandleDC==0)
		{
			nHandleLine=0;
			return -1;
		}
		//获取信号机方向
		int iToward =-1;
		if(this->GetBlockToward(nHandleDC,iToward)!=TRUE)
		{
			return -1;
		}
		//bool bfoward=false;
		if(iToward==1)
		{
			foward=true;
		}
		else
		{
			foward=false;
		}
		//long nHandleLine=0;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
		if(foward==false)
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLine) ;
		}
		else
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLine) ;
		}
		//根据当前线获取后继线上的信号机
		return 0;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetNextDCXHJByDCXHJ"));
		return -2;
	}		
}
int CZnSxt::GetJYJ_YouCe_GdLine(  long nHandleJYJ,long &nHandleLine)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		int iXHJ_Count=0;
		if(nHandleJYJ==0)
		{
			nHandleLine=0;
			return -1;
		}
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleJYJ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLine) ;
		//根据当前线获取后继线上的信号机
		return 0;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetJYJ_YouCe_GdLine"));
		return -2;
	}		
}
int CZnSxt::GetXHJ_ZuoCe_GdLine(  long nHandleDC,long &nHandleLine,bool &foward)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		int iXHJ_Count=0;
		if(nHandleDC==0)
		{
			nHandleLine=0;
			return -1;
		}
		//获取信号机方向
		int iToward =-1;
		if(this->GetBlockToward(nHandleDC,iToward)!=TRUE)
		{
			return -1;
		}
		//bool bfoward=false;
		if(iToward==1)
		{
			foward=true;
		}
		else
		{
			foward=false;
		}
		//long nHandleLine=0;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
		if(foward==false)
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLine) ;
		}
		else
		{
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLine) ;
		}
		//根据当前线获取后继线上的信号机
		return 0;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetXHJ_ZuoCe_GdLine"));
		return -2;
	}		
}
int CZnSxt::GetJYJ_ZuoCe_GdLine(  long nHandleJYJ,long &nHandleLine)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		int iXHJ_Count=0;
		if(nHandleJYJ==0)
		{
			nHandleLine=0;
			return -1;
		}
		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleJYJ) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLine) ;
		//根据当前线获取后继线上的信号机
		return 0;
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetXHJ_ZuoCe_GdLine"));
		return -2;
	}		
}
void CZnSxt::GetHandleByName( CString str_ent_name,long &nHandle )
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		long nHandleTem=0;
		if(str_ent_name!=_T(""))
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_name='%s'"), str_ent_name.GetString()) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"),nHandleTem);
		}
		//strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
		//long nHandleFwLine = 0 ;
		//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
		nHandle =nHandleTem;
	
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		//return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetHandleByName"));
		//return -2;
	}		

}
void CZnSxt::GetHandleByEntBlkName( CString str_ent_blk_name,long &nHandle )
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		long nHandleTem=0;
		if(str_ent_blk_name!=_T(""))
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_block='%s'"), str_ent_blk_name) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"),nHandleTem);
		}
		//strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
		//long nHandleFwLine = 0 ;
		//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
		nHandle =nHandleTem;

	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		//return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetHandleByEntBlkName"));
		//return -2;
	}		

}
void CZnSxt::GetEntBlkNameByHandle( const long nHandle,CString &str_ent_name)
{
	try
	{
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		//long nHandleTem=0;
		if(nHandle!=0)
		{
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandle) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_block"),str_ent_name);
		}
		//strSql.Format(_T("select sxt_ent_fwline_handle from sxt_ent where sxt_ent_handle=%d"), nHandleDc) ;
		//long nHandleFwLine = 0 ;
		//m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleFwLine) ;
		//nHandle =nHandleTem;

	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		//return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in GetEntBlkNameByHandle"));
		//return -2;
	}		

}

BOOL CZnSxt::FindNextLineByJYJ( long nHandleLineStart,long &nHandleLineNext,bool bForward )
{
	try
	{
		if(nHandleLineStart==0)
		{
			return FALSE;
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForward?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		//long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForward?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleLineNext);
		return TRUE;
	
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return FALSE;
		//return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextLineByJYJ"));
		//return -2;
		return FALSE;
	}		
	return FALSE;
}

BOOL CZnSxt::GetClosedPointToLine( AcGePoint3d& GivePt,AcGePoint3d & DestPt,long nHandleLine,int& upordown )
{
	AcDbPolyline *pLineEnt=NULL;
	AcDbObjectId LeftLineId;
	BOOL bRet=FALSE;
	m_mysys.GetObjectId(LeftLineId,nHandleLine);
	if(acdbOpenObject(pLineEnt,LeftLineId,AcDb::kForRead)==Acad::eOk)
	{
		pLineEnt->getClosestPointTo(GivePt,DestPt,Adesk::kFalse);
	}
	//如果得到的点在线上，而不是端点
	if(CPolylineUtil::PointIsPolyVert(pLineEnt,CConvertUtil::ToPoint2d(DestPt),1e-7)!=true)
	{
		if(GivePt.y-DestPt.y>1e-6)
		{
			upordown=1;
		}
		else
		{
			upordown=0;
		}
		bRet =TRUE;

	}
	//acutPrintf(_T("\ndest x=%6f,y=%6f,z=%6f"),destP.x,destP.y,destP.z);
	pLineEnt->close();
	return bRet;
}

BOOL CZnSxt::FindCXGuiDao( const long nHandleCXJYJ,long & nHandleLineConLeft,long& nHandleLineCXLeft,long& nHandleLineConRight,long& nHandleLineCXRight ,CString& str_CX_GdName_left,CString &str_CX_GdName_Right)
{
	try
	{
		if(nHandleCXJYJ==0)
		{
			return FALSE;
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql ;
	   // acutPrintf(_T("\n找警冲标"));
		//查询超限绝缘节左线和右线
		int iFlag_find_left=-1;
		int iFlag_find_right=-1;
		nHandleLineConLeft=0;
		nHandleLineConRight=0;
		CString str_cx_guidao_left;
		CString str_cx_guidao_right;
		GetJYJ_ZuoCe_GdLine(nHandleCXJYJ,nHandleLineConLeft);
		GetJYJ_YouCe_GdLine(nHandleCXJYJ,nHandleLineConRight);
		CLongArray nArrayHandleJCB;
		long nHandleLeftJCB=0;
		long nHandleRightJCB=0;
		//获取所有警冲标
		GetSomeBlocks(_T("PMT_JC"),nArrayHandleJCB);
		//获取信号楼坐标
		long nHandleXHL=0;
		double pt_xhl_x=0;
		GetHandleByEntBlkName(_T("PMT_XHL_1"),nHandleXHL);
		if(GetBlockPosition_X(nHandleXHL,pt_xhl_x)==FALSE)
		{
			return FALSE;
		}
		//获取超限绝缘节坐标
		double pt_jyj_x=0;
		if(GetBlockPosition_X(nHandleCXJYJ,pt_jyj_x)==FALSE)
		{
			return false;
		}
		int shangxia=-1;
		if(pt_jyj_x-pt_xhl_x>1e-6)
		{
			//位于上行咽喉区
			shangxia=1;
		}
		else
		{
			//位于下行咽喉区
			shangxia=0;
		}
		//左右线合成一条线
		//对左线分析
		CLongArray nArrayHandleLeftDC;
		GetOnLineChaOrderByXDesc(nHandleLineConLeft,nArrayHandleLeftDC);
		CLongArray nArrayHandleRightDC;
		GetOnLineDaoChaOrderByXAsc(nHandleLineConRight,nArrayHandleRightDC);
		//CString DCname;
		int iCount_left=nArrayHandleLeftDC.GetCount();
		if(iCount_left!=0)
			str_cx_guidao_left+=_T("<");
		for(int i=0;i<iCount_left;i++)
		{
			CString str_DC;
			GetEntName(nArrayHandleLeftDC.GetAt(i),str_DC);
			if(i!=iCount_left-1)
			{
				str_cx_guidao_left+=str_DC;
			    str_cx_guidao_left+=_T("、");
			}
			else
			{
				str_cx_guidao_left+=str_DC;
				str_cx_guidao_left+=_T(">");
			}
		}
		//添加轨道名称
		CString Gdname;
		m_mysys.GetXdata(nHandleLineConLeft,_T("GUIDAONAME"),Gdname);
		str_cx_guidao_left+=Gdname;
		int iCount_right=nArrayHandleRightDC.GetCount();
		if(iCount_right!=0)
			str_cx_guidao_right+=_T("<");
		for(int i=0;i<iCount_right;i++)
		{
			CString str_DC;
			GetEntName(nArrayHandleRightDC.GetAt(i),str_DC);
			if(i!=iCount_right-1)
			{
				str_cx_guidao_right+=str_DC;
				str_cx_guidao_right+=_T("、");
			}
			else
			{
				str_cx_guidao_right+=str_DC;
				str_cx_guidao_right+=_T(">");
			}
		}
		//添加轨道名称
		CString Gdname2;
		m_mysys.GetXdata(nHandleLineConRight,_T("GUIDAONAME"),Gdname2);
		str_cx_guidao_right+=Gdname2;
		str_CX_GdName_left=str_cx_guidao_left;
		str_CX_GdName_Right=str_cx_guidao_right;
		for(int i=0;i<nArrayHandleLeftDC.GetCount();i++)
		{
			//获取道岔反位线以及iStart
			long nHandleDC=nArrayHandleLeftDC.GetAt(i);
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
			//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			//反位线对应的道岔
			long nHandleLineFw=0;
			int IsStart=-1;
			m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleLineFw);
			if(nHandleLineFw!=0)
			{
				if(IsStart==0)
				{
					//是否为渡线
					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineFw) ;
					long nLineType = 0 ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
					if(nLineType==1)
					{
						//渡线，需要再求一次后继
						long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineFw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineFw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
						//如果是向右寻找，则找右端绝缘节。
						int nHandleEndConJyj = nHandleRightJyj2; //线末端连接的绝缘节handle
						long nHandleLineFw2 = 0 ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
						CString strFieldName = _T("sxt_ent_conline_right");
						//读取结果集
						m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleLineFw2);
						//合成一条线，找出相应的警冲标，并判断是否超限
						//AcDbPolyline *pPoly= new AcDbPolyline(,,);
						//GetClosedPointToLine()
						//CLongArray 
						//GetSomeBlocks(_T("PMT_JC"))
						for(int i=0;i<nArrayHandleJCB.GetCount();i++)
						{
							AcGePoint3d GivePt;
							AcGePoint3d DestPt1,DestPt2,DestPt3,DestPt4;
							int up1=-1;
						    int up2=-1;
							int up3=-1;
							int up4=-1;
							CString JCBName;
							GetEntName(nArrayHandleJCB.GetAt(i),JCBName);
							if(JCBName==_T("581"))
							{
								JCBName=JCBName;
							}
							GetBlockPosition(nArrayHandleJCB.GetAt(i),GivePt);
							if(GetClosedPointToLine(GivePt,DestPt1,nHandleLineConLeft,up1)==TRUE||GetClosedPointToLine(GivePt,DestPt2,nHandleLineConRight,up2)==TRUE)
							{
								if(GetClosedPointToLine(GivePt,DestPt3,nHandleLineFw,up3)==TRUE||GetClosedPointToLine(GivePt,DestPt4,nHandleLineFw2,up4)==TRUE)
								{
									if((up1+up3)==1||(up2+up3)==1||(up1+up4)==1||(up2+up4)==1)
									{
										nHandleLeftJCB=nArrayHandleJCB.GetAt(i);
										CString JCBName;
										GetEntName(nHandleLeftJCB,JCBName);
										//acutPrintf(_T("\n渡线 找到 JCB:%s"),JCBName);
										//需要判断是否超限，获取超限绝缘节属性值
										CString strDist;
										m_mysys.GetAttValue(nHandleCXJYJ,_T("DIST"),strDist);
										strDist.Remove(_T('('));
										strDist.Remove(_T(')'));
										int i_dist_JYJ=StrToIntA(strDist);
										int i_dist_JCB=StrToIntA(JCBName);
										if(i_dist_JCB-i_dist_JYJ<4)
										{
											acutPrintf("\n渡线 超限：%d %d %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_right);
											nHandleLineCXLeft=nHandleLineFw;
											iFlag_find_left=1;
											break;
										}
										
									}
								}

							}
						}

					}
					else
					{
						//非渡线
						for(int i=0;i<nArrayHandleJCB.GetCount();i++)
						{
							AcGePoint3d GivePt;
							AcGePoint3d DestPt1,DestPt2,DestPt3,DestPt4;
							int up1=-1;
							int up2=-1;
							int up3=-1;
							//bool up4=false;
							nHandleLeftJCB=nArrayHandleJCB.GetAt(i);
							CString JCBName;
							GetEntName(nHandleLeftJCB,JCBName);
							if(JCBName==_T("581"))
							{
								JCBName=JCBName;
							}
							GetBlockPosition(nArrayHandleJCB.GetAt(i),GivePt);
							if(GetClosedPointToLine(GivePt,DestPt1,nHandleLineConLeft,up1)==TRUE||GetClosedPointToLine(GivePt,DestPt2,nHandleLineConRight,up2)==TRUE)
							{
								if(GetClosedPointToLine(GivePt,DestPt3,nHandleLineFw,up3)==TRUE)
								{
									if((up1+up3)==1||(up2+up3)==1)
									{
										nHandleLeftJCB=nArrayHandleJCB.GetAt(i);
										CString JCBName;
										GetEntName(nHandleLeftJCB,JCBName);
										//acutPrintf(_T("\n 非渡线 找到JCB:%s"),JCBName);
										CString strDist;
										m_mysys.GetAttValue(nHandleCXJYJ,_T("DIST"),strDist);
										strDist.Remove(_T('('));
										strDist.Remove(_T(')'));
										int i_dist_JYJ=StrToIntA(strDist);
										int i_dist_JCB=StrToIntA(JCBName);
										if(i_dist_JCB-i_dist_JYJ<4)
										{
											acutPrintf("\n非渡线  超限：%d %d %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_right);
											nHandleLineCXLeft=nHandleLineFw;
											iFlag_find_left=1;
											break;
										}
										
									}
								}

							}
						}

					}
				}
				else
				{
					continue;
				}
				

			}
			else
			{
				acutPrintf(_T("\n道岔反位线不存在，数据录入错误！"));
			}
			if(iFlag_find_left==1)
			{
				break;
			}
		}
		//可能为某一个道岔的反位线
		strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineConLeft) ;
		//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//获取对应的定位线
		long nHandleLineDw=0;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleLineDw);
		if(nHandleLineDw!=0)
		{
			for(int i=0;i<nArrayHandleJCB.GetCount();i++)
			{
				AcGePoint3d GivePt;
				AcGePoint3d DestPt1,DestPt2,DestPt3,DestPt4;
				int up1=-1;
				int up2=-1;
				int up3=-1;
				//bool up4=false;
				nHandleLeftJCB=nArrayHandleJCB.GetAt(i);
				CString JCBName;
				GetEntName(nHandleLeftJCB,JCBName);
				if(JCBName==_T("581"))
				{
					JCBName=JCBName;
				}
				GetBlockPosition(nArrayHandleJCB.GetAt(i),GivePt);
				if(GetClosedPointToLine(GivePt,DestPt1,nHandleLineConLeft,up1)==TRUE||GetClosedPointToLine(GivePt,DestPt2,nHandleLineConRight,up2)==TRUE)
				{
					if(GetClosedPointToLine(GivePt,DestPt3,nHandleLineDw,up3)==TRUE)
					{
						if((up1+up3)==1||(up2+up3)==1)
						{
							nHandleLeftJCB=nArrayHandleJCB.GetAt(i);
							CString JCBName;
							GetEntName(nHandleLeftJCB,JCBName);
							//acutPrintf(_T("\n 非渡线 找到JCB:%s"),JCBName);
							CString strDist;
							m_mysys.GetAttValue(nHandleCXJYJ,_T("DIST"),strDist);
							strDist.Remove(_T('('));
							strDist.Remove(_T(')'));
							int i_dist_JYJ=StrToIntA(strDist);
							int i_dist_JCB=StrToIntA(JCBName);
							if(i_dist_JCB-i_dist_JYJ<4)
							{
								acutPrintf("\n反位线  超限：%d %d %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_right);
								iFlag_find_left=1;
								nHandleLineCXLeft=nHandleLineDw;
								break;
							}
						
						}
					}

				}
			//nHandleLineCXLeft =nHandleLineDw;
				if(iFlag_find_left==1)
				{
					break;
				}
		}
	}

		//从右线分析
		for(int i=0;i<nArrayHandleRightDC.GetCount();i++)
		{
			//获取道岔反位线以及iStart
			long nHandleDC=nArrayHandleRightDC.GetAt(i);
			strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleDC) ;
			//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
			//反位线对应的道岔
			long nHandleLineFw=0;
			int IsStart=-1;
			m_RecordSet.GetRecordValue(strSql,  _T("sxt_ent_fwline_vertex"),IsStart) ;
			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_fwline_handle"), nHandleLineFw);
			if(nHandleLineFw!=0)
			{
				if(IsStart>0)
				{
					//是否为渡线
					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLineFw) ;
					long nLineType = 0 ;
					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
					if(nLineType==1)
					{
						//渡线，需要再求一次后继
						long nHandleLeftJyj2 = 0, nHandleRightJyj2 = 0 ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineFw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj2) ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineFw) ;
						m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj2) ;      
						//如果是向右寻找，则找右端绝缘节。
						int nHandleEndConJyj =nHandleLeftJyj2; //线末端连接的绝缘节handle
						long nHandleLineFw2 = 0 ;
						strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
						CString strFieldName = _T("sxt_ent_conline_left");
						//读取结果集
						m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleLineFw2);
						//合成一条线，找出相应的警冲标，并判断是否超限
						//AcDbPolyline *pPoly= new AcDbPolyline(,,);
						//GetClosedPointToLine()
						//CLongArray 
						//GetSomeBlocks(_T("PMT_JC"))
						for(int i=0;i<nArrayHandleJCB.GetCount();i++)
						{
							AcGePoint3d GivePt;
							AcGePoint3d DestPt1,DestPt2,DestPt3,DestPt4;
							int up1=-1;
							int up2=-1;
							int up3=-1;
							int up4=-1;
							CString JCBName;
							GetEntName(nArrayHandleJCB.GetAt(i),JCBName);
							if(JCBName==_T("581"))
							{
								JCBName=JCBName;
							}
							GetBlockPosition(nArrayHandleJCB.GetAt(i),GivePt);
							if(GetClosedPointToLine(GivePt,DestPt1,nHandleLineConLeft,up1)==TRUE||GetClosedPointToLine(GivePt,DestPt2,nHandleLineConRight,up2)==TRUE)
							{
								if(GetClosedPointToLine(GivePt,DestPt3,nHandleLineFw,up3)==TRUE||GetClosedPointToLine(GivePt,DestPt4,nHandleLineFw2,up4)==TRUE)
								{
									if((up1+up3)==1||(up2+up3)==1||(up1+up4)==1||(up2+up4)==1)
									{
										nHandleRightJCB=nArrayHandleJCB.GetAt(i);
										CString JCBName;
										GetEntName(nHandleRightJCB,JCBName);
										//acutPrintf(_T("\n渡线 找到 JCB:%s"),JCBName);
										//需要判断是否超限，获取超限绝缘节属性值
										CString strDist;
										m_mysys.GetAttValue(nHandleCXJYJ,_T("DIST"),strDist);
										strDist.Remove(_T('('));
										strDist.Remove(_T(')'));
										int i_dist_JYJ=StrToIntA(strDist);
										int i_dist_JCB=StrToIntA(JCBName);
										if(i_dist_JCB-i_dist_JYJ<4&&shangxia==1)
										{
											acutPrintf("\n 渡线 超限：%d %d %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_left);
											nHandleLineCXRight=nHandleLineFw;
											iFlag_find_right=1;
											break;
										}
										else if(i_dist_JYJ-i_dist_JCB<4&&shangxia==0)
										{
											acutPrintf("\n 渡线 超限：%d %d %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_left);
											nHandleLineCXRight=nHandleLineFw;
											iFlag_find_right=1;
											break;
										}
									
									}
								}

							}
						}

					}
					else
					{
						//非渡线
						for(int i=0;i<nArrayHandleJCB.GetCount();i++)
						{
							AcGePoint3d GivePt;
							AcGePoint3d DestPt1,DestPt2,DestPt3,DestPt4;
							int up1=-1;
							int up2=-1;
							int up3=-1;
							//bool up4=false;
							nHandleRightJCB=nArrayHandleJCB.GetAt(i);
							CString JCBName;
							GetEntName(nHandleRightJCB,JCBName);
							if(JCBName==_T("581"))
							{
								JCBName=JCBName;
							}
							GetBlockPosition(nArrayHandleJCB.GetAt(i),GivePt);
							if(GetClosedPointToLine(GivePt,DestPt1,nHandleLineConLeft,up1)==TRUE||GetClosedPointToLine(GivePt,DestPt2,nHandleLineConRight,up2)==TRUE)
							{
								if(GetClosedPointToLine(GivePt,DestPt3,nHandleLineFw,up3)==TRUE)
								{
									if((up1+up3)==1||(up2+up3)==1)
									{
										nHandleLeftJCB=nArrayHandleJCB.GetAt(i);
										CString JCBName;
										GetEntName(nHandleLeftJCB,JCBName);
										//acutPrintf(_T("\n 非渡线 找到JCB:%s"),JCBName);
										CString strDist;
										m_mysys.GetAttValue(nHandleCXJYJ,_T("DIST"),strDist);
										strDist.Remove(_T('('));
										strDist.Remove(_T(')'));
										int i_dist_JYJ=StrToIntA(strDist);
										int i_dist_JCB=StrToIntA(JCBName);
										if((i_dist_JCB-i_dist_JYJ<4)&&shangxia==1)
										{
											acutPrintf("\n 非渡线 超限：%d %d %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_left);
											nHandleLineCXRight=nHandleLineFw;
										    iFlag_find_right=1;
											break;
										}
										else if((i_dist_JYJ-i_dist_JCB<4)&&shangxia==0)
										{
											acutPrintf("\n 非渡线 超限：%d %d %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_left);
											nHandleLineCXRight=nHandleLineFw;
											iFlag_find_right=1;
											break;
										}
									}
								}

							}
						}

					}
				}
				else
				{
					continue;
				}


			}
			else
			{
				acutPrintf(_T("\n道岔反位线不存在，数据录入错误！"));
			}
			if(iFlag_find_right==1)
			{
				break;
			}
		}
		//可能为某一个道岔的反位线
		strSql.Format(_T("select * from sxt_ent where sxt_ent_fwline_handle=%d"), nHandleLineConRight) ;
		//CString strFieldName = (bForword?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//获取对应的定位线
		long nHandleLineDw2=0;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_online_handle"), nHandleLineDw2);
		if(nHandleLineDw2!=0)
		{
			for(int i=0;i<nArrayHandleJCB.GetCount();i++)
			{
				AcGePoint3d GivePt;
				AcGePoint3d DestPt1,DestPt2,DestPt3,DestPt4;
				int up1=-1;
				int up2=-1;
				int up3=-1;
				//bool up4=false;
				nHandleRightJCB=nArrayHandleJCB.GetAt(i);
				CString JCBName;
				GetEntName(nHandleRightJCB,JCBName);
				if(JCBName==_T("581"))
				{
					JCBName=JCBName;
				}
				GetBlockPosition(nArrayHandleJCB.GetAt(i),GivePt);
				if(GetClosedPointToLine(GivePt,DestPt1,nHandleLineConLeft,up1)==TRUE||GetClosedPointToLine(GivePt,DestPt2,nHandleLineConRight,up2)==TRUE)
				{
					if(GetClosedPointToLine(GivePt,DestPt3,nHandleLineDw2,up3)==TRUE)
					{
						if((up1+up3)==1||(up2+up3)==1)
						{
							nHandleLeftJCB=nArrayHandleJCB.GetAt(i);
							CString JCBName;
							GetEntName(nHandleLeftJCB,JCBName);
							//acutPrintf(_T("\n 非渡线 找到JCB:%s"),JCBName);
							CString strDist;
							m_mysys.GetAttValue(nHandleCXJYJ,_T("DIST"),strDist);
							strDist.Remove(_T('('));
							strDist.Remove(_T(')'));
							int i_dist_JYJ=StrToIntA(strDist);
							int i_dist_JCB=StrToIntA(JCBName);
							if(i_dist_JCB-i_dist_JYJ<4)
							{
								acutPrintf("\n 反位线 超限：%d %d  %s",i_dist_JYJ,i_dist_JCB,str_cx_guidao_left);
								nHandleLineCXRight=nHandleLineDw2;
								iFlag_find_right=1;
								break;
							}
							
						}
					}

				}
			}

		}
			
		//nHandleLineCXRight =nHandleLineDw2;

	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);   
		return FALSE;
		//return -2;
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindCXGuiDao"));
		//return -2;
		return FALSE;
	}		
	return FALSE;

}
/*****************************函数     FindALLChaoXianGuiDao*****************************************************************************************************/
/*****功能：用于找出平面图上所有的超限绝缘情况，返回超限时走过的区段句柄和应该占用的轨道区段名称***************************************************************************************************************/
/*****输入：无，即信号设备平面布置图数据全部来自数据库*************************************************************************************************************/
/*****输出：走过的区段句柄CLongArray& nArrayHandleLine，以及应该占用的轨道区段名称CStringArray& strArrayGuiDao***************************************************************************************************************************************************/
/*****注意：考虑超限绝缘时分别考虑了超限绝缘节为于定位线和反位线的情况，分别考虑了超限绝缘节左线道岔所在的定位和右线所在的定位线引起的超限绝缘，****/
/************在判断是否超限时，分别将超限绝缘节位置和对应的警冲标进行了比较。并分别考虑了超限绝缘节分别位于上行咽喉和下行咽喉的不同情况************************************************************************************************************/
/************使用该函数是，对平面图警冲标位置有一定要求，即要求对应警冲标必须位于绝缘节定位线和反位线围起来的区域内部（一个为警冲标的下方，一个位于警冲标的上方且必须是这样）************************************************************/
/********************* 注释 2015-06-17 pm-17:04 by luo*******************************************************************************************************************/
int CZnSxt::FindALLChaoXianGuiDao( CLongArray& nArrayHandleLine,CStringArray& strArrayGuiDao )
{
	//获取超限绝缘节
	CLongArray nArrayHandleJCB;
	CLongArray nArrayHandleCXJYJ;
	//用于存储超限绝缘时走的轨道区段
	//CLongArray nArrayHandleLine;
	//用于存储超限绝缘时应该占用的区段
	//CStringArray strArrayGuiDao;
	GetSomeBlocks(_T("PMT_JC"),nArrayHandleJCB);
	GetSomeBlocks(_T("JYJ_CX"),nArrayHandleCXJYJ);
	int iRet=0;
	for(int i=0;i<nArrayHandleCXJYJ.GetCount();i++)
	{
		long nHandleJYJ=0;
		nHandleJYJ=nArrayHandleCXJYJ.GetAt(i);	
		//long nHandleJYJ=nArrayHandleCXJYJ.GetAt(0);
		//求左线和右线
		long nHandleLeft=0;
		long nHandleRight=0;
		long nHandleCXLeft=0;
		long nHandleCXRight=0;
		bool foward=false;
		CString strGdLeft;
		CString strGdRight;
		FindCXGuiDao(nHandleJYJ,nHandleLeft,nHandleCXLeft,nHandleRight,nHandleCXRight,strGdLeft,strGdRight);
		if(nHandleCXLeft!=0)
		{
			nArrayHandleLine.Add(nHandleCXLeft);
			strArrayGuiDao.Add(strGdRight);
			iRet++;
		}
		if(nHandleCXRight!=0)
		{
			nArrayHandleLine.Add(nHandleCXRight);
			strArrayGuiDao.Add(strGdLeft);
			iRet++;
		}
	}
	acutPrintf(_T("\n 超限绝缘结果："));
	for(int i=0;i<nArrayHandleLine.GetCount();i++)
	{
		CString name;
		m_mysys.GetXdata(nArrayHandleLine.GetAt(i),_T("GUIDAONAME"),name);
		acutPrintf(_T("\n经过%s，须占用%s"),name,strArrayGuiDao.GetAt(i));
	}
	return iRet;

}

void CZnSxt::LSBExcel()
{
	ads_point base_pt={0,0,0};
	ads_getpoint(NULL,_T("\n选择起始点"),base_pt);
	AcGePoint3d base_pt3d;
	CUserSystem my_User;
	my_User.ConvertPtAdsTo3D(base_pt,base_pt3d);
	AcGePoint2d base_pt2d=CConvertUtil::ToPoint2d(base_pt3d);
	AcGePoint2d start_rectangle1_pt2d1=base_pt2d;
	start_rectangle1_pt2d1.x-=15;
	start_rectangle1_pt2d1.y+=9;
	float xls_len=400;
	AcGePoint2d start_rectangle1_pt2d2=base_pt2d;
	start_rectangle1_pt2d2.x+=(15+xls_len);
	start_rectangle1_pt2d2.y+=(9-287);
	CPolylineUtil::AddRectangle(start_rectangle1_pt2d1,start_rectangle1_pt2d2,0.5);
	AcGePoint2d start_rectangle2_pt2d1=base_pt2d;
	start_rectangle2_pt2d1.x-=40;
	start_rectangle2_pt2d1.y+=14;
	AcGePoint2d start_rectangle2_pt2d2=base_pt2d;
	start_rectangle2_pt2d2.x+=(20+xls_len);
	start_rectangle2_pt2d2.y+=(14-297);
	CPolylineUtil::AddRectangle(start_rectangle2_pt2d1,start_rectangle2_pt2d2,0);
	//创建圆形
	AcGePoint2d ptCenter_2d=start_rectangle1_pt2d1;
	ptCenter_2d.x-=12.41;
	ptCenter_2d.y-=227;
	CPolylineUtil::AddPolyCircle(ptCenter_2d,7.4,0);
	AcGePoint3d sign_point1=CConvertUtil::ToPoint3d(start_rectangle1_pt2d2);
	sign_point1.x+=-180+63;
	sign_point1.y+=17;
	CString tuname;
	CString tuhao;
	CString riqi;
	CString program_name1;
	CString program_name2;
	TCHAR*file_sign =_T("C:\\辅助开发\\my_sign.dwg");
	TCHAR *bsign=_T("my_sign");
	AcDbObjectId blockid = CBlockUtil::InsertDwgBlockDef(file_sign,bsign,1);
	//CBlockUtil::InsertBlockRef(blockid,ptStart);
	AcDbObjectId blkRefId = CBlockUtil::InsertBlockRefWithAttribute(blockid,sign_point1);
	AcDbBlockReference *pBlkRef =NULL;
	if(acdbOpenObject(pBlkRef,blkRefId,AcDb::kForWrite)==Acad::eOk)
	{
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("TUNAME_001"),tuname.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("TUHAO_001"),tuhao.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("RIQI_001"),riqi.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("PROGRAM_NAME_001"),program_name1.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("PROGRAM_NAME2_001"),program_name2.GetString());
		pBlkRef->close();
	}
	//以块方式插入
	AcGePoint3d jungong_point =CConvertUtil::ToPoint3d(start_rectangle1_pt2d1);
	TCHAR*filename =_T("C:\\辅助开发\\xiugai.dwg");
	TCHAR *bname =_T("jungong");
	AcDbObjectId blockid1 = CBlockUtil::CopyBlockDefFromOtherDwg(filename,bname);
	//CBlockUtil::InsertBlockRef(blockid,pt_Start);
	CBlockUtil::InsertBlockRef(blockid1,jungong_point);
	AcGePoint3d filename_point =CConvertUtil::ToPoint3d(start_rectangle1_pt2d1);
	filename_point.y-=287;
	TCHAR *bname2 =_T("filename");
	AcDbObjectId blockid2 = CBlockUtil::CopyBlockDefFromOtherDwg(filename,bname2);
	//CBlockUtil::InsertBlockRef(blockid,pt_Start);
	CBlockUtil::InsertBlockRef(blockid2,filename_point);

}
//根据生成的excel表的长度转化成CAD
void CZnSxt::XlsToLSB( AcGePoint3d start_pt_3d,float f_length_xls )
{
	//ads_point base_pt={0,0,0};
	//ads_getpoint(NULL,_T("\n选择起始点"),base_pt);
	AcGePoint3d base_pt3d=start_pt_3d;
	//CUserSystem my_User;
	//my_User.ConvertPtAdsTo3D(base_pt,base_pt3d);
	AcGePoint2d base_pt2d=CConvertUtil::ToPoint2d(base_pt3d);
	AcGePoint2d start_rectangle1_pt2d1=base_pt2d;
	start_rectangle1_pt2d1.x-=15;
	start_rectangle1_pt2d1.y+=9;
	float xls_len=f_length_xls;
	AcGePoint2d start_rectangle1_pt2d2=base_pt2d;
	start_rectangle1_pt2d2.x+=(15+xls_len);
	start_rectangle1_pt2d2.y+=(9-287);
	CPolylineUtil::AddRectangle(start_rectangle1_pt2d1,start_rectangle1_pt2d2,0.5);
	AcGePoint2d start_rectangle2_pt2d1=base_pt2d;
	start_rectangle2_pt2d1.x-=40;
	start_rectangle2_pt2d1.y+=14;
	AcGePoint2d start_rectangle2_pt2d2=base_pt2d;
	start_rectangle2_pt2d2.x+=(20+xls_len);
	start_rectangle2_pt2d2.y+=(14-297);
	CPolylineUtil::AddRectangle(start_rectangle2_pt2d1,start_rectangle2_pt2d2,0);
	//创建圆形
	AcGePoint2d ptCenter_2d=start_rectangle1_pt2d1;
	ptCenter_2d.x-=12.41;
	ptCenter_2d.y-=227;
	CPolylineUtil::AddPolyCircle(ptCenter_2d,7.4,0);
	AcGePoint3d sign_point1=CConvertUtil::ToPoint3d(start_rectangle1_pt2d2);
	sign_point1.x+=-180+63;
	sign_point1.y+=17;
	CString tuname;
	CString tuhao;
	CString riqi;
	CString program_name1;
	CString program_name2;
	TCHAR*file_sign =_T("C:\\辅助开发\\my_sign.dwg");
	TCHAR *bsign=_T("my_sign");
	AcDbObjectId blockid = CBlockUtil::InsertDwgBlockDef(file_sign,bsign,1);
	//CBlockUtil::InsertBlockRef(blockid,ptStart);
	AcDbObjectId blkRefId = CBlockUtil::InsertBlockRefWithAttribute(blockid,sign_point1);
	AcDbBlockReference *pBlkRef =NULL;
	if(acdbOpenObject(pBlkRef,blkRefId,AcDb::kForWrite)==Acad::eOk)
	{
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("TUNAME_001"),tuname.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("TUHAO_001"),tuhao.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("RIQI_001"),riqi.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("PROGRAM_NAME_001"),program_name1.GetString());
		CBlockUtil::SetBlockRefAttribute(pBlkRef,_T("PROGRAM_NAME2_001"),program_name2.GetString());
		pBlkRef->close();
	}
	//以块方式插入
	AcGePoint3d jungong_point =CConvertUtil::ToPoint3d(start_rectangle1_pt2d1);
	TCHAR*filename =_T("C:\\辅助开发\\xiugai.dwg");
	TCHAR *bname =_T("jungong");
	AcDbObjectId blockid1 = CBlockUtil::CopyBlockDefFromOtherDwg(filename,bname);
	//CBlockUtil::InsertBlockRef(blockid,pt_Start);
	CBlockUtil::InsertBlockRef(blockid1,jungong_point);
	AcGePoint3d filename_point =CConvertUtil::ToPoint3d(start_rectangle1_pt2d1);
	filename_point.y-=287;
	TCHAR *bname2 =_T("filename");
	AcDbObjectId blockid2 = CBlockUtil::CopyBlockDefFromOtherDwg(filename,bname2);
	//CBlockUtil::InsertBlockRef(blockid,pt_Start);
	CBlockUtil::InsertBlockRef(blockid2,filename_point);
}

BOOL CZnSxt::FindNextZhiGuidao( long nHandleLineStart,long &nHandleNextLine,bool bForward )
{
	try
	{
		if(nHandleLineStart==0)
		{
			nHandleNextLine=0;
			return FALSE;
		}
		CADORecordset cSet(&m_AdoDb) ;
		CString strSql;
		long nHandleLeftJyj = 0, nHandleRightJyj = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_right=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleLeftJyj) ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_conline_left=%d"), nHandleLineStart) ;
		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_handle"), nHandleRightJyj) ;      
		//如果是向右寻找，则找右端绝缘节。
		int nHandleEndConJyj = (bForward?nHandleRightJyj:nHandleLeftJyj) ; //线末端连接的绝缘节handle
		//long nHandleNextLine = 0 ;
		strSql.Format(_T("select * from sxt_ent where sxt_ent_type>=200 and sxt_ent_type<220 and sxt_ent_handle=%d"), nHandleEndConJyj) ;
		CString strFieldName = (bForward?_T("sxt_ent_conline_right"):_T("sxt_ent_conline_left")) ;
		//读取结果集
		m_RecordSet.GetRecordValue(strSql, strFieldName, nHandleNextLine);
		if(nHandleNextLine==0)
		{
			return FALSE;
		}
		else
		{
			return TRUE;
		}
	}
	catch(_com_error& e)
	{
		CString sBuff = CBlkUtility::GetErrorDescription(e);
		AfxMessageBox(sBuff);        
	}
	catch(...)
	{	
		AfxMessageBox(_T("未知的错误!in FindNextZhiGuiDao"));
	}	
	return FALSE;
}

void CZnSxt::FindFirstDiffString( vector<CString>&vec_str1,vector<CString>&vec_str2,CString &str_diff1,CString&str_diff2 )
{
	int iCnt_vec1=vec_str1.size();
	int iCnt_vec2=vec_str2.size();
	int iCnt=(iCnt_vec1<=iCnt_vec2?iCnt_vec1:iCnt_vec2);
	for(int i=0;i<iCnt;i++)
	{
		if(vec_str1[i]!=vec_str2[i])
		{
			str_diff1=vec_str1[i];
			str_diff2=vec_str2[i];
			break;
		}
	}
	return;

}

// int CZnSxt::GetYanHouDCXHJ( bool bSXYanHou,CStringArray& str_nArrayXHJ,CLongArray& nArrayHandleXHJ )
// {
// 	//获取所有调车信号机
//     CLongArray nArrayHandleAllDC;
// 	GetSomeBlocks(_T("XHJ_DC"),nArrayHandleAllDC);
// 	double pt_x=0;
// 	//获取信号楼坐标
// 	long nHandleXHL=0;
// 	GetHandleByName(_T("PMT_XHL_1"),nHandleXHL);
// 	if(nHandleXHL==0)
// 	{
// 		return 0;
// 	}
// 	GetBlockPosition_X(nHandleXHL,pt_x);
// 	if(bSXYanHou==true)
// 	{
// 		for(int i=0;i<nArrayHandleAllDC.GetCount();i++)
// 		{
// 			long nhandleDC=nArrayHandleAllDC.GetAt(i);
// 			if(nhandleDC!=0)
// 			{
// 				double pt_DC_x=0;
// 				GetBlockPosition_X(nhandleDC,pt_DC_x);
// 				if(pt_DC_x-pt_x>(1e-6))
// 				{
// 					nArrayHandleXHJ.Add(nhandleDC);
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int i=0;i<nArrayHandleAllDC.GetCount();i++)
// 		{
// 			long nhandleDC=nArrayHandleAllDC.GetAt(i);
// 			if(nhandleDC!=0)
// 			{
// 				double pt_DC_x=0;
// 				GetBlockPosition_X(nhandleDC,pt_DC_x);
// 				if(pt_DC_x-pt_x<1e-6)
// 				{
// 					nArrayHandleXHJ.Add(nhandleDC);
// 				}
// 			}
// 		}
// 	}
// 
// }

// void CZnSxt::SortStringArray( CStringArray &StrArray)
// {
// 	TCHAR del_char=_T('D');
// 	for(int i=0;i<StrArray.GetCount();i++)
// 	{
// 		//acutPrintf(_T("\n"));
// 		CString str_first=StrArray.GetAt(i);
// 		str_first.Remove(del_char);
// 		int int_fisrt=StrToIntA(str_first);
// 		acutPrintf(_T("int_first=%d"),int_fisrt);
// 		for(int j=i+1;j<StrArray.GetCount();j++)
// 		{
// 			CString strNext=StrArray.GetAt(j);
// 			strNext.Remove(del_char);
// 			int int_next=StrToIntA(strNext);
// 			acutPrintf(_T("int_next=%d"),int_next);
// 			if(int_fisrt>int_next)
// 			{
// 				CString temp=StrArray[j];
// 				StrArray.SetAt(j,StrArray.GetAt(i));
// 				StrArray.SetAt(i,temp);
// 				//acutPrintf("")
// 			}
// 
// 		}
// 	}
// 
// }


// void CZnSxt::LsbTest()
// {
// 	CLongArray nArrayHandle_LJ_XHJ;
// 	int iRet =GetAll_LJ_XHJ(nArrayHandle_LJ_XHJ);
// 	CLongArray nArrayHandle_LF_XHJ;
// 	CString name_xhj=_T("XHJ_LF");
// 	int iRet2 =GetSomeBlocks(name_xhj,nArrayHandle_LF_XHJ);
// 	acutPrintf(_T("\n iRet =%d"),iRet);
// 	acutPrintf(_T("\n 出站信号机个数=%d"),iRet2);
// 	//获取股道所在轨道
// 	CLongArray nAarryHandleGuDaoS;
// 	CLongArray nAarryHandleGuDaoX;
// 	for(int i=0;i<iRet2;i++)
// 	{
// 		CString entname;
// 		long nHandleLine =nArrayHandle_LF_XHJ[i];
// 		long nHandleLineTe;
// 		CString strSql;
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine) ;
// 		if(entname.Left(1)==_T("S"))
// 		{
// 			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLineTe) ;
// 			nAarryHandleGuDaoS.Add(nHandleLineTe);
// 		}
// 		else if(entname.Left(1)==_T("X"))
// 		{
// 			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLineTe) ;
// 			nAarryHandleGuDaoX.Add(nHandleLineTe);
// 		}
// 	}
// 	
// 	CADORecordset cSet(&m_AdoDb) ;
// 	CString strSql ;
// 	int length =nArrayHandle_LJ_XHJ.GetCount();
// 	if(length<1)
// 	{
// 		acutPrintf(_T("\n 信号机个数为%d"),length);
// 		return;
// 	}
// 	//打印进站信号机名称
// 	for(int i=0;i<length;i++)
// 	{
// 		CString entname;
// 		long nHandleLine =nArrayHandle_LJ_XHJ[i];
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),entname) ;
// 	    acutPrintf(_T("\n 进站信号机名称为%s"),entname.GetString());
// 		//查询进站信号机右侧直线
//         strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine);
// 		long nHandleLinetemp;
// 		 //寻找后一条轨道
// 		CLongArray nArrayHandle_GD_Next;
// 		//获取信号机右侧轨道
// 		if(entname.Left(1)==_T("X"))
// 		{
//           m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLinetemp) ;
// 		  this->FindNextLine(nHandleLinetemp,nArrayHandle_GD_Next,true);
// 		}
// 		else if(entname.Left(1)==_T("S"))
// 		{
//           m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLinetemp) ;
// 		  this->FindNextLine(nHandleLinetemp,nArrayHandle_GD_Next,false);
// 		}
// 		//将直线变色显示
// 		m_mysys.FlashEnt(nHandleLinetemp, 500, 50) ;
// 		m_mysys.SetEntColorIndex(nHandleLinetemp,1);
// 		//this->FindNextLine(nHandleLi)
// 	    //寻找后一条轨道
// 		//CLongArray nArrayHandle_GD_Next;
// 		//this->FindNextLine(nHandleLinetemp,nArrayHandle_GD_Next,true);
// 		if(nArrayHandle_GD_Next.GetCount()<1)
// 		{
// 			acutPrintf(_T("\n 没有后继轨道"));
// 		}
// 		else
// 		{
// 			for(int i=0;i<nArrayHandle_GD_Next.GetCount();i++)
// 			{
// 				//m_mysys.FlashEnt(nHandleLinetemp, 500, 50) ;
// 				long nHandleLinenext =nArrayHandle_GD_Next[i];
// 				m_mysys.SetEntColorIndex(nHandleLinenext,3);
// 				CLongArray nexthandle;
// 				if(entname.Left(1)==_T("S"))
// 				{
// 					this->FindNextLine(nHandleLinenext,nexthandle,false);
// 				}
// 				else
// 				{
// 					this->FindNextLine(nHandleLinenext,nexthandle,true);
// 				}
// 				for(int i=0;i<nexthandle.GetCount();i++)
// 				{
// 					//m_mysys.FlashEnt(nHandleLinetemp, 500, 50) ;
// 					long nHandleLine3 =nexthandle[i];
// 					strSql.Format(_T("select * from sxt_line where sxt_line_handle=%d"), nHandleLine3) ;
// 					long nLineType = -1 ;
// 					m_RecordSet.GetRecordValue(strSql, _T("sxt_line_type"), nLineType) ;
// 					acutPrintf(_T("\n 第三条线类型=%d"),nLineType);
// 					m_mysys.SetEntColorIndex(nHandleLine3,4);
// 			   }
// 		}
// 	}
// 	//打印出站信号机名称
// 	for(int i=0;i<iRet2;i++)
// 	{
// 		CString entname;
// 		long nHandleLine =nArrayHandle_LF_XHJ[i];
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine) ;
// 		m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_name"),entname) ;
// 		acutPrintf(_T("\n 出站信号机名称为%s"),entname.GetString());
// 		//查询进站信号机右侧直线
// 		strSql.Format(_T("select * from sxt_ent where sxt_ent_handle=%d"), nHandleLine);
// 		long nHandleLinetemp;
// 		//获取信号机右侧轨道,即为股道
// 		if(entname.Left(1)==_T("S"))
// 		{
// 			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_right"),nHandleLinetemp) ;
// 		}
// 		else if(entname.Left(1)==_T("X"))
// 		{
// 			m_RecordSet.GetRecordValue(strSql, _T("sxt_ent_conline_left"),nHandleLinetemp) ;
// 		}
// 		//将直线变色显示
// 		m_mysys.FlashEnt(nHandleLinetemp, 500, 50) ;
// 		//m_mysys.SetEntColorIndex(nHandleLinetemp,2);
// 	}
// 
// }
// 	
